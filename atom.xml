<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wei</title>
  
  
  <link href="http://wcx2001.github.io/atom.xml" rel="self"/>
  
  <link href="http://wcx2001.github.io/"/>
  <updated>2021-12-07T09:26:40.075Z</updated>
  <id>http://wcx2001.github.io/</id>
  
  <author>
    <name>小学渣的春天</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://wcx2001.github.io/2021/12/07/L3/"/>
    <id>http://wcx2001.github.io/2021/12/07/L3/</id>
    <published>2021-12-07T09:21:09.380Z</published>
    <updated>2021-12-07T09:26:40.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="course3：对极几何"><a href="#course3：对极几何" class="headerlink" title="course3：对极几何"></a>course3：对极几何</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>之前，我们已经看到了如何使用典型的相机校准程序或单视图测量方法，使用一个或多个视图来计算相机的固有和外在参数。这个过程最终是从一幅图像中推导出关于三维世界的属性。然而，一般来说，不可能仅仅从一张图像中恢复3D世界的整个结构。这是由于3D到二维映射的内在模糊性：一些信息只是丢失了。</p><p><img src="https://c1.im5i.com/2021/12/07/cLTdt.png" alt></p><p>图1：像现在这样的一个男人举起比萨斜塔的照片可能会导致模糊的场景。对同一个场景的多个视图可以帮助我们解决这些潜在的歧义。</p><p>例如，在图1中，我们最初可能会被愚弄，认为这个人是在举着比萨的斜塔。只有通过仔细的检查，我们才能发现情况并非如此，而仅仅是一种基于在图像平面上不同深度的投影的错觉。然而，如果我们能够从一个完全不同的角度来看这个场景，这个错觉就会立即消失，我们就会立即找出正确的场景布局。</p><p>这些课堂讲稿的重点是展示当有多个相机时，掌握几何知识是非常大的帮助。具体来说，我们将首先关注定义两个观点所涉及的几何，然后介绍这个几何如何帮助进一步理解我们周围的世界。</p><h2 id="3-2-对极几何"><a href="#3-2-对极几何" class="headerlink" title="3.2  对极几何"></a>3.2  对极几何</h2><p><img src="https://c1.im5i.com/2021/12/07/cL5oS.png" alt></p><p>图2：上极性几何结构的一般设置。灰色区域是上极平面。橙色的线是基线，而两条蓝色的线是上极性线。</p><p>通常在多视图几何图形中，多个相机、一个3D点和该点在每个相机图像平面上的投影之间存在着有趣的关系。与照相机、三维图像中的点和相应的观测结果相关联的几何形状被称为立体声对的上极性几何形状。</p><p>如图2所示，标准的外极性几何设置包括两个摄像机观察相同的三维点P，它们在每个图像平面上的投影分别位于$p$和$p’$处。摄像机中心位于$O_1$和$O_2$​，它们之间的线称为基线。我们称由两个相机中心定义的平面，P为上极平面。基线与两个图像相交的位置。</p><p><img src="https://c1.im5i.com/2021/12/07/cLHML.png" alt></p><p>图3：在图像对上绘制的上极性线及其对应点的一个例子。</p><p>平面被称为外极点$e$和$e’$。最后，由上极平面与两个图像平面的交点定义的线称为上极线。外极线具有在图像平面的外极上与基线相交的特性。</p><p><img src="/2021/12/07/L3/办公文件\大三上\CV\笔记\L3.assets\image-20211202232841394-16384589235163.png" alt="image-20211202232841394"></p><p>图4：当两个图像平面平行时，上极e和e0位于无穷远处。请注意，上极线平行于每个图像平面的u轴。</p><p>图4显示了一个有趣的上极几何情况，当图像平面彼此平行时。当图像平面相互平行时，外极$e$和$e’$位于无穷大，因此上极$e$和$e’$与图像平面平行。这种情况的另一个重要副产品是上极线平行于每个图像平面的一个轴。这种情况特别有用，并将在后面的图像校正一节中进行更详细的介绍。</p><p>然而，在现实世界中，我们并没有给出3D位置P的确切位置，但我们可以确定它在其中一个图像平面P中的投影。我们还应该能够知道相机的位置、方向和相机矩阵。我们能用这些知识做些什么呢？通过对相机位置$O_1$、$O_2$和图像点$p$的了解，我们可以定义上极平面。有了这个上极平面，我们就可以确定上极线1。根据定义，P对第二幅图像$p’$的投影必须位于第二幅图像的上极线上。因此，对外极几何的基本理解允许我们在不了解场景的三维结构的情况下创建图像对之间的强约束。</p><p><img src="https://c1.im5i.com/2021/12/07/cLthD.png" alt></p><p>图5：确定必要矩阵和基本矩阵的设置，这有助于跨视图绘制点和上极性线。</p><p>我们现在将尝试开发无缝的方法来绘制跨视图的点和外极性线。如果我们采用原始的外极性几何框架中给出的设置（图5），那么我们将进一步定义$M$​和$M_0$​​为将三维点映射到它们各自的二维图像平面位置的相机投影矩阵。让我们假设世界参考系统与第一个相机相关联，第二个相机的偏移首先通过旋转R，然后平移T。这指定了相机投影矩阵为：</p><script type="math/tex; mode=display">M=K[I\,\,\,0]\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,M'=K'[R^{\rm T}\,\,\,-R^{\rm T}T]\tag{1}</script><h2 id="3-本质矩阵"><a href="#3-本质矩阵" class="headerlink" title="3 本质矩阵"></a>3 本质矩阵</h2><p>在最简单的情况下，让我们假设我们有典型的相机，其中$K=K’=I$。这将公式1简化为</p><script type="math/tex; mode=display">M=[I\,\,\,0]\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,M'=[R^{\rm T}\,\,\,-R^{\rm T}T]\tag{2}</script><p>此外，这意味着$p’$​在第一个相机的参考系统是$Rp’+T$因为向量$Rp’+T$和$T$躺在上极平面，那么如果我们的交叉积$T×(Rp’+T)=T×(Rp’)$，我们将得到一个向量上极平面的正常。这也意味着位于上极平面的$p$与$T×(Rp’)$是正常，这给了我们它们的点积为零的约束：</p><script type="math/tex; mode=display">p^{\rm T}\cdot[T\times(Rp')]=0\tag{3}</script><p>从线性代数中，我们可以引入交叉积的一个不同的、紧的表达式：我们可以将任意两个向量a和b之间的交叉积表示为矩阵-向量乘法：</p><script type="math/tex; mode=display">a\times b=\begin{bmatrix}0 & -a_x & a_y\\a_z & 0 & -a_x\\-a_y & a_x & 0\end{bmatrix}\cdot\begin{bmatrix}b_x\\b_y\\b_z\end{bmatrix}=[a_{\times}]b\tag{4}</script><p>将此表达式与方程3相结合，我们可以将交叉积项转换为矩阵乘法，并给出</p><script type="math/tex; mode=display">\begin{matrix}p^{\rm T}\cdot[T_\times](R_p')=0\\p^{\rm T}[T_{\times}]Rp'=0\end{matrix}\tag{5}</script><p>矩阵$E=[T_×]R$被称为基本矩阵，为外极约束创建了一个紧凑的表达式：</p><script type="math/tex; mode=display">p^{\rm T}Rp'=0\tag{6}</script><p>本质矩阵是一个$3×3$​，其秩为$2$，包含$5$个自由度的奇异矩阵。</p><p>本质矩阵对于计算与$p$​和$p’$相关的上极线很有用。例如，$l’=E^Tp$​​给出了相机$2$的图像平面上的上极线。同样，$l=Ep’$给出了相机$1$的图像平面上的上极线。基本矩阵的其他有趣的性质是，它带外极点的点积等于零：$E^Te=Ee’=0$。因为对于相机$1$图像中的任何点$x$（$e$以外），相机$2$图像中对应的上极线$l’=E^Tx$包含外极$e’$。因此，$e’$满足所有x的$e’^T(E^Tx)=(e’^TE^T)x=0$，因此$Ee’=0$。同样，$E^Te=0$​​.</p><h2 id="4-基本矩阵"><a href="#4-基本矩阵" class="headerlink" title="4 基本矩阵"></a>4 基本矩阵</h2><p>虽然当我们有规范摄像机时，我们推导出了$p$和$p’$之间的关系，但当摄像机不再是规范摄像机时，我们应该能够找到一个更普遍的表达式。回想一下我们投影矩阵</p><script type="math/tex; mode=display">M=[I\,\,\,0]\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,M'=K'[R^{\rm T}\,\,\,-R^{\rm T}T]\tag{7}</script><p>首先，我们必须将$p_c=K^{−1}p$​​和$p’_c=K’^{−1}p’$​​定义为典型相机，即$P$对相应相机图像的投影。回想一下，在典型的情况：</p><script type="math/tex; mode=display">p_c^{\rm T}[T_\times]Rp_c'=0\tag{8}</script><p>通过替换$p_c$和$p’_c$​​的值，我们得到了</p><script type="math/tex; mode=display">p^{\rm T}K^{-\rm T}[T_\times]RK'^{-1}p'=0\tag{9}</script><p>矩阵$F=K’^{−T}[T_×]RK^{−1}$​​​被称为基本矩阵，其作用类似于前一节的基本矩阵，但也对相机矩阵$K$​​、$K’$​和摄像机之间的相对平移$T$​和旋转$R$​的信息进行编码。因此，即使相机矩阵$K$、$K’$和变换$R$、$T$未知，它也对计算与$p$和$p’$相关的上极线也很有用。与基本矩阵相似，我们可以仅从基本矩阵和相应的点计算外极线$l’=F^Tp$和$l=Fp’$​​。本质矩阵和基本矩阵之间的一个主要区别是，基本矩阵包含$7$个自由度，而本质矩阵包含$5$个自由度。</p><p>但是基本矩阵是怎么用的呢？就像基本矩阵一样，如果我们知道基本矩阵，那么简单地知道一个图像中的一个点就会给我们在另一个图像中对应点的一个简单的约束（上极线）。因此，在不知道$P$在三维空间中的实际位置，或相机的任何外在或内在特征的情况下，我们可以建立任何$p$和$p’$之间的关系。</p><h2 id="4-1-八点算法"><a href="#4-1-八点算法" class="headerlink" title="4.1 八点算法"></a>4.1 八点算法</h2><p>尽管如此，假设我们可以有基本矩阵，这是由相机参数的矩阵乘积定义的，似乎相当大。然而，在给定同一场景的两幅图像的情况下，可以通过不知道相机的外部或内在参数来估计基本矩阵。我们所讨论的方法称为八点算法；</p><p><img src="https://c1.im5i.com/2021/12/07/cLWXq.png" alt></p><p>图6：在各自的图像上以相同的颜色绘制相应的点。</p><p>该算法由朗格特-希金斯于1981年提出，并于1995年由哈特利进行扩展。如标题所示，八点算法假设两张图像之间至少有$8$对对应的点可用。</p><p>每个对应的$pi=(u^i，v^i，1)$和$p’i=(u’_i，v’_i，1)$都给出了外极约束$p^T_iFp’_i=0$​。我们可以重新表述该约束条件如下：</p><script type="math/tex; mode=display">\begin{bmatrix}u_iu_i' & v_i'u_i & u_i & u_i'v_i & v_iv_i' & v_i & u_i'& v_i' & 1\end{bmatrix}\cdot\begin{bmatrix}F_{11}\\F_{12}\\F_{13}\\F_{21}\\F_{22}\\F_{23}\\F_{31}\\F_{32}\\F_{33}\end{bmatrix}=0\tag{10}</script><p>由于这个约束是一个标量方程，所以它只约束一个自由度。由于我们只能知道基本矩阵，我们需要其中的$8$个约束来确定基本矩阵：</p><script type="math/tex; mode=display">\begin{bmatrix}u_1u_1' & v_1'u_1 & u_1' & u_1'v_1 & v_1v_1' & v_1 & u_1' & v_1' & 1\\u_2u_2' & v_2'u_2 & u_2' & u_2'v_2 & v_2v_2' & v_2 & u_2' & v_2' & 1\\u_3u_3' & v_3'u_3 & u_3' & u_3'v_2 & v_3v_3' & v_3 & u_3' & v_3' & 1\\u_4u_4' & v_4'u_4 & u_4' & u_4'v_4 & v_4v_4' & v_4 & u_4' & v_4' & 1\\u_5u_5' & v_5'u_5 & u_5' & u_5'v_5 & v_5v_5' & v_5 & u_5' & v_5' & 1\\u_6u_6' & v_6'u_6 & u_6' & u_6'v_6 & v_6v_6' & v_6 & u_6' & v_6' & 1\\u_7u_7' & v_7'u_7 & u_7' & u_7'v_7 & v_7v_7' & v_7 & u_7' & v_7' & 1\\u_8u_8' & v_8'u_8 & u_8' & u_8'v_8 & v_8v_8' & v_8 & u_8' & v_8' & 1\\\end{bmatrix}\cdot\begin{bmatrix}4F_{11}\\F_{12}\\F_{13}\\F_{21}\\F_{22}\\F_{23}\\F_{31}\\F_{32}\\F_{33}5\end{bmatrix}=0\tag{11}</script><p>可以化简为</p><script type="math/tex; mode=display">W\rm f = 0 \tag{12}</script><p>其中$W$​是由$N≥8$对应推导出的$N×9$矩阵，$f$是我们想要的基本矩阵的值。</p><p>在实践中，通常最好使用$8$个以上的对应项，并创建一个更大的$W$矩阵，因为它减少了噪声测量的影响。该齐次方程组的解可以通过奇异值分解(SVD)得到最小二乘意义上，因为W是有缺陷的。SVD将给出基本矩阵$\hat F$的估计值，它可能满秩。然而，我们知道真正的基本矩阵的秩为$2$。因此，我们应该寻找一个可以作为$\hat F$​的最佳秩-2近似的解决方案。为此，我们解决了以下优化问题：</p><script type="math/tex; mode=display">\begin{matrix}{\rm minimize}_{F}\,\,\,||F-\hat{F}||_{F}\\{\rm subject\,\,\, to}\,\,\, {\rm det}\,\,F=0\end{matrix}\tag{13}</script><p>这个问题再次用SVD解决，其中$\hat F=UΣV^T$​​，然后找到最佳的秩$-2$近似</p><script type="math/tex; mode=display">F=U\begin{bmatrix}\sum_1 & 0 & 0\\0 & \sum_2 & 0\\0 & 0 & 0\end{bmatrix}V^{\rm T}=0\tag{14}</script><h2 id="4-2-八点算法的归一化"><a href="#4-2-八点算法的归一化" class="headerlink" title="4.2 八点算法的归一化"></a>4.2 八点算法的归一化</h2><p>在实际应用中，八点算法的标准最小二乘方法并不精确。通常，一个点$p_i$​与其相应的上极线$l_i=Fp’$​之间的距离会非常大，通常在$10+$像素的尺度上。为了减少这个错误，我们可以考虑一个改进版本的八点算法，称为归一化八点算法。</p><p>标准八点算法的主要问题源于$W$对SVD是病态的。为了使SVD能够正常工作，$W$应该有一个奇异值等于（或接近）零，而其他奇异值为非零。然而，由于现代相机的像素范围(即$p_i=(1832,1023,1)$)，对应的$pi=(u_i，v_i，1)$在第一和第二坐标中往往具有极大的值。如果用于构造$W$的图像点在图像中一个相对较小的区域，那么$p_i$和$p’_i$​的每个向量通常会非常相似。因此，所构造的$W$矩阵将有一个非常大的奇异值，而其余的则相对较小。</p><p>为了解决这一问题，我们将在构造$w$之前对图像中的点进行归一化。这意味着我们通过对图像坐标进行平移和缩放来进行先决条件$W$，从而满足两个要求。首先，新坐标系的原点应位于图像点的质心（平移）。其次，变换后的图像点从原点处的均方距离应为$2$像素（缩放）。我们可以用一个变换矩阵$T$，$T_0$来紧凑地表示这个过程，该矩阵通过质心和缩放因子$(\frac{2N}{\sum_{i=1}^N||x_i-\bar{x}||^2})^{1/2}$​来转换。</p><p>然后，我们对坐标进行归一化：</p><script type="math/tex; mode=display">q_i=Tp_i\,\,\,\,\,\,\,\,\,\,\,\,q_i'=T'p_i'\tag{15}</script><p>利用新的归一化坐标，我们可以使用正则最小二乘八点算法来计算新的$F_q$​​。而矩阵$F_q$​​是归一化坐标的基本矩阵。为了使它在正则坐标空间上可用，我们需要将它去规范化，并给出</p><script type="math/tex; mode=display">F=T'^{\rm T}F_qT\tag{16}</script><p>最终，这个新的基本矩阵F在实际应用中得到了很好的效果。</p><h2 id="5-图像整改"><a href="#5-图像整改" class="headerlink" title="5 图像整改"></a><strong>5 图像整改</strong></h2><p>回想一下，当两个图像相互平行时，上极几何的一个有趣的情况发生了。让我们首先计算平行图像平面情况下的基本矩阵$E$。我们可以假设这两个相机有个相同的$K$，并且在相机之间没有相对旋转($R=I$)。在这种情况下，让我们假设只有一个沿$x$轴的平移，给出$T=(T_x,0,0)$​。这就给出了</p><script type="math/tex; mode=display">l=Ep'=\begin{bmatrix}0 & 0 & 0\\0 & 0 & -T_x\\ 0 & T_x & 0\end{bmatrix}\cdot\begin{bmatrix}u'\\v'\\1\end{bmatrix}=\begin{bmatrix}0\\-T_x\\ T_xv'\end{bmatrix}\tag{18}</script><p>我们可以看到$l$​的方向是水平的，$l’$​的方向也是水平的，它是用类似的计算方法计算的。</p><p>​        <img src="/2021/12/07/L3/办公文件\大三上\CV\笔记\L3.assets\image-20211204164507526-163860750878413.png" alt="image-20211204164507526"></p><p>图7：图像校正的过程包括计算两个同构态，我们可以应用于一对图像，使它们并行。</p><p>如果我们使用外极约束$p^TEp’=0$​，那么我们得到了$v=v’$的事实，证明了$p$和$p’$共享相同的$v$坐标。因此，在对应的点之间存在着一种非常直接的关系。因此，当识别图像中对应点之间的关系时，校正或使任意两个给定图像并行的过程变得有用。</p><p>​        <img src="/2021/12/07/L3/办公文件\大三上\CV\笔记\L3.assets\image-20211204164617398-163860757903614.png" alt="image-20211204164617398"></p><p>图8：校正问题的设置：我们计算了两个同构态，我们可以应用于图像平面，使得到的平面平行。</p><p>重新生成一对图像不需要知道两个相机矩阵$K$​、$K’$​或它们之间的相对变换$R$​、$T$。相反，我们可以使用由归一化八点算法估计的基本矩阵。在得到基本矩阵后，我们可以计算每个对应的$p_i$和$p’_i$的外极线$l_i$和$l’_i$​​。</p><p>从一组上极线中，我们可以估计每幅图像的上极e和e’。这是因为我们知道外极位于所有外极线的交点处。在现实世界中，由于噪声测量，所有的上极线不会在一个点上相交。因此，可以通过最小化拟合一个点的最小二乘误差来计算上极点。回想一下，每条上极线都可以表示为一个向量$l$​​，这样直线上的所有点（用均次坐标表示）都在集合{${x|l^Tx=0}$​​}中。如果我们将每条上极线定义为$l_i=[l_{i,1}\ \ l_{i,2} \ \ l_{i,3}]^T$​​，那么我们可以建立一个线性方程组，并使用SVD求解找到外极$e$​​：</p><script type="math/tex; mode=display">\begin{bmatrix}l_1^{\rm T}\\ \vdots\\l_n^{\rm T}\end{bmatrix}e = 0\tag{19}</script><p>在找到外极$e$​和$e’$​时，我们很可能会注意到它们不是沿横轴在无穷大的点。如果它们是，那么，根据定义，这些图像将已经是平行的。因此，我们获得了一些如何使图像平行的见解：我们能找到一个沿横轴映射到无穷大的同源线吗？具体来说，这意味着我们想要找到一对同形图$H_1$​，$H_2$​，我们可以应用于图像，将上极映射到无穷大。让我们从找到一个同调图$H_2$开始，即$11$将第二个外极子$e’$映射到横轴上无穷远处的一个点$(f,0,0)$。由于这种同质性有很多可能的选择，我们应该尝试选择一些合理的东西。在实践中导致良好结果的一个条件是坚持认为同源性就像一个变换，在图像中心附近的点上应用平移和旋转。</p><p>实现这种变换的第一步是变换第二幅图像，使其中心在齐次坐标下处于$(0,0,1)$​处。我们可以通过应用平移矩阵来实现这一点</p><script type="math/tex; mode=display">T=\begin{bmatrix}1 & 0 &  -\frac{\rm width}{2}\\0 & 1 & -\frac{\rm height}{2}\\0 & 0 & 1\end{bmatrix}\tag{20}</script><p>在应用平移后，我们通过旋转将其放置在某个点$(f,0,1)$的横轴上。如果平移的外极子$Te’$位于均次坐标$(e’_1, e’_2, 1)$​，则所应用的旋转为</p><script type="math/tex; mode=display">R=\begin{bmatrix}\alpha \frac{e_1'}{\sqrt{e_1'^2+e_2'^2}} & \alpha \frac{e_2'}{\sqrt{e_1'^2+e_2'^2}} & 0\\-\alpha \frac{e_2'}{\sqrt{e_1'^2+e_2'^2}} & \alpha \frac{e_1'}{\sqrt{e_1'^2+e_2'^2}} & 0\\0 & 0 & 1\end{bmatrix}\tag{21}</script><p>其中，$α=1$，如果是$e’_1≥0$​和$α=−1$，否则。应用此旋转后，请注意，给定$(f,0,1)$处的任意点，将其带到横轴$(f,0,0)$上的无穷远处，只需要应用变换</p><script type="math/tex; mode=display">G=\begin{bmatrix}1 & 0 & 0\\0 & 1& 0\\-\frac{1}{f} & 0 & 1\end{bmatrix}\tag{22}</script><p>在应用这个变换后，我们最终在无穷大处有一个外极，所以我们可以转换回正则图像空间。因此，我们应用在第二幅图像上来校正它的同源性$H_2$是</p><script type="math/tex; mode=display">H_2=T^{-1}GRT\tag{23}</script><p>现在找到了一个有效的$H_2$​，我们需要为第一张图像找到一个匹配的同调H1。我们通过找到一个变换H1来最小化图像对应点之间的平方距离的平方和</p><script type="math/tex; mode=display">\arg\min_{H_1} \sum_{i}||H_1p_i-H_2p_i'||^{2}\tag{24}</script><p>虽然推导$2$超出了这个类的范围，但我们可以证明匹配的$H_1$的形式是：</p><script type="math/tex; mode=display">H_1=H_A H_2M\tag{25}</script><p>其中，$F=[e]_×M$​​和</p><script type="math/tex; mode=display">H_A=\begin{bmatrix}a_1 & a_2 &a_3\\0 & 1 & 0\\0 & 0 & 1\end{bmatrix}</script><p>用$(a1、a2、a3)$组成计算特定向量a的元素。</p><p>首先，我们需要知道$M$​​是什么。任何$3×3$​斜对称矩阵$a$​的一个有趣的性质是一个$=A3$。因为任何交叉积矩阵$[e]_×$​​​都是偏对称的，而且我们只能知道基本矩阵$F$</p><script type="math/tex; mode=display">F=[e]_\times M =[e]_\times[e]_\times[e]_\times M=[e]_\times[e]_\times F\tag{27}</script><p>通过对正确的术语进行分组，我们可以找到它</p><script type="math/tex; mode=display">M=[e]_\times F\tag{28}</script><p>请注意，如果$M$的列由$e$的任意标量倍数添加，那么$F=[e]_×M$​仍然可以按缩放。因此，定义$M$的更一般的情况是</p><script type="math/tex; mode=display">M=[e]_\times F+e v^{\rm T}\tag{29}</script><p>对于一些向量$v$。在实践中，通过设置$v^{\rm T}=[1\ \  1\ \  1]$​来定义M的效果非常好。</p><p>为了最终求解$H_1$​，我们需要计算$H_A$​的$a$值。回想一下，我们想找到一个$H_1，H_2$来最小化公式$24$中提出的问题。因为我们已经知道$H_2$和$M$的值，那么我们可以用$\hat {p_i}=H_2Mp_i和\hat p’_i=H_2p’_i$​来代替，然后最小化问题就变成了</p><script type="math/tex; mode=display">\arg\min_{H_A}\sum_i||H_A\hat{p_i}-\hat{p_i'}||^2\tag{30}</script><p>特别地，如果我们让$\hat p_i=(\hat x_i，\hat y_i，1)$​和$\hat p_i=(\hat x_i，\hat y_i，1)$​​，那么最小化问题可以替换为：</p><script type="math/tex; mode=display">\arg\min_a\sum_{i}(a_1\hat{x_i}+a_2\hat{y_i}+a_3-\hat{x_i'})^2+(\hat{y_i}-\hat{y_i'})^2\tag{31}</script><p>由于$\hat y_i−\hat y’_i$​​是一个常数值，因此最小化问题进一步简化为</p><script type="math/tex; mode=display">\arg\min_a\sum_i(a_i\hat{x_i}+a_2\hat{y_i}+a_3-\hat{x_i'})^2\tag{32}</script><p>最终，这将分解为解决一个最小二乘问题$Wa = b$​</p><script type="math/tex; mode=display">W=\begin{bmatrix}\hat{x_1} & \hat{y_1} & 1\\& \vdots\\\hat{x_n} & \hat{y_n} & 1\end{bmatrix}\,\,\,\,\,\,\,\,b=\begin{bmatrix}\hat{x_1'}\\\vdots\\\hat{x_n'}\end{bmatrix}\tag{33}</script><p>在计算$a$后，我们可以计算$H_A$，最后是$H_1$。因此，我们生成了同态$H_1、H_2$​​来校正给定一些对应关系的任何图像对。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;course3：对极几何&quot;&gt;&lt;a href=&quot;#course3：对极几何&quot; class=&quot;headerlink&quot; title=&quot;course3：对极几何&quot;&gt;&lt;/a&gt;course3：对极几何&lt;/h1&gt;&lt;h2 id=&quot;5-1-概述&quot;&gt;&lt;a href=&quot;#5-1-概述&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>cs231a Course 2:单视图计量</title>
    <link href="http://wcx2001.github.io/2021/12/07/L2/"/>
    <id>http://wcx2001.github.io/2021/12/07/L2/</id>
    <published>2021-12-06T16:00:00.000Z</published>
    <updated>2021-12-07T05:06:18.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Course-2-单视图计量"><a href="#Course-2-单视图计量" class="headerlink" title="Course 2: 单视图计量"></a>Course 2: 单视图计量</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>在之前的课堂讲稿中，我们讨论了如何利用相机的外部和内在特性将点从真实的三维世界转换为数字图像。我们研究了如何在校准装置中使用已知的结构及其相应的图像来推断出这些相机的特性。这一次，我们将研究一个相关的问题：如果我们有一张图像，并知道拍摄图像的相机的属性，我们能恢复三维世界的已知结构吗？然后，我们将更一般地讨论，从单个图像中可以推导出哪些信息。</p><h2 id="2-2-二维变换"><a href="#2-2-二维变换" class="headerlink" title="2.2 二维变换"></a>2.2 二维变换</h2><p>为了更好地理解我们如何从图像中学习，我们应该能够首先了解二维空间中的各种转换。</p><p>等距变换是指保持距离的变换。在其最基本的形式中，等距法可以被描述为旋转矩阵$R$和平移矩阵$t$​。因此，在数学上，它们被定义为：</p><script type="math/tex; mode=display">\begin{bmatrix}x'\\y'\\1\end{bmatrix}=\begin{bmatrix}R & t\\0 &1\end{bmatrix}\cdot\begin{bmatrix}x \\ y \\ 1\end{bmatrix}</script><p>其中，R是$2\times 2$的矩阵​​，$t$​是一个$2\times1$​的向量，$[x’\,\,\,y’\,\,\, 1]^{\rm T}$​​​​是经过等距变换后得到的点。</p><p>附：此处推导</p><script type="math/tex; mode=display">\begin{align}\begin{bmatrix}R & t\\0 &1\end{bmatrix}\cdot\begin{bmatrix}x \\ y \\ 1\end{bmatrix}& =\begin{bmatrix}R_{11} & R_{12} & t_1\\R_{21} & R_{22} & t_2\\0 & 0 & 1\end{bmatrix}\cdot\begin{bmatrix}x\\y\\1\end{bmatrix}\\[2ex]& =\begin{bmatrix}R_{11}\cdot x+R_{12}\cdot y + t_1\\R_{21}\cdot x+ R_{22} \cdot y+ t_2\\1\end{bmatrix}=\begin{bmatrix}x'\\y'\\1\end{bmatrix}\end{align}</script><p>相似变换是指保持形状的转换。直观地说，它们可以做所有等距变换加上缩放的事情。在数学上，它们被记为：</p><script type="math/tex; mode=display">\begin{bmatrix}x'\\y'\\1\end{bmatrix}=\begin{bmatrix}SR & t\\0 &1\end{bmatrix}\cdot\begin{bmatrix}x \\ y \\ 1\end{bmatrix},S=\begin{bmatrix}s & 0 \\0 & s\end{bmatrix}</script><p>由于它们保留形状，它们也保持了长度和角度的比例。注意，当$s=1$时，每个等距转换都是相似变换的一种特定形式。然而，反之亦然，但事实并不成立。</p><p>仿射变换是保留点、直线和并行性的变换。对于某些向量$v$，一个仿射变换$T$被去定义为：</p><script type="math/tex; mode=display">T(v)=AV+t</script><p>其中，$A$是$R^{n}$的线性变换。在齐次坐标中，仿射变换通常被写成：</p><script type="math/tex; mode=display">\begin{bmatrix}x'\\y'\\1\end{bmatrix}=\begin{bmatrix}A & t\\0 & 1\end{bmatrix}\cdot\begin{bmatrix}x \\ y \\ 1\end{bmatrix}</script><p>从上面的方程可以很容易看到所有的相似之处（因此等距）都是亲缘的特殊情况。</p><p>投影变换或同态变换是任何将线映射到线的变换，但不一定保持并行性。在齐次坐标下，射影变换被表示为：</p><script type="math/tex; mode=display">\begin{bmatrix}x'\\y'\\1\end{bmatrix}=\begin{bmatrix}A & t\\v & b\end{bmatrix}\cdot\begin{bmatrix}x \\ y \\ 1\end{bmatrix}</script><p>我们看到该形式是仿射变换的进一步推广，因为额外的自由度与$v$。</p><p>尽管没有保持并行性，但射影变换仍然保持了点的共线性，因为它将线映射到线之间。此外，我们还证明了四个共线点的交比在射影变换下保持不变。交叉比在一条直线上取4个点$P_1$​、$P_2$、$P_3$、$P_4$​并进行计算</p><script type="math/tex; mode=display">{\rm cross \,\, radio  }= \frac{||P_3-P_1|| \,\,||P_4-P_2||}{||P_3-P_2||\,\,||P_4-P_1||}\tag{1}</script><p>我们将证明射影变换下交叉比的不变性作为一个类练习。</p><h2 id="2-3-在无限处的点和界限"><a href="#2-3-在无限处的点和界限" class="headerlink" title="2.3 在无限处的点和界限"></a>2.3 在无限处的点和界限</h2><p>线条对于确定图像中的结构很重要，所以了解它们在二维和三维中的定义是至关重要的。二维中的一条线可以用齐次向量$l=[a\,\,\,b\,\,\,c]^{\rm T}$来表示。他的比率$-\frac{a}{c}$捕获直线的斜率，比率$-\frac{c}{b}$捕获$y$截距。在形式上，二维线的定义为：</p><script type="math/tex; mode=display">\forall p =\begin{bmatrix}x\\y\end{bmatrix}\in l ,\begin{bmatrix}a & b &c\end{bmatrix}\cdot\begin{bmatrix}x\\y\\z\end{bmatrix}=0\tag{2}</script><p>一般来说，两直线$l$和$l’$将在一个点$x$处相交。该点定义为$l$和$l’$之间的交叉积。</p><p>证明：给定两条相交的线$l$​和$l’$​，交点$x$​应该同时位于直线$l$​和$l’$​上。因此，$x^{\rm T}l=0$​，$x^{\rm T}l’=0$​。如果我们设置$x=l×l’$​，那么根据叉积的定义，向量$x$​与向量$l$​和$l’$​都正交。根据正交性的定义，$x^{\rm T}l=0$​​，$x^{\rm T}l’=0$​。因此，$x$的这个定义满足了约束条件。</p><p>那么平行线的情况又如何呢？日常的知识期望这些线永远不会相交。然而，这个定义可以重写为这些线相交于无穷大。在齐次坐标下，在无穷远处的一个点被写为$[x\,\,\,y\,\,\,0]^{\rm T}$。回想一下，欧几里得坐标是通过将所有坐标除以最后一个坐标来收集的。在这种情况下，坐标为零，在无穷远处达到一个点。因此，齐次坐标给出了一个很好的确定交集的公式，即使是在平行线的情况下。</p><p>现在，让我们考虑两条平行线$l$和$l’$。当两条线平行时，它们的斜率相等，因此$\frac{a}{b}=\frac{a’}{b’}$。如果我们用均匀坐标来计算交点，那么我们可以验证</p><script type="math/tex; mode=display">l\times l' ∝\begin{bmatrix}b\\-a\\0\end{bmatrix}=x_{\infty}\tag{1}</script><p>因此，我们证实了我们的直觉，即两条平行线在最终相交。两条平行线在无穷大处的交点也称为理想点。在无穷远处的一个点的一个有趣的特性是，所有斜率相同的$-\frac{a}{b}$的平行线都通过这个理想点，如下图所示：</p><script type="math/tex; mode=display">l^{\rm T}x_{\infty}=\begin{bmatrix}a & b & c\end{bmatrix}\cdot\begin{bmatrix}b\\-a\\0\end{bmatrix}=0\tag{4}</script><p>无穷点的概念可以推广到定义有限度下的直线。考虑两对或更多对平行线。每一对平行线相交无穷远处$\{x_{∞，1}，…，x_{∞，n}\}$。在无穷远处通过所有这些点的线$l_∞$必须满足$\forall i,l_\infty^{\rm T}x_{\infty,i}=0$。这意味着$l_\infty=\begin{bmatrix} 0 &amp; 0 &amp;c\end{bmatrix}^{\rm T}$。由于$c$是一个任意的值，所以我们可以简单地定义$l_\infty=\begin{bmatrix} 0 &amp; 0 &amp;c\end{bmatrix}^{\rm T}$​​。</p><p><img src="https://c1.im5i.com/2021/12/07/cAje5.png" alt></p><p>​                                图1：无穷大处的点形成无穷大处的线。</p><p>如果我们将一个一般的射影变换$H$应用到无穷大$p_∞$处的一个点，那么将会发生什么呢？</p><script type="math/tex; mode=display">p'=Hp_{\infty}=\begin{bmatrix}A & t\\v & b\end{bmatrix}\cdot\begin{bmatrix}1\\1\\0\end{bmatrix}=\begin{bmatrix}p_x'\\p_y'\\p_z'\end{bmatrix}\tag{5}</script><p>请注意，$p’$的最后一个元素可能会变成非零，这表明射影变换通常将在无穷远处的点映射到不再在无穷远处的点。然而，仿射变换的情况并非如此，它将无穷远处的点映射到无穷远处的点：</p><script type="math/tex; mode=display">p'=Hp_{\infty}=\begin{bmatrix}A & t\\0 & 1\end{bmatrix}\cdot\begin{bmatrix}1\\1\\0\end{bmatrix}=\begin{bmatrix}p_x'\\p_y'\\0\end{bmatrix}\tag{6}</script><p>现在让我们将投影变换$H$应用到线$l$上，得到一个新的线$l’$。通过一条直线的所有点x都必须满足属性$x^{\rm T}l=0$。在转换后的空间中，我们知道线仍然映射到线，这意味着$x’l’=0$。我们可以使用身份属性来得到：</p><script type="math/tex; mode=display">x^{\rm T}I l = x^{\rm T}H^{\rm T}H^{\rm -T}l=0</script><p>如果我们对直线应用射影变换，那么所有的点也被变换，给出$x’=Hx$。这样我们就得到了$x^{\rm T}H^{\rm T}H^{\rm -T}l=x’^{\rm T}l’$，我们发现一条直线的射影变换是$l’=H^{\rm -T}l$。与我们在无穷远处的观测点相似，我们发现无穷远处的一条线的射影变换并不一定映射到无穷远处的另一条线。此外，仿射反式地层仍然将无穷远处的线映射到无穷远处的线。</p><h2 id="2-4-消失点和线条"><a href="#2-4-消失点和线条" class="headerlink" title="2.4 消失点和线条"></a>2.4 消失点和线条</h2><p>到目前为止，我们已经在二维中引入了无穷远处的线和点的概念。现在让我们在其相应的齐次坐标中引入三维的等价概念。</p><p>在3D世界中，我们现在被介绍到了平面的概念。我们可以将一个平面表示为一个向量$[a\,\,\,b\,\,\,c\,\,\,d]^{\rm T}$，其中$(a，b，c)$形成一个法向量，$d$是从原点到该法向量方向上的平面的距离。在形式上，一个平面被定义为满足的所有点$x$</p><script type="math/tex; mode=display">x^{\rm T}\begin{bmatrix}a\\b\\c\\d \end{bmatrix}=ax_1+ bx_2+cx_3+d=0\tag{7}</script><p>三维平面中的线被定义为两个平面的交点。由于它们有四个自由度（在每个三维空间中都定义了截距位置和斜率），因此它们很难在三维空间中很好地表示。更多细节请参见哈特利和齐瑟曼教科书的第3.2.2节。</p><p>然而，点在3D中的定义与在2D中的定义相似。三维中无穷远处的点再次被定义为三维中平行线的交点。此外，如果我们对无穷大$x_∞$处的其中一个点应用一个射影变换，那么我们就可以得到在图像平面上的$p_∞$点中，它在均匀坐标下不再在无穷远处。这个点$p_∞$被称为一个消失点。但是，我们能如何处理消失的点呢？</p><p>我们可以推导出三维平行线及其在图像中对应的消失点与相机参数$K$、$R$、$T$之间的有用关系。让我们将$d=(a、b、c)$定义为照相机参考系统中一组三维平行线的方向。这些线与无穷远处的一个点相交，在图像中这样一个点的投影返回消失点$v$，它被定义为：</p><script type="math/tex; mode=display">v=Kd\tag{8}</script><p>我们把上述方程的推导作为一个练习。可改写此方程，提取方向$d$：</p><script type="math/tex; mode=display">d=\frac{K^{-1}v}{||K^{-1}v||}\tag{9}</script><p>如果我们把一个平面$Π$作为一个平行线的超集，每一组平行线在无穷大的一点上相交。在无穷远处通过这一组点的线是在无穷远处与$Π$相关联的$l_∞$处的线。在无穷远处的一条线也被定义为两个平行平面相交的线。投影变换$l_\infty$到图像平面不再是无穷远处的一条线，被称为消失线或视界线$l_{\rm horiz}$。视界线是穿过图像中相应的消失点的一条线。视界线可以计算为：</p><script type="math/tex; mode=display">l_{\rm horiz}= H_p^{-T}l_{\infty}\tag{10}</script><p><img src="https://c1.im5i.com/2021/12/07/cA2iU.png" alt></p><p>​                                图2：从一组消失点中计算出的视界线。</p><p>视界线的概念允许我们像人类一样直观地推断出那些可能在数学上不容易表现出来的图像的属性。例如，在图2中，虽然地面上的线在图像坐标上不是平行的，但我们很自然地理解，它们在3D世界中是平行的。</p><p>此外，视界线允许我们计算关于这个世界的有用属性。例如，我们可以推导出三维平面的正规$n$与图像中相应的视界线$l_{\rm horiz}$​之间的有趣关系：</p><script type="math/tex; mode=display">n=K^{\rm T} l_{\rm horiz}\tag{11}</script><p>这意味着，如果我们能够识别与一个平面相关的视平线，如果我们的相机被校准，那么我们就可以估计该平面的方向。在引入有关消失点和线的最后一个性质之前，我们首先需要定义在无穷大$Π_∞$​处的平面。此平面的定义为一组2条或更多的消失线，由向量描述$[0\,\,\,0\,\,\,0\,\,\,1]^{\rm T}$​在均匀坐标。</p><p><img src="https://c1.im5i.com/2021/12/07/cAXU8.png" alt></p><p>图3：一组两条或多个消失线（蓝色线）定义了位于无穷大$Π_∞$处的平面（黄色平面）。</p><p><img src="https://c1.im5i.com/2021/12/07/cAW66.png" alt></p><p>图4：推导出两行之间的夹角。</p><p>最后引入的性质是将三维平面上的线和平面与图像平面上相应的消失点和线联系起来。假设三维中的两对平行线的方向分别为$d_1$​和$d_2$​，并与无穷大$x_{1,∞}$和$x_{2,∞}$处的点相关联。设$v_1$和$v_2$为相应的消失点。然后，我们发现利用余弦规则给出了$d_1$和$d_2$之间的夹角$θ$：</p><script type="math/tex; mode=display">\begin{align}\cos \theta &=\frac{d_1\cdot d_2}{||d_1||\,\,||d_2||}\\[2ex]& = \frac{v_1^{\rm T}\omega v_2}{\sqrt{v_1^{\rm T}\omega v_1}\sqrt{v_2^{\rm T}\omega v_2}}\end{align}\tag{12}</script><p>其中，$\omega=(KK^{\rm T})^{-1}$</p><p>我们可以将这个想法进一步扩展到三维平面的情况下，其中我们想在三维平面中关联不同的平面。回想一下，对于任何一个平面，我们都可以计算出它相关的消失线$l_{\rm horiz}$和他的标准化$K^{\rm T}l_{\rm horiz}$。因此，我们可以通过计算每个平面的法向量$n_1$和$n_2$之间的角来确定两个平面之间的角$θ$。我们推导出了分别有消失线$l_1$和$l_2$的两个平面之间的角$θ$：</p><script type="math/tex; mode=display">\begin{align}\cos\theta &=\frac{n_1\cdot n_2}{||n_1||\,\,||n_2||}\\[2ex]&=\frac{l_1^{\rm T}w^{-1}l_2}{\sqrt{l_1^{\rm ^{\rm T}}\omega^{-1}l_1}\sqrt{l_2^{\rm T}w^{-1}l_2}}\end{align}\tag{13}</script><h2 id="2-5-一个单个视图的计量学示例"><a href="#2-5-一个单个视图的计量学示例" class="headerlink" title="2.5 一个单个视图的计量学示例"></a>2.5 一个单个视图的计量学示例</h2><p><img src="https://c1.im5i.com/2021/12/07/cARQw.png" alt></p><p>图5：具有针对一对垂直平面的两个消失点的示例设置。</p><p>假设我们可以在一个三维世界的图像中识别出两个平面。另外，让我们假设我们可以在每个平面上识别出一对平行的线。这允许我们估计图像中的两个消失点$v_1$​和$v_2$​​。最后，假设我们知道这些平面在三维空间上是垂直的。在这种情况下，我们从方程$12$中知道，$v_1ωv_2=0$​。</p><p>但请回想一下，$ω$依赖于相机矩阵$K$，这在此时可能是未知的。因此，知道这两个消失点足以准确估计相机参数吗？考虑到$K$有$5$个自由度，而$v_1ωv_2=0$只提供了一个约束，我们没有足够的信息来计算$K$。如果我们能为另一个相互正交的平面找到另一个消失的$v_3$呢？然后我们就知道了$v_1ωv_2=v_1ωv_3=v_2ωv_3=0$。由于每对都给出一个约束，我们只得到计算$K$所需的$5$个约束中的$3$个。然而，如果我们假设相机有零偏角和正方形像素，那么我们可以添加所需的额外的两个约束条件。通过这些假设，我们就知道$ω$具有这种形式：</p><script type="math/tex; mode=display">w=\begin{bmatrix}w_1 & 0 & w_4\\0 & w_1 & w_5\\w_4 & w_5 & w_6\end{bmatrix}\tag{14}</script><p>如果您仔细注意到，在$ω$的定义中有四个变量。然而，我们只能大规模地了解$ω$，这将实际变量的数量减少到三个，从而可以解决它。一旦我们有了$ω$，那么我们就可以使用Cholesky分解来计算$K$。因此，我们已经设法用一张图像来校准照相机！</p><p>一旦知道了$K$，我们就可以重建场景的三维几何形状。例如，我们可以计算上述所有平面的方向。因此，一幅图像可以很容易地用来揭示它所捕获的场景的丰富信息。</p>]]></content>
    
    
    <summary type="html">本文是课程cs231a的第2节笔记</summary>
    
    
    
    <category term="计算机视觉" scheme="http://wcx2001.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="http://wcx2001.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="cs231a" scheme="http://wcx2001.github.io/tags/cs231a/"/>
    
  </entry>
  
  <entry>
    <title>cs231a Course 4：立体声系统和运动结构恢复</title>
    <link href="http://wcx2001.github.io/2021/12/07/L5/"/>
    <id>http://wcx2001.github.io/2021/12/07/L5/</id>
    <published>2021-12-06T16:00:00.000Z</published>
    <updated>2021-12-07T13:31:25.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Course-5：主动立体声和体积立体声"><a href="#Course-5：主动立体声和体积立体声" class="headerlink" title="Course 5：主动立体声和体积立体声"></a>Course 5：主动立体声和体积立体声</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>在传统立体声中，主要思想是利用相应的点$p$​和$p’$​通过三角剖分来估计三维点$P$​的位置。这里的一个关键挑战是解决对应问题：我们如何知道一个点$p$​是否真的对应于另一个图像中的一个点$p’$？我们需要处理场景中存在的许多三维点，这进一步强调了这个问题。这些注释的重点将讨论在重建三维结构中工作良好的替代技术。</p><h2 id="2-主动立体声"><a href="#2-主动立体声" class="headerlink" title="2 主动立体声"></a>2 主动立体声</h2><p><img src="/2021/12/07/L5/blog\source\_posts\视觉_5.assets\image-20211206212433636-16387970747231.png" alt="image-20211206212433636"></p><p>图1：将一个点投影到3D空间中的活动立体声设置。</p><p>首先，我们将介绍一种被称为主动立体声的技术，以帮助缓解传统立体声中的对应问题。主动立体声的主要思想是用一个与3D环境交互的设备取代两个相机中的一个，通常通过将图案投射到很容易从第二台相机的物体上识别。这种新的投影仪-相机对定义了与我们引入的相机对相同的超极几何，将替换相机的图像平面替换为投影仪虚拟平面。在图$1$中，投影仪用于将虚拟平面上的一个点$p$投影到三维空间中的物体上，在三维空间$P$中产生一个点。这个3D点$P$应该在第二台相机中作为一个点$p’$被观察到。因为我们知道我们在投影什么(例如，$p$在虚拟平面上的位置，投影的颜色和强度等)，我们可以很容易地在第二台相机$p’$中发现相应的观测结果。</p><p><img src="/2021/12/07/L5/blog\source\_posts\视觉_5.assets\image-20211206214854643-16387985356642.png" alt="image-20211206214854643"></p><p>图2：将一条直线投射到三维空间中的活动立体声设置。</p><p>主动立体声的一种常见策略是从虚拟平面上投影一条垂直条纹，而不是单个点。这种情况与点的情况非常相似，其中线$s$​被投影到三维空间$S$​中的一条条纹上，并在相机中观察为一条线为$s’$​。如果投影仪和照相机是平行的或校正的，那么我们可以通过简单地将$s’$​与水平的上极线相交来很容易地发现相应的点。从对应关系中，我们可以使用前面的课程注释中介绍的三角测量方法来重建条纹$s$上的所有三维点。通过在场景中滑动线并重复这个过程，我们可以恢复场景中所有可见物体的整个形状。</p><p>请注意，该算法工作的一个要求是，前投影器和相机需要校准。有源立体声系统可以使用前面注释中描述的类似技术进行校准。我们可以先使用一个校准装置来校准照相机。然后，通过将已知条纹投影到校准装置上，并利用新校准相机的相应观测结果，建立估计投影仪内在和外部参数的约束条件。一旦校准了，这种主动立体声设置可以产生非常准确的结果。2000年，马克·莱瓦伊和他在斯坦福大学的学生们证明，通过使用精细调整的激光扫描仪，他们可以以亚毫米的精度恢复米开朗基罗的圣塔的形状。</p><p>然而，在某些情况下，拥有一个精心调谐的投影仪可能太昂贵或麻烦。另一种使用更便宜得多的设置的方法是利用阴影为我们想要恢复的对象生成活动模式。通过在物体和光源之间的已知位置放置一根棍子，我们可以像以前一样有效地将一条条纹投射到物体上。移动棍子可以让我们在对象上投射不同的阴影条纹，并以类似的方式恢复对象。这种方法虽然便宜得多，但往往会产生不太准确的结果，因为它需要在棒、相机和光源之间进行非常好的校准，同时需要在棒的阴影的长度和厚度之间保持权衡。</p><p><img src="/2021/12/07/L5/blog\source\_posts\视觉_5.assets\image-20211206215038288-16387986391903.png" alt="image-20211206215038288"></p><p>图3：使用多条彩色线从单个投影中重建对象的活动立体声设置。</p><p>将一条条纹投射到物体上的一个限制是，它相当慢，因为投影仪需要滑动整个物体。此外，这意味着这种方法不能实时捕获变形。一个自然的扩展是尝试从前投影单个帧或图像来重建对象。其想法是将一种已知的不同条纹图案投射到物体的整个可见区域，而不是一条条纹。这些条纹的颜色的设计方式可以从图像中唯一地识别条纹。图3说明了这种多种颜色编码的条纹方法。这个概念为许多现代版本的深度传感器提供了动力，比如最初版本的微软Kinect。在实践中，这些传感器使用红外激光投影仪，使其能够在任何环境光条件下捕获3D视频数据。</p><h2 id="3-体积立体声"><a href="#3-体积立体声" class="headerlink" title="3 体积立体声"></a><strong>3 体积立体声</strong></h2><p><img src="/2021/12/07/L5/blog\source\_posts\视觉_5.assets\image-20211206215136068-16387986969364.png" alt="image-20211206215136068"></p><p>图4：体积立体声的设置，它从一个有限的工作体积中获取点，并执行一致性检查，以确定三维形状。</p><p>传统立体声和主动立体声方法的另一种替代方法是体积立体声，它扭转了利用对应关系来寻找三维结构的问题。在体积立体声中，我们假设我们试图估计的三维点在一些包含的已知体积范围内。然后，我们将假设的3D点投影到校准的相机中，并验证这些投影是否在多个视图中一致。图4说明了体积立体声问题的一般设置。因为这些技术假设我们想要重建的点包含在有限的体积中，所以这些技术主要用于恢复特定对象的三维模型，而不是恢复场景的模型，这可能是无界的。</p><p>任何体积立体方法的主要原则都是，当我们将包含体积中的三维点重新投影到多个图像视图中时，首先定义“一致”的含义。因此，根据一致观察概念的认识，可以引入不同的技术。在这些注释中，我们将简要概述三种主要的技术，即空间雕刻、阴影雕刻和体素着色。        </p><h2 id="3-1空间雕刻"><a href="#3-1空间雕刻" class="headerlink" title="3.1空间雕刻"></a>3.1空间雕刻</h2><p><img src="/2021/12/07/L5/blog\source\_posts\视觉_5.assets\image-20211206215226337-16387987471065.png" alt="image-20211206215226337"></p><p>图5：我们想要重建的一个对象的剪影包含了图像中该对象的可见部分的所有像素。视锥是可以投射到图像中对象的剪影中的所有可能点的集合。</p><p>空间雕刻的概念主要来源于观察到一个物体的轮廓提供了关于该物体的几何信息的丰富来源。在多个视图的上下文下，让我们首先设置图5中所示的问题。每个照相机观察一个物体的一些可见的部分，从中可以确定一个轮廓。当投影到图像平面时，该轮廓包含一组像素，称为图像平面中的对象的剪影。空间雕刻最终使用来自多个视图的对象的轮廓来加强一致性。</p><p>但是，如果我们没有三维对象的信息，而只有图像，那么我们如何获得剪影信息呢？幸运的是，使用轮廓的一个实际优点是，如果我们能够控制我们想要重建的物体背后的背景，它们就可以很容易地在图像中被检测到。例如，我们可以在对象后面的“绿色屏幕”来轻松地从对象的背景分割对象。</p><p>现在我们有了轮廓，我们如何真正使用它们呢？回想一下，在体积立体声中，我们估计了物体可以容纳的一些体积。现在我们介绍视锥的概念，即由相机中心定义的物体表面和图像平面上的包络轮廓。通过构造，保证了物体将完全位于初始体积和视锥内。</p><p><img src="/2021/12/07/L5/blog\source\_posts\视觉_5.assets\image-20211206215353976-16387988347746.png" alt="image-20211206215353976"></p><p>图6：从多个视图估计对象的过程涉及到恢复视觉船体，这是从每个相机的视觉锥的交集。</p><p>因此，如果我们有多个视图，那么我们可以计算每个视图的视锥。因为，根据定义，该物体位于每个这些视锥中，那么它必须位于这些视锥的交叉处，如图6所示。这样的交叉口通常被称为<strong>可见外壳</strong>。</p><p>在实践中，我们首先首先定义一个我们知道对象包含在其中的工作卷。例如，如果我们的相机包围着这个物体，那么我们就可以简单地说，工作体积是被相机所包围的空间的整个内部。我们将这个体积划分为被称为体素的小单位，定义了所谓的体素网格。我们将体素网格中的每个体素，并将其投射到每个视图中。如果该体素在一个视图中不包含在剪影中，那么它将被丢弃。因此，在空间雕刻算法的最后，我们留下了包含在可见外壳中的体素。</p><p>空间雕刻方法虽然避免了对应问题，而且相对简单，但仍有很多局限性。空间雕刻的一个限制是，它与网格中的体素数量呈线性关系。当我们减小每个体素的大小时，网格所需的体素数量以立方体的形式增加。因此，为了得到更好的重建，时间大幅增加。然而，可以使用一些方法，如使用八叉树来缓解这个问题。相关的，但更简单的方法包括迭代雕刻，以减少初始体素网格的大小。</p><p>​        <img src="/2021/12/07/L5/blog\source\_posts\视觉_5.assets\image-20211206215558090-16387989589137.png" alt="image-20211206215558090"></p><p>图7：在体素网格上进行的空间雕刻的结果。该区域是从两个视图中雕刻后重建的对象，而内部的阴影部分是实际的对象。请注意，重建方法总是保守的。</p><p>另一个限制是，空间雕刻的效果取决于视角的数量，剪影的精确性，甚至是我们试图重建的物体的形状。如果视图的数量太少，那么我们最终将对对象的视觉船体进行一个非常松散的估计。随着视图数量的增加，可以通过一致性检查删除更多无关的体素。此外，一致性检查的有效性仅仅是因为我们相信轮廓是正确的。如果剪影过于保守，并且包含的像素超过了必要的数量，那么我们的雕刻可能并不精确。在一个可能更糟糕的情况下，剪影遗漏了实际物体的部分内容，导致了过度雕刻的重建。最后，空间雕刻的一个主要缺点是它不能建模一个对象的某些凹处，如图8所示。</p><p><img src="/2021/12/07/L5/blog\source\_posts\视觉_5.assets\image-20211206215740328-16387990612118.png" alt="image-20211206215740328"></p><p>图8：空间雕刻不能处理一些凹处，如这里所示，因为它不能雕刻到那个区域，因为这样做将在物体中雕刻。注意，这意味着通常空间雕刻可以处理的唯一凹处是物体上的洞。</p><h2 id="3-2阴影雕刻"><a href="#3-2阴影雕刻" class="headerlink" title="3.2阴影雕刻"></a>3.2阴影雕刻</h2><p>为了规避空间雕刻所带来的凹度问题，我们需要查看其他形式的一致性检查。确定一个我们可以使用的物体的三维形状的一个重要线索是自阴影的存在。自我阴影是一个对象投射在其自身上的阴影。对于凹形物体的情况，一个物体通常会在凹形区域投射自阴影。</p><p>其核心的<strong>阴影雕刻</strong>通过使用自阴影来更好地估计凹度的想法，增强了空间雕刻。如图9所示，阴影雕刻的一般设置与空间雕刻非常相似。物体放置在校准相机查看的转盘中。然而，在相机周围有一组已知位置的灯，其状态可以适当地打开和关闭。这些灯将被用来制造对象投下自己的阴影。</p><p><img src="/2021/12/07/L5/blog\source\_posts\视觉_5.assets\image-20211206221300008-16387999808179.png" alt="image-20211206221300008"></p><p>图9：阴影雕刻的设置，通过从相机周围的一系列灯中添加一个新的一致性检查来增强空间雕刻。</p><p>如图10所示，阴影雕刻过程从一个初始体素网格开始，通过使用与空间雕刻相同的方法对该网格进行裁剪。然而，在每个视图中，我们都可以打开和关闭相机周围阵列中的每一盏灯。每一种光都会在物体上产生不同的自影。在识别出图像平面上的阴影后，我们就可以在我们裁剪后的体素网格的表面上找到位于阴影的视锥中的体素。这些表面体素允许我们用图像源制作一个新的视觉锥体。然后，我们利用一个有用的事实，即属于两个视锥的体素不能成为对象的一部分，来消除凹度中的体素。</p><p>与空间雕刻一样，阴影雕刻的运行时也取决于体素网格的分辨率。运行时随体素网格的分辨率呈立体比例。然而，如果有N个灯，那么阴影雕刻需要的N个+大约是空间雕刻的1倍，因为每个体素都需要投射到相机和每个N个灯中。</p><p>总之，阴影雕刻总是能产生一个保守的体积估计，从而更好地重建具有凹度的三维形状。结果的质量取决于视图的数量和光源的数量。这种方法的一些缺点是，它不能处理对象包含反射区或低反照率区域的情况。这是因为在这种情况下无法准确地检测到阴影。</p><p><img src="/2021/12/07/L5/blog\source\_posts\视觉_5.assets\image-20211206221538184-163880013911510.png" alt="image-20211206221538184"></p><p>图10：阴影雕刻依赖于一种新的一致性检查，它可以去除相机的自阴影视锥和光的视锥中的体素。</p><h2 id="3-3体素着色"><a href="#3-3体素着色" class="headerlink" title="3.3体素着色"></a>3.3体素着色</h2><p>我们在体积立体图像中介绍的最后一种技术是体素着色，它在空间雕刻中使用颜色一致性而不是轮廓一致性。</p><p>如图11所示，假设我们从一个要重建的对象的多个视图中给出了图像。对于每个体素，我们查看它在每个图像中对应的投影，并比较每个投影的颜色。如果这些投影的颜色足够匹配，那么我们将该体素标记为对象的一部分。在空间雕刻中不存在的体素着色的一个好处是，与投影相关的颜色可以转移到体素上，从而给出彩色重建。</p><p>总的来说，人们可以使用许多方法来检查颜色一致性。一个例子是在投影之间的颜色相似性之间设置一个阈值。然而，对于任何使用的颜色一致性检查都存在一个关键的假设：被重建的物体必须是<strong>兰伯特式</strong>的，这意味着物体的任何部分的感知亮度不会随着视点位置或姿态而变化。对于非兰伯式的物体，比如那些由高反射性材料制成的物体，我们很容易想象，在实际上是物体一部分的体素上，颜色一致性检查会失败。</p><p><img src="/2021/12/07/L5/blog\source\_posts\视觉_5.assets\image-20211206221830788-163880031174711.png" alt="image-20211206221830788"></p><p>图11：体素着色的设置，它对一个体素的所有投影的颜色进行了一致性检查。</p><p><img src="/2021/12/07/L5/blog\source\_posts\视觉_5.assets\image-20211206221856626-163880033767012.png" alt="image-20211206221856626"></p><p>图12：一个香草体素着色的例子。</p><p>香草体素着色的一个缺点是，它产生的解决方案不一定是唯一的，如图12所示。找到真正的、唯一的解决方案会使通过体素着色进行重建的问题变得复杂。</p><p>通过在体素上引入可见性约束，可以消除重构中的歧义，这要求体素以特定的顺序进行遍历。</p><p>特别是，我们想要一层一层地遍历体素，从更靠近相机的体素开始，然后发展到更远的体素。当使用此顺序时，我们将执行颜色一致性检查。然后，我们检查该体素是否可以被至少两个摄像机看到，这就构建了我们的可见性约束。如果至少有两个摄像机无法看到该体素，那么它必须被遮挡，因此不能成为物体的一部分。请注意，我们处理更接近体素的顺序允许我们确保保留可以封闭以后处理的体素的体素，以强制这种可见性约束。</p><p>总之，体素着色具有同时捕获物体的形状和纹理的优点。一些缺点包括假设对象是兰伯特的，相机不能在特定的位置，因为由于可见性限制，体素需要以特定的顺序处理。</p>]]></content>
    
    
    <summary type="html">本文是课程cs231a的第4节笔记</summary>
    
    
    
    <category term="计算机视觉" scheme="http://wcx2001.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="http://wcx2001.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="cs231a" scheme="http://wcx2001.github.io/tags/cs231a/"/>
    
  </entry>
  
  <entry>
    <title>npuSE Chapter 2 图像形成</title>
    <link href="http://wcx2001.github.io/2021/12/07/Chapter2/"/>
    <id>http://wcx2001.github.io/2021/12/07/Chapter2/</id>
    <published>2021-12-06T16:00:00.000Z</published>
    <updated>2021-12-07T05:10:17.589Z</updated>
    
    <content type="html"><![CDATA[<h1 id="npuSE-Chapter-2-图像形成"><a href="#npuSE-Chapter-2-图像形成" class="headerlink" title="npuSE Chapter 2 图像形成"></a>npuSE Chapter 2 图像形成</h1><h2 id="1-1-针孔相机"><a href="#1-1-针孔相机" class="headerlink" title="1.1.针孔相机"></a>1.1.针孔相机</h2><p>(ref: cs231a notes 1-camera-models)</p><h3 id="什么是针孔相机？"><a href="#什么是针孔相机？" class="headerlink" title="什么是针孔相机？"></a>什么是针孔相机？</h3><p><img src="https://s4.ax1x.com/2021/12/07/o6QXGt.png" alt></p><p>​                        图1：一个简单的工作相机模型：针孔相机模型。</p><p>让我们设计一个简单的照相系统——一个可以在3D世界中记录物体或场景图像的系统。这种相机系统可以通过在3D物体和摄影胶片或传感器之间放置一个小孔圈的屏障来设计。如图1所示，3D对象上的每个点都会向外发出多条光线。如果没有适当的屏障，薄膜上的每一个点都会受到3D物体上每个点发出的光线的影响。由于障碍物，只有一条（或少数）这些光线穿过孔径并击中薄膜。因此，我们可以在三维物体和薄膜上的点之间建立一个一对一的映射。其结果是，通过这种映射，胶片被三维物体的“图像”曝光。这个简单的模型被称为针孔照相机模型。</p><p><img src="https://s4.ax1x.com/2021/12/07/o6QOPI.png" alt></p><p>​                                图2：针孔照相机模型的正式构造。</p><p>针孔照相机的一个更正式的结构如图$2$所示。在这种结构中，薄膜（像）通常被称为图像或视网膜平面。这个孔径被称为针孔$O$或中心相机。图像平面与针孔$O$之间的距离为焦距$f$。有时，视网膜平面被放置在$O$和三维物体之间，距离$O$为$f$。在这种情况下，它被称为虚拟图像或虚拟视网膜平面。请注意，对象在图像平面中的投影与对象在虚拟图像平面中的图像的投影在一定比例内是相同的（相似性）转换。</p><h3 id="针孔相机是如何是如何实现的变化？"><a href="#针孔相机是如何是如何实现的变化？" class="headerlink" title="针孔相机是如何是如何实现的变化？"></a>针孔相机是如何是如何实现的变化？</h3><p>现在，我们如何使用针孔照相机呢？设$P=[x\,\,\,\,y\,\,\,\,z]^{\rm T}$​​是针孔相机可见的某些三维物体上的一个点。$P$​​将被映射或投影到图像平面$\Pi’$​​上，得到$P’=[x’\,\,\,y’]^{\rm T}$​​（将三维图形投影到二维平面，因此$P’$比$P$少了一个维度）。类似地，针孔本身也可以投射到图像平面上，给出一个新的点$C’$​。</p><p>在这里，我们可以定义一个以针孔$O$​为中心的坐标系$[i\,\,\,j\,\,\,k]$​，使轴$k$​垂直于图像平面并指向它。这个坐标系通常被称为照相机参考系统或照相机坐标系。由$ C’$​和$O$​定义的线称为照相机系统的光轴。</p><p>回想一下，该点$P’$​是由三维点$P$​在图像平面$\Pi’$​​上的投影产生而得到的。因此，如果我们推导出三维点$P$​和图像平面点$P’$​之间的关系，我们就可以理解如何理解3D世界把自己印在针孔相机拍摄的图像上。请注意，三角形$P’C’O$​类似于由$P$​、$O$​和$(0、0、z)$​形成的三角形。因此，利用相似三角形定律我们发现：</p><script type="math/tex; mode=display">P'=[x'\,\,\, y']^{\rm T}=[f\frac{x}{z}\,\,\,f\frac{y}{z}]^{\rm T}\tag{1}</script><p><img src="https://s4.ax1x.com/2021/12/07/o6QqIA.png" alt></p><p><img src="https://s4.ax1x.com/2021/12/07/o6Qbad.png" style="zoom:50%;"></p><p>请注意，我们在这个针孔模型中所做的一个很大的假设是，孔径是一个单点。然而，在大多数真实世界的场景中，我们不能假设孔径可以无限小。钍孔径大小的影响是什么？</p><p><img src="https://s4.ax1x.com/2021/12/07/o6Qvxf.png" alt></p><p>图3：孔径大小对图像的影响。随着孔径尺寸的减小，图像会变得更清晰，但颜色会更暗。</p><p>随着孔径尺寸的增加，通过势垒的光线数量因此增加。随着更多的光线通过，薄膜上的每个点都会受到l的影响光线来自三维空间中的多点，模糊图像。虽然我们可能倾向于试图使孔径尽可能小，但请记住，较小的孔径尺寸会导致光线减少通过，导致更清晰但更暗的图像。因此，我们得出了针孔公式提出的基本问题：我们能开发出拍摄清晰明亮图像的相机吗?</p><h2 id="1-2-透镜"><a href="#1-2-透镜" class="headerlink" title="1.2.透镜"></a>1.2.透镜</h2><p>(ref: <span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xNDc4NjI2Nzg=">计算机图形学十六：照相机与透镜(光圈,快门和景深) - 知乎 (zhihu.com)<i class="fa fa-external-link-alt"></i></span>)</p><h3 id="透镜概念"><a href="#透镜概念" class="headerlink" title="透镜概念"></a>透镜概念</h3><p><img src="https://img-blog.csdnimg.cn/2020061215504231.png" alt="img"></p><p>(1) 所有平行射入透镜的光都会集中于一点，称该点为焦点</p><p>(2) 所有从焦点射入透镜的光都会平行射出(光路可逆性)</p><p>(3) 焦距可以被随意改变(这里单个透镜当然不行，但在现实中大部分的照相机都是一个透镜组，可以做到焦距随意改变)</p><p><img src="https://s4.ax1x.com/2021/12/07/o6QzM8.png" alt></p><p>细透镜方程：</p><script type="math/tex; mode=display">\frac{1}{f}=\frac{1}{u}+\frac{1}{v}</script><h3 id="景深"><a href="#景深" class="headerlink" title="景深"></a>景深</h3><p>了解了上述的透镜成像规律之后，让我们一起观察一下景深模糊所产生的的原因：</p><p><img src="https://img-blog.csdnimg.cn/20200612160611963.png" alt="img"></p><p>当一个传感器平面不在一个物体真正精确的成像平面之上时，便会出现模糊。如上图所示，当传感器平面在根据透镜成像规律所计算出的成像平面Image之后时，一个点经过透镜到传感器上变成了一条线(从三维去看就是一个圆)，因此就出现了模糊，把上图中模糊之后的长度C称为 Circle of Confusion，同样利用三角形相似推导如下：</p><script type="math/tex; mode=display">\frac{C}{A}=\frac{d'}{z_i}=\frac{|z_s-z_i|}{z_i}</script><p>不难看出，C与棱镜长度A成正比，而棱镜长度也与光圈的直径成正比，因此当光圈越大，C也就越大，此时出现的景深模糊也就越明显。</p><p><img src="https://s4.ax1x.com/2021/12/07/o6lCZQ.png" alt></p><p>​                (左图大光圈，右图小光圈)明显看出右图要更加的清晰。</p><p>回顾一下在之前曾提到，光圈大小F-Number值与光圈直径的倒数成正比，更具体来说，$N = \frac{f}{D}$， 即焦距比上直径，因此换算Circle of Confusion当中的光圈直径$A=\frac{f}{N}$，得到如下图当中的式子：<br><img src="https://img-blog.csdnimg.cn/2020061216211332.png" alt="img"></p><p>同时这里也给出了不同光圈大小拍照的例子，小光圈锐利，景深模糊不明显，大光圈则有明显的景深模糊</p><p>那么回归到本章的主题，Depth of Field，它与景深模糊并不是同一个东西，景深模糊是一种情形，而景深则是一个具体的数值，其具体指</p><p>当我们固定一个可以接受的Circle of Confusion C值之后，可以逆向推导出小于该C值的对应的一段距离是多少，这个距离就是景深，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200612164410710.png" alt="img"></p><p>孔径如何影响景深？</p><p><img src="https://s4.ax1x.com/2021/12/07/o6lPaj.png" alt></p><p>孔径小使得更大范围的目标近似聚焦。</p><h3 id="视场角-FOV"><a href="#视场角-FOV" class="headerlink" title="视场角(FOV)"></a>视场角(FOV)</h3><p>视场(角)：相机能够拍摄的最大角度范围</p><p><img src="https://s4.ax1x.com/2021/12/07/o6lAGq.png" alt></p><p>视场角取决于焦距大小</p><ul><li><p>随着焦距变小，图像能够观察更大角度范围</p></li><li><p>随着焦距增大，图像能够观察得更远</p></li></ul><p>视场角的定义：</p><ol><li>在光学仪器中，以光学仪器的镜头为顶点，以被测目标的物像可通过镜头的最大范围的两条边缘构成的夹角，称为视场角。如图一。 视场角的大小决定了光学仪器的视野范围，视场角越大，视野就越大，光学倍率就越小。通俗地说，目标物体超过这个角就不会被收在镜头里。</li></ol><p><img src="https://www.colorspace.com.cn/wiki/uploads/201801/151493499806jjJQoP.jpg" alt="img"></p><ol><li>在显示系统中，视场角就是显示器边缘与观察点（眼睛）连线的夹角。例如在图二中，AOB角就是水平视场角，BOC就是垂直视场角。</li></ol><p>一台相机的FOV</p><p><img src="/2021/12/07/Chapter2/image-20211201231725526.png" alt="image-20211201231725526"></p><p><img src="https://s4.ax1x.com/2021/12/07/o6liIs.png" alt></p><script type="math/tex; mode=display">φ=\tan^{-1}(\frac{d}{2f})</script><p>可以得到结论：$f$（焦距）越大，FOV越小</p><h2 id="1-3-几何模型"><a href="#1-3-几何模型" class="headerlink" title="1.3.几何模型"></a>1.3.几何模型</h2><p>(ref: cs231a notes 1-camera-models)</p><p>在本节中，我们将讨论在建模从三维空间到我们所知道的数字图像的投影时必须考虑的参数的细节。所有得到的结果都将使用烟晕但它们也适用于近轴折射模型。</p><p>如前所述，三维空间中的一个点P可以被映射（或投影）到图像平面$\Pi’$中的一个二维点$P’$​中。这种$R^3→R^2$映射被称为射影变换。这个投影图像平面上的三维点并不直接对应于我们在实际数字图像中看到的，有几个原因。首先，数字图像中的点通常是用不同的参考中比图像平面上的系统要高。第二，数字图像被划分为离散的像素，而图像平面上的点是连续的。最后，物理传感器可以引入非线性传感器比如对映射的失真。为了解释这些差异，我们将引入一些额外的转换，允许我们将来自三维世界的任何点映射到像素坐标。</p><p>图像坐标的原点$C’$在k轴与图像平面相交的图像中心。另一方面，数字图像通常来自于i图像的左下角法师。因此，图像平面上的二维点和图像中的二维点被平移向量偏移$[c_x,c_y]^{\rm T}$。为了适应坐标系统的这种变化，映射现在变为：</p><script type="math/tex; mode=display">P'=\begin{bmatrix}x'\\y'\end{bmatrix}=\begin{bmatrix}f\frac{x}{z}+c\\f\frac{y}{z}+c\\\end{bmatrix}\tag{3}</script><p>下一个效果是，我们必须考虑到数字图像中的点用像素表示，而图像平面上的点用物理测量值表示（例如厘米）。为了适应这个单位的变化，我们必须引入两个新的参数$k$和$l$。这些参数，其单位大概是像“像素/厘米”，对应于图像平面的两个轴上单位的变化。请注意，$k$和$l$可能会有所不同，因为单元元素的长宽比不保证为$1$。如果$k=l$，我们通常说相机有方形像素。我们调整了我们之前的映射为：</p><script type="math/tex; mode=display">P'=\begin{bmatrix}x'\\y'\end{bmatrix}=\begin{bmatrix}fk\frac{x}{z}+c_x\\fl\frac{y}{z}+c_y\end{bmatrix}=\begin{bmatrix}\alpha\frac{x}{z}+c_x\\\beta\frac{y}{z}+c_y\end{bmatrix}\tag{4}</script><p>有没有更好的方法从$P→P’$来表示这个投影？如果这个投影是一个线性变换，那么它可以表示为一个矩阵和输入向量的乘积(在这种情况下，它将是$P$。然而，从方程4中，我们可以看到这个问题$P→P’$不是线性的，因为操作划分了其中一个输入参数(即z)。尽管如此，将这个投影表示为矩阵向量乘积对于未来的推导将是有用的。因此，我们是否可以将我们的变换表示为矩阵向量积，尽管它具有非线性？</p><p>解决这个问题的一种方法是改变坐标系。例如，我们引入了一个新的坐标，从而使任何点$P’=(x’、y’)$变成$(x’、y’、1)$。类似地，任何点$P=(x、y、z)$变成$(x、y、z、1)$。这个增广空间被称为齐次坐标系。如前所示，为了将一些欧几里得向量$(v_1，…，v_n)$转换为齐次坐标，我们简单地在一个新的维数中附加一个$1$来得到$(v_1，…，v_n，1)$。请注意，向量及其齐次坐标之间的相等只在最终坐标等于$1$时才会发生。 因此，当从任意齐次坐标$(v_1、…，v_n，w)$转换回时，我们得到欧几里得坐标$(\frac{v_1}{w}，…，\frac{v_n}{w})$。利用齐次坐标，我们可以表示：</p><script type="math/tex; mode=display">P_h'=\begin{bmatrix}\alpha x+c_x z\\\beta y+c_y z\\z\end{bmatrix}=\begin{bmatrix}\alpha & 0 & c_x & 0\\0 & \beta & c_y & 0\\0 & 0 & 1 & 0\end{bmatrix}\cdot\begin{bmatrix}x\\y\\z\\1\end{bmatrix}=\begin{bmatrix}\alpha & 0 & c_x & 0\\0 & \beta & c_y & 0\\0 & 0 & 1 & 0\end{bmatrix}P_h\tag{5}</script><p>从这一点起，假设我们将在齐次坐标下工作，除非另有说明。我们将去掉$h$指数，这样任何点$P$或$P’$都可以假定在齐次坐标中。从公式$5$中可以看出，我们可以用矩阵向量关系来表示三维空间中的一个点与其图像坐标之间的关系：</p><script type="math/tex; mode=display">P'=\begin{bmatrix}x'\\y'\\z\end{bmatrix}=\begin{bmatrix}\alpha & 0 & c_x & 0\\0 & \beta & c_y & 0\\0 & 0 & 1 & 0\end{bmatrix}\cdot\begin{bmatrix}x\\y\\z\\1\end{bmatrix}=\begin{bmatrix}\alpha & 0 & c_x & 0\\0 & \beta & c_y & 0\\0 & 0 & 1 & 0\end{bmatrix}\cdot P=MP\tag{6}</script><p>我们可以把这个转换进一步分解为：</p><script type="math/tex; mode=display">P'=MP=\begin{bmatrix}\alpha & 0 & c_x \\0 & \beta & c_y \\0 & 0 & 1 \end{bmatrix}\cdot\begin{bmatrix}I & 0\end{bmatrix}\cdot P=K\cdot\begin{bmatrix}I & 0\end{bmatrix}\cdot P\tag{7}</script><p>矩阵$K$通常被称为相机矩阵。这个矩阵包含了一些对表征照相机模型很有用的关键参数。我们的公式目前缺少两个参数：偏度和失真。我们经常说，当相机坐标系倾斜时，图像是倾斜的。在这种情况下，两个轴之间的夹角略大于或小于$90$​度。大多数相机都有零偏态，但由于传感器制造错误，可能会出现一定程度的偏态。证明新的相机矩阵超出了这类的范围，我们给你如下：</p><script type="math/tex; mode=display">K=\begin{bmatrix}x'\\y'\\z\end{bmatrix}=\begin{bmatrix}\alpha & -\alpha\cot \theta & c_x\\0 & \frac{\beta}{\sin\theta} & c_y\end{bmatrix}\tag{8}</script><p>我们在这类中引入的大多数方法都忽略了失真效应。因此，我们最终的相机矩阵有$5$个自由度：$2$焦距，$2$偏移量，$1$偏度。</p><p>到目前为止，我们已经描述了三维相机参考系统中的一个点$P$到二维图像平面中的一个点$P’$之间的映射。但是如果关于3D世界的信息是不同的呢坐标系？然后，我们需要包括一个额外的转换，将点从世界参考系统到相机参考系统联系起来。这个转换被一个旋转器捕获离子矩阵$R$和平移向量$t$。因此，如果给定世界参考系统$P_w$中的一个点，我们可以计算其相机坐标如下：</p><script type="math/tex; mode=display">P=\begin{bmatrix}R & T\\0 & 10\end{bmatrix} P_w\tag{9}</script><p>将其代入方程（7）并简化给出：</p><script type="math/tex; mode=display">P'=K\begin{bmatrix}R&T\end{bmatrix} P_w=MP_w\tag{10}</script><p>这就完成了从任意世界参考系统中的三维点$P$​​到图像平面的映射。我们可以看到投影矩阵$M$​由两种类型的参数组成：固有参数和外部参数$c$​参数。相机矩阵$K$​中包含的所有参数都为固有参数，它们随相机类型的变化而变化。外在参数包括旋转和平移我并不依赖于相机的结构。总的来说，我们发现$3×4$​投影矩阵$M$​有$11$个自由度：$5$个来自内在相机矩阵，$3$个来自外在旋转，$3$个来自外在外在转化。</p><h2 id="1-4-光照模型"><a href="#1-4-光照模型" class="headerlink" title="1.4.光照模型"></a>1.4.光照模型</h2><p>(ref: <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NTUyODg2L2FydGljbGUvZGV0YWlscy83OTA4OTQxOA==">(51条消息) 经典光照模型（illumination model）_miaobeihai的博客-CSDN博客_光照模型<i class="fa fa-external-link-alt"></i></span>)</p><h3 id="光照模型分类"><a href="#光照模型分类" class="headerlink" title="光照模型分类"></a>光照模型分类</h3><p>光照模型（ illumination model ），也称为明暗模型，用于计算物体某点处的光强（颜色值）。</p><h4 id="①-从算法理论基础而言"><a href="#①-从算法理论基础而言" class="headerlink" title="① 从算法理论基础而言"></a>① 从算法理论基础而言</h4><p>从算法理论基础而言，光照模型分为两类：一种是基于物理理论的，另一种是基于经验模型的。</p><p>基于物理理论的光照模型，偏重于使用物理的度量和统计方法，比较典型的有 ward BRDF 模型，其中的不少参数是需要仪器测量的，使用这种光照模型的好处是 “ 效果非常真实” ，但是 “计算复杂，实现起来也较为困难 ” </p><p>经验模型更加偏重于使用特定的概率公式，使之与一组表面类型相匹配，所以经验模型大都比较简洁，效果偏向理想化。</p><p>其实两者之间的界限并不是明确到 “非黑即白” 的地步，无论何种光照模型本质上还是基于物理的，只不过在求证方法上各有偏重而已。</p><h4 id="②-从使用角度而言"><a href="#②-从使用角度而言" class="headerlink" title="② 从使用角度而言"></a>② 从使用角度而言</h4><p>从使用角度而言，光照模型分为局部光照模型和全局光照模型。</p><p>所谓局部光照模型，是将光照的种类进行分解，在计算时只考虑其中的一种；</p><p>而全局光照模型则是考虑到所有的光照种类。</p><p>一个比较类似的例子是物理力学，牛顿力学最初是考虑理想状态下的运动方式，无摩擦力；然后慢慢的会在力的条件中考虑到摩擦力因素；接着会学习弹性系数。</p><p>总之是将一个原本复杂的过程分解为各种子过程，然后渐进叠加。</p><p>当光照射到物体表面时，一部分被物体表面吸收，另一部分被反射，对于透明物体而言，还有一部分光穿过透明体，产生透射光。被物体吸收的光能转化为热量，只有反射光和透射光能够进入眼睛，产生视觉效果。通过反射和透射产生的光波（光具有波粒二相性）决定了物体呈现的亮度和颜色，即反射和投射光的强度决定了物体表面的亮度，而它们含有的不同波长光的比例决定了物体表面的色彩。所以，物体表面光照颜色由入射光、物体材质，以及材质和光的交互规律共同决定。光与物体最基本的交互方式就是反射，遵循反射定律：反射光与入射光位于表面法向两侧，对理想反射面（如镜面），入射角等于反射角，观察者只能在表面法向的反射方向一侧才能看到反射光。 不过世界上并不存在真正的理想反射体，正如物理学中绝对的匀速状态是不存在的。</p><h3 id="光源"><a href="#光源" class="headerlink" title="光源"></a>光源</h3><p>环境光 (Ambient Light): 从物体表面所产生的反射光的统一照明，称为环境光或背景光（计算机图形学第二版 389 页）。例如房间里面并没有受到灯光或者太阳光的直接照射，而是由墙壁、天花板、地板及室内各物体之间光的多次反射进行自然照明。通常我们认为理想的环境光具有如下特性：没有空间或方向性；在所有方向上和所有物体表面上投射的环境光强度是统一的恒定值。</p><p>由于环境光给予物体各个点的光照强度相同，且没有方向之分，所以在只有环境光的情况下，同一物体各点的明暗程度均一样，因此，只有环境光是不能产生具有真实感的图形效果。</p><p>环境光是对光照现象的最简单抽象，局限性很大。它仅能描述光线在空间中无方向并均匀散布时的状态。真实的情况是：光线通常都有方向。点光源是发光体的最简单的模型，光线由光源出发向四周发散。还有一种是平行光，即光线都从同一个方向照射。通过模拟方向光和物体表面的交互模式，可以渲染出具有高真实感（明暗变化、镜面反射等）的三维场景。</p><h3 id="漫反射与-Lambert-模型"><a href="#漫反射与-Lambert-模型" class="headerlink" title="漫反射与 Lambert 模型"></a>漫反射与 Lambert 模型</h3><p>粗糙的物体表面向各个方向等强度地反射光，这种等同地向各个方向散射的现象称为光的漫反射（ diffuse reflection ）。产生光的漫反射现象的物体表面称为理想漫反射体，也称为朗伯（ Lambert ）反射体。</p><p>粗糙的物体表面向各个方向等强度地反射光，这种等同地向各个方向散射的现象称为光的漫反射（ diffuse reflection ）。产生光的漫反射现象的物体表面称为 理想漫反射体，也称为朗伯（ Lambert ）反射体。</p><p>对于仅暴露在环境光下的朗伯反射体，可以用公式(9-1)表示某点处漫反射的光强：</p><script type="math/tex; mode=display">I_{\rm ambiff}=k_dI_a\tag{9-1}</script><p>其中$I$表示环境光强度（简称光强），$k(0&lt;k &lt;1)$为材质对环境光的反射系数，I  ambdiff是漫反射体与环境光交互反射的光强。</p><p>即使一个理想的漫反射体在所有方向上具有等量的反射光线，但是表面光强还依赖于光线的入射方向（方向光）。例如，入射光方向垂直的表面与入射光方向成斜角的表面相比，其光强要大的多。这种现象可以用 Lambert 定律进行数学上的量化。即，当方向光照射到朗伯反射体上时，漫反射光的光强与入射光的方向和入射点表面法向夹角的余弦成正比，这称之为 Lambert 定律，并由此构造出 Lambert漫反射模型：</p><script type="math/tex; mode=display">I_{\rm ibiff}=k_dI_i\cos \theta\tag{9-2}</script><p>$I$ 是点光源强度， $θ$ 是入射光方向与顶点法线的夹角，称为入射$(0≤ θ ≤90°)$，ldiff  I 是漫反射体与方向光交互反射的光强。入射角为零时，说明光线垂直于物体表面，漫反射光强最大；$90°$时光线与物体表面平行，物体接收不到任何光线。若 $N$ 为顶点单位法向量， $L$ 表示从顶点指向光源的单位向量（注意，是由顶点指向光源，不要弄反了），则 $cos θ$ 等价于 $N$ 与 $L$ 的点积。所以公式(9-2)可以表示为公式(9-3)：</p><script type="math/tex; mode=display">I_{idiff}=k_dI_i(N\cdot L)\tag{9-3}</script><p>综合考虑环境光和方向来，Lambert光照模型可写为：</p><script type="math/tex; mode=display">I_{diff}=I_{ambdiff}+I_{idiff}=k_dI_a+k_dI_i(N\cdot L)\tag{9-4}</script><h3 id="镜面反射与-Phong-模型"><a href="#镜面反射与-Phong-模型" class="headerlink" title="镜面反射与 Phong 模型"></a>镜面反射与 Phong 模型</h3><p>Lambert 模型较好地表现了粗糙表面上的光照现象，如石灰粉刷的墙壁、纸张等，但在用于诸如金属材质制成的物体时，则会显得呆板，表现不出光泽，主要原因是该模型没有考虑这些表面的镜面反射效果。一个光滑物体被光照射时，可以在某个方向上看到很强的反射光，这是因为在接近镜面反射角的一个区域内，反射了入射光的全部或绝大部分光强，该现象称为镜面反射。故此，Phong Bui Tuong 提出一个计算镜面反射光强的经验模型，称为 phong模型，认为镜面反射的光强与反射光线和视线的夹角相关，其数学表达如公式(9-5)所示：</p><script type="math/tex; mode=display">I_{\rm spec}=k_sI_i(V\cdot R)^{n_i}\tag{9-5}</script><p>$k$​​ 为材质的镜面反射系数，$n$​​ 是高光指数， $V$​​ 表示从顶点到视点的观察方向， $R$​​ 代表反射光方向。高光指数反映了物体表面的光泽程度。$n$​ 越大，反射光越集中，当偏离反射方向时，光线衰减的越厉害，只有当视线方向与反射光线方向非常接近时才能看到镜面反射的高光现象，此时，镜面反射光将会在反射方向附近形成亮且小的光斑；$n$​ 越小，表示物体越粗糙，反射光分散，观察到的光斑区域小，强度弱。反射光的方向 $R$​ 可以通过入射光方向 $L$​ （从顶点指向光源）和物体法向量 $N$​ 求出：</p><script type="math/tex; mode=display">R+L=(2N\cdot L)N\tag{9-6}</script><p>所以有：</p><script type="math/tex; mode=display">R=(2N\cdot L)N - L\tag{9-7}</script><h3 id="Blinn-Phong-光照模型"><a href="#Blinn-Phong-光照模型" class="headerlink" title="Blinn-Phong 光照模型"></a>Blinn-Phong 光照模型</h3><p>Blinn-Phong 光照模型，又称为 Blinn-phong 反射模型（ Blinn–Phong reflection model ）或者 phong 修正模型（ modified Phong reflection model ），是由 Jim Blinn于 1977 年在文章 “Models of light reflection for computer synthesized pictures” 中对传统 phong 光照模型基础上进行修改提出的。和传统 phong 光照模型相比，Blinn-phong 光照模型混合了 Lambert 的漫射部分和标准的高光，渲染效果有时比 Phong  高光更柔和、更平滑，此外它在速度上相当快，因此成为许多 CG 软件中的默认光照渲染方法。此外它也集成在了大多数图形芯片中，用以产生实时快速的渲染。在 OpenGL 和 Direct3D 渲染管线中， Blinn-Phong 就是默认的渲染模型。</p><p>phong 光照模型中，必须计算 $V\cdot R$​  的值，其中 $R$​ 为反射光线方向单位向量，$V$ 为视线方向单位向量，但是在 Blinn-phong 光照模型中，用 $N\cdot H$ 的值取代了$V\cdot R$​  。 </p><p>Blinn-phong 光照模型公式为：</p><script type="math/tex; mode=display">I_{spec} = k_s I_l(N\cdot H)^{n_s}\tag{9-8}</script><p>其中 N 是入射点的单位法向量， H 是“光入射方向 L 和视点方向 V 的中间向量”，通常也称之为半角向量。注意：半角向量被广泛用于各类光照模型，原因不但在于半角向量蕴含的信息价值，也在于计算半角向量是一件简单、耗时不多的工作。</p><script type="math/tex; mode=display">H=\frac{L+V}{|L+V|}\tag{9-9}</script><p>通常情况下，使用 Blinn-phong 光照模型渲染的效果和 phong 模型渲染的效果没有太大的区别，有些艺术工作者认为 phong 光照模型比 blinn-phong 更加真实，实际上也是如此。 Blinn-phong 渲染效果要更加柔和一些， Blinn-phong 光照模型省去了计算反射光线方向向量的两个乘法运算，速度更快。由于 Blinn-phong和 phong 模型的唯一区别一个使用半角向量，一个使用反射光方向向量。</p><h2 id="1-5-感光元件"><a href="#1-5-感光元件" class="headerlink" title="1.5.感光元件"></a>1.5.感光元件</h2><p>(ref: <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hlbGxvWkVYL2FydGljbGUvZGV0YWlscy84MDkwMTc2Ng==">(45条消息) 【图像处理】数码相机工作原理完整解析_Twinkle-CSDN博客<i class="fa fa-external-link-alt"></i></span>)</p><p>相比传统的胶片相机来说，数码相机最大的改变就是将感光元件从胶片转变为了CCD/CMOS。传统胶片相机使用银盐作为感光材料，即胶卷作为感光元件，拍摄后还需经过冲洗才能得到最终成片。不但无法第一时间得知最终效果而且在保存上也不太方便。而数码相机的“胶卷”就是其成像感光元件，它与相机融为一体，是数码相机的心脏。感光元件是数码相机的核心，也是最关键的技术。数码相机的发展道路，可以说就是感光元件的发展道路。目前数码相机的核心成像部件有两种：一种是CCD，一种是CMOS。</p><p>它们每个感光元件的像素点分别对应图像传感器中的一个像点，由于感光元件只能感应光的强度，无法捕获色彩信息，因此彩色CCD/CMOS图像传感器必须在感光元件上方覆盖彩色滤光片。在这方面，不同的传感器厂商有不同的解决方案，最常用的做法是覆盖RGB红绿蓝三色滤光片，以1：2：1的构成由四个像点构成一个彩色像素（即红蓝滤光片分别覆盖一个像点，剩下的两个像点都覆盖绿色滤光片），这种解决方案就是大名鼎鼎的拜耳滤镜。</p><h2 id="1-6-色彩空间"><a href="#1-6-色彩空间" class="headerlink" title="1.6.色彩空间"></a>1.6.色彩空间</h2><p>(ref: <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Npbl9nZWVrL2FydGljbGUvZGV0YWlscy8yMjMyNTIyOQ==">(45条消息) 颜色迁移之一——基础知识（色彩空间及其转换）_Sin_Geek成长の迹-CSDN博客_颜色迁移<i class="fa fa-external-link-alt"></i></span>)</p><h3 id="色彩空间"><a href="#色彩空间" class="headerlink" title="色彩空间"></a>色彩空间</h3><p>色彩空间是进行颜色信息研究的理论基础，它将颜色从人们的主观感受量化为具体的表达，为用计算机来记录和表现颜色提供了有力的依据。</p><p>一幅图像可以用不同的色彩空间表示，其视觉效果是相同的。但色彩空间的选取对图像的色彩迁移算法是否有效有很大的影响，选择一个合适的色彩空间能够保证色彩迁移结果的准确性。用于彩色图像处理的色彩空间必须同时具有独立性和均匀性。独立性是指色彩空间的三个分量互不影响，对其中某个分量的处理不会导致其它分量相对于人眼感觉发生变化；均匀性是指对色彩空间的每一个分量来说，相同数量的变化能够产生大约相同视觉重要性的变化。</p><p>   色彩空间的表达形式是多样的，不同的色彩空间具有不同的特性，但因为不同的色彩空间是同构的，所以它们之间可以互相转换。</p><h3 id="RGB色彩空间"><a href="#RGB色彩空间" class="headerlink" title="RGB色彩空间"></a>RGB色彩空间</h3><p>色彩混合的基本定律表明：自然界任何一种色彩均可用红、绿、蓝三种原色光混合产生，这在几何上能够以R、G、B三个互相垂直的轴所构成的空间坐标系统来表示，称为RGB色彩空间。如图1所示，RGB色系坐标中三维空间的三个轴分别于红、绿、蓝三基色相对应，原点对应黑色，离原点最远的顶点对应白色，而立方体内其余各点对应不同的颜色。RGB色彩系统用R、G、B三原色通过不同比例的混合来表示任一种色彩，因而它不能直观地度量色调、饱和度和亮度。而且，各分量之间存在着一定的相关性，它们在大多数情况下都是成正比的，主要表现为自然场景中若某一通道大，则像素的其他通道值也较大。这意味着，如果要对图像的色彩进行处理，常常需要对像素的三个分量同时进行修改才不会影响图像的真实感，这将大大增加颜色调整过程的复杂性。因此，在RGB色彩空间下进行色彩迁移会比较复杂，得到的视觉效果也不自然。</p>]]></content>
    
    
    <summary type="html">本文是西北工业大学软件学院计算机视觉课程第二讲课程笔记</summary>
    
    
    
    <category term="计算机视觉" scheme="http://wcx2001.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="http://wcx2001.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="npuSE" scheme="http://wcx2001.github.io/tags/npuSE/"/>
    
  </entry>
  
  <entry>
    <title>cs231a Course 1:相机模型</title>
    <link href="http://wcx2001.github.io/2021/12/07/L1/"/>
    <id>http://wcx2001.github.io/2021/12/07/L1/</id>
    <published>2021-12-06T16:00:00.000Z</published>
    <updated>2021-12-07T05:06:24.994Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Course-1-相机模型"><a href="#Course-1-相机模型" class="headerlink" title="Course 1: 相机模型"></a>Course 1: 相机模型</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>照相机是计算机视觉中最重要的工具之一。它是我们可以记录我们周围的世界并使用其输出照片用于各种应用程序的机制。因此，我们在计算机视觉入门课程中必须问的一个问题是：我们如何建模一个相机？</p><h2 id="1-2-针孔相机"><a href="#1-2-针孔相机" class="headerlink" title="1.2 针孔相机"></a>1.2 针孔相机</h2><p><img src="https://s4.ax1x.com/2021/12/07/o6QXGt.png" alt></p><p>​                        图1：一个简单的工作相机模型：针孔相机模型。</p><p>让我们设计一个简单的摄像系统——一个可以在3D世界中记录物体或场景图像的系统。这种相机系统可以通过在3D物体和摄影胶片或传感器之间放置一个小孔圈的屏障来设计。如图1所示，3D对象上的每个点都会向外发出多条光线。如果没有适当的屏障，薄膜上的每一个点都会受到3D物体上每个点发出的光线的影响。由于障碍物，只有一条（或少数）这些光线穿过孔径并击中薄膜。因此，我们可以在三维物体和薄膜上的点之间建立一个一对一的映射。其结果是，通过这种映射，胶片被三维物体的“图像”曝光。这个简单的模型被称为针孔照相机模型。</p><p><img src="https://s4.ax1x.com/2021/12/07/o6QOPI.png" alt></p><p>​                                图2：针孔照相机模型的正式构造。</p><p>针孔照相机的一个更正式的结构如图2所示。在这种结构中，薄膜通常被称为图像或视网膜平面。这个孔径被称为针孔$O$或中心相机。图像平面与针孔$O$之间的距离为焦距$f$。有时，视网膜平面被放置在$O$和三维物体之间，距离$O$为$f$​​。在这种情况下，它被称为虚拟图像或虚拟视网膜平面。请注意，对象在图像平面中的投影与对象在虚拟图像平面中的图像的投影在一定比例内是相同的（相似性）转换。</p><p>现在，我们如何使用针孔照相机呢？设$P=[x\,\,\,\,y\,\,\,\,z]^{\rm T}$​是针孔相机可见的某些三维物体上的一个点。$P$​将被映射或投影到图像平面$\Pi’$​上，得到$P’=[x’\,\,\,y’]^{\rm T}$​。类似地，针孔本身也可以投射到图像平面上，给出一个新的点$C’’$。</p><p>在这里，我们可以定义一个以针孔$O$为中心的坐标系$[i\,\,\,j\,\,\,k]$，使轴$k$垂直于图像平面并指向它。这个坐标系通常被称为照相机参考系统或照相机坐标系。由$ C’’$和$O$定义的线称为照相机系统的光轴。</p><p>回想一下，该点$P’$是由三维点$P$在图像平面$\Pi’$​上的投影产生而得到的。因此，如果我们推导出三维点$P$和图像平面点$P’$之间的关系，我们就可以理解如何理解3D世界把自己印在针孔相机拍摄的图像上。请注意，三角形$P’C’O$类似于由$P$、$O$和$(0、0、z)$形成的三角形。因此，利用相似三角形定律我们发现：</p><script type="math/tex; mode=display">P'=[x'\,\,\, y']^{\rm T}=[f\frac{x}{z}\,\,\,f\frac{y}{z}]^{\rm T}\tag{1}</script><p>请注意，我们在这个针孔模型中所做的一个很大的假设是，孔径是一个单点。然而，在大多数真实世界的场景中，我们不能假设孔径可以无限小。钍孔径大小的影响是什么？</p><p><img src="https://s4.ax1x.com/2021/12/07/o6Qvxf.png" alt></p><p>图3：孔径大小对图像的影响。随着孔径尺寸的减小，图像会变得更清晰，但颜色会更暗。</p><p>随着孔径尺寸的增加，通过势垒的光线数量因此增加。随着更多的光线通过，薄膜上的每个点都会受到l的影响光线来自三维空间中的多点，模糊图像。虽然我们可能倾向于试图使孔径尽可能小，但请记住，较小的孔径尺寸会导致光线减少通过，导致更清晰但更暗的图像。因此，我们得出了针孔公式提出的基本问题：我们能开发出拍摄清晰明亮图像的相机吗?</p><h2 id="1-3-相机和镜头"><a href="#1-3-相机和镜头" class="headerlink" title="1.3 相机和镜头"></a>1.3 相机和镜头</h2><p><img src="https://s2.loli.net/2021/12/07/B8gDMFaGmH4YtIr.png" alt="image-20211130221320390.png"></p><p>图4：一个简单的镜头模型的设置。请注意，树上的顶点的光线是如何很好地汇聚在胶片上的。然而，一个距离镜头有不同距离的点会产生射线，而不是完美地融合在电影上。</p><p>在现代相机中，通过使用可以聚焦和分散光的镜头，可以缓解上述清晰度和亮度之间的冲突。如果我们把针孔换成一种有两种形状的针孔如果放置和大小，然后它满足以下特性：所有由某些点$P$发射的光线都被透镜折射，使它们收敛到一个单点$P’$在图像平面上。因此，消除了由于一个小孔径而导致的大部分光线被阻挡的问题（图4）。但是，请注意，这个属性并不适用于所有的3D点，而是只适用于某些特定的点P。取与图像平面更近或更远的点Q，图像中相应的投影会模糊或失焦。因此，镜头有一个规格物体“处于焦点中”的特定距离。这一特性也与摄影和计算机图形学的概念有关，这是相机可以达到的有效范围拍摄清晰的照片。</p><p><img src="https://obohe.com/i/2021/12/07/ihnnqv.png" alt></p><p>图5：镜头将平行于光轴的光线聚焦到焦点中。此外，该装置还说明了近轴折射模型，帮助我们找到带镜头相机的图像平面点与三维世界之间的关系。</p><p>相机镜头还有另一个有趣的特性：它们将所有平行于光轴移动的光线聚焦到一个被称为焦点的点（图5）。焦尖之间的距离$t$和透镜的中心通常被称为焦距$f$。此外，通过透镜中心的普通针垫筒没有偏离。因此，我们可以得到一个与与点$P$相关的针孔模型类似的构造三维空间及其对应的在图像平面上的点$P’$。</p><script type="math/tex; mode=display">P'=\begin{bmatrix}x'\\y'\end{bmatrix}=\begin{bmatrix}z' & \frac{x}{z}\\z' & \frac{y}{z}\end{bmatrix}</script><p>这个模型的推导超出了类的范围。但是，请注意，在针孔模型$z’=f$中，而在这个基于镜头的模型中，$z’=f+z_0$。此外，由于这个衍生物上利用近轴或“薄透镜”假设，称为近轴折射模型。</p><p><img src="https://obohe.com/i/2021/12/07/ihdosf.png" alt></p><p>​                            图6：演示针垫和桶变形如何影响图像。</p><p>由于近轴折射模型近似于薄透镜假设，因此会发生一些像差。最常见的一种被称为径向失真，它导致图像放大作用随着与光轴的距离的增加而减小或增加。当放大阳离子增加和枪管扭曲时，我们将径向畸变划分为针垫畸变当放大率降低时。径向失真是由于透镜的不同部分有不同的焦距而造成的。</p><h2 id="1-4-进入数字图像空间"><a href="#1-4-进入数字图像空间" class="headerlink" title="1.4 进入数字图像空间"></a>1.4 进入数字图像空间</h2><p>在本节中，我们将讨论在建模从三维空间到我们所知道的数字图像的投影时必须考虑的参数的细节。所有得到的结果都将使用烟晕但它们也适用于近轴折射模型。</p><p>如前所述，三维空间中的一个点P可以被映射（或投影）到图像平面$\Pi’$中的一个二维点$P’$​中。这种$R^3→R^2$映射被称为射影变换。这个投影图像平面上的三维点并不直接对应于我们在实际数字图像中看到的，有几个原因。首先，数字图像中的点通常是用不同的参考中比图像平面上的系统要高。第二，数字图像被划分为离散的像素，而图像平面上的点是连续的。最后，物理传感器可以引入非线性传感器比如对映射的失真。为了解释这些差异，我们将引入一些额外的转换，允许我们将来自三维世界的任何点映射到像素坐标。</p><p>图像坐标的原点$C’$在k轴与图像平面相交的图像中心。另一方面，数字图像通常来自于i图像的左下角法师。因此，图像平面上的二维点和图像中的二维点被平移向量偏移$[c_x,c_y]^{\rm T}$。为了适应坐标系统的这种变化，映射现在变为：</p><script type="math/tex; mode=display">P'=\begin{bmatrix}x'\\y'\end{bmatrix}=\begin{bmatrix}f\frac{x}{z}+c\\f\frac{y}{z}+c\\\end{bmatrix}\tag{3}</script><p>下一个效果是，我们必须考虑到数字图像中的点用像素表示，而图像平面上的点用物理测量值表示（例如厘米）。为了适应这个单位的变化，我们必须引入两个新的参数$k$和$l$。这些参数，其单位大概是像“像素/厘米”，对应于图像平面的两个轴上单位的变化。请注意，$k$和$l$可能会有所不同，因为单元元素的长宽比不保证为$1$。如果$k=l$，我们通常说相机有方形像素。我们调整了我们之前的映射为：</p><script type="math/tex; mode=display">P'=\begin{bmatrix}x'\\y'\end{bmatrix}=\begin{bmatrix}fk\frac{x}{z}+c_x\\fl\frac{y}{z}+c_y\end{bmatrix}=\begin{bmatrix}\alpha\frac{x}{z}+c_x\\\beta\frac{y}{z}+c_y\end{bmatrix}\tag{4}</script><p>有没有更好的方法从$P→P’$来表示这个投影？如果这个投影是一个线性变换，那么它可以表示为一个矩阵和输入向量的乘积(在这种情况下，它将是$P$。然而，从方程4中，我们可以看到这个问题$P→P’$不是线性的，因为操作划分了其中一个输入参数(即z)。尽管如此，将这个投影表示为矩阵向量乘积对于未来的推导将是有用的。因此，我们是否可以将我们的变换表示为矩阵向量积，尽管它具有非线性？</p><p>解决这个问题的一种方法是改变坐标系。例如，我们引入了一个新的坐标，从而使任何点$P’=(x’、y’)$变成$(x’、y’、1)$。类似地，任何点$P=(x、y、z)$变成$(x、y、z、1)$。这个增广空间被称为齐次坐标系。如前所示，为了将一些欧几里得向量$(v_1，…，v_n)$转换为齐次坐标，我们简单地在一个新的维数中附加一个$1$来得到$(v_1，…，v_n，1)$。请注意，向量及其齐次坐标之间的相等只在最终坐标等于$1$时才会发生。 因此，当从任意齐次坐标$(v_1、…，v_n，w)$转换回时，我们得到欧几里得坐标$(\frac{v_1}{w}，…，\frac{v_n}{w})$。利用齐次坐标，我们可以表示：</p><script type="math/tex; mode=display">P_h'=\begin{bmatrix}\alpha x+c_x z\\\beta y+c_y z\\z\end{bmatrix}=\begin{bmatrix}\alpha & 0 & c_x & 0\\0 & \beta & c_y & 0\\0 & 0 & 1 & 0\end{bmatrix}\cdot\begin{bmatrix}x\\y\\z\\1\end{bmatrix}=\begin{bmatrix}\alpha & 0 & c_x & 0\\0 & \beta & c_y & 0\\0 & 0 & 1 & 0\end{bmatrix}P_h\tag{5}</script><p>从这一点起，假设我们将在齐次坐标下工作，除非另有说明。我们将去掉$h$指数，这样任何点$P$或$P’$都可以假定在齐次坐标中。从公式$5$中可以看出，我们可以用矩阵向量关系来表示三维空间中的一个点与其图像坐标之间的关系：</p><script type="math/tex; mode=display">P'=\begin{bmatrix}x'\\y'\\z\end{bmatrix}=\begin{bmatrix}\alpha & 0 & c_x & 0\\0 & \beta & c_y & 0\\0 & 0 & 1 & 0\end{bmatrix}\cdot\begin{bmatrix}x\\y\\z\\1\end{bmatrix}=\begin{bmatrix}\alpha & 0 & c_x & 0\\0 & \beta & c_y & 0\\0 & 0 & 1 & 0\end{bmatrix}\cdot P=MP\tag{6}</script><p>我们可以把这个转换进一步分解为：</p><script type="math/tex; mode=display">P'=MP=\begin{bmatrix}\alpha & 0 & c_x \\0 & \beta & c_y \\0 & 0 & 1 \end{bmatrix}\cdot\begin{bmatrix}I & 0\end{bmatrix}\cdot P=K\cdot\begin{bmatrix}I & 0\end{bmatrix}\cdot P\tag{7}</script><p>矩阵$K$通常被称为相机矩阵。这个矩阵包含了一些对表征照相机模型很有用的关键参数。我们的公式目前缺少两个参数：偏度和失真。我们经常说，当相机坐标系倾斜时，图像是倾斜的。在这种情况下，两个轴之间的夹角略大于或小于$90$​度。大多数相机都有零偏态，但由于传感器制造错误，可能会出现一定程度的偏态。证明新的相机矩阵超出了这类的范围，我们给你如下：</p><script type="math/tex; mode=display">K=\begin{bmatrix}x'\\y'\\z\end{bmatrix}=\begin{bmatrix}\alpha & -\alpha\cot \theta & c_x\\0 & \frac{\beta}{\sin\theta} & c_y\end{bmatrix}\tag{8}</script><p>我们在这类中引入的大多数方法都忽略了失真效应。因此，我们最终的相机矩阵有$5$个自由度：$2$焦距，$2$偏移量，$1$偏度。</p><p>到目前为止，我们已经描述了三维相机参考系统中的一个点$P$到二维图像平面中的一个点$P’$之间的映射。但是如果关于3D世界的信息是不同的呢坐标系？然后，我们需要包括一个额外的转换，将点从世界参考系统到相机参考系统联系起来。这个转换被一个旋转器捕获离子矩阵$R$和平移向量$t$。因此，如果给定世界参考系统$P_w$中的一个点，我们可以计算其相机坐标如下：</p><script type="math/tex; mode=display">P=\begin{bmatrix}R & T\\0 & 10\end{bmatrix} P_w\tag{9}</script><p>将其代入方程（7）并简化给出：</p><script type="math/tex; mode=display">P'=K\begin{bmatrix}R&T\end{bmatrix} P_w=MP_w\tag{10}</script><p>这就完成了从任意世界参考系统中的三维点$P$​​到图像平面的映射。我们可以看到投影矩阵$M$​由两种类型的参数组成：固有参数和外部参数$c$​参数。相机矩阵$K$​中包含的所有参数都为固有参数，它们随相机类型的变化而变化。外在参数包括旋转和平移我并不依赖于相机的结构。总的来说，我们发现$3×4$​投影矩阵$M$​有$11$个自由度：$5$个来自内在相机矩阵，$3$个来自外在旋转，$3$个来自外在外在转化。</p><h2 id="1-5-相机校准"><a href="#1-5-相机校准" class="headerlink" title="1.5 相机校准"></a>1.5 相机校准</h2><p>要精确地了解从真实的3D世界到数字图像的转换，就需要事先了解相机的许多内在参数。如果给了一个任意的相机，我们可能会，也可能不会可以访问这些参数。然而，我们确实可以看到照相机拍摄的图像。因此，我们能找到一种方法从图像中推断出它们吗？估计外在和内在的相机参数问题被称为相机校准。</p><p><img src="https://s2.loli.net/2021/12/07/8BTWuQl7FkImVcz.png" alt="image-20211201100328709.png"></p><p>​                                    图7：一个示例校准设备的设置。</p><p>具体地说，我们通过求解公式10中的内在相机矩阵K和外在参数R、T来实现这一点。我们可以在校准设备的背景下来描述这个问题，如图7所示。设备通常由一个已知尺寸的简单图案（即棋盘）组成。此外，该设备定义了我们的世界参考系，包括原点$O_w$和轴$i_w$、$j_w$、$k_w$。从设备的已知模式来看，我们已经得到世界参考系$P_1,…,P_n$中的已知点。在我们从相机拍摄的图像中找到这些点会给出图像$p_1，…，p_n$中相应的点。</p><p>我们从$n$个对应项中建立了一个线性方程组，对于每个对应项的$P_i$、$p_i$和相机矩阵$M$，其行分别为$m_1$、$m_2$、$m_3$：</p><script type="math/tex; mode=display">p_i=\begin{bmatrix}u_i\\v_i\end{bmatrix}=MP_i=\begin{bmatrix}\frac{m_1P_i}{m_3P_i}\\[2ex]\frac{m_2P_i}{m_3P_i}\end{bmatrix}\tag{11}</script><p>正如我们从上面的方程中所看到的，每个对应关系都给出了我们两个方程，因此，也有两个求解$m$中所包含的未知参数的约束条件。从以前开始，我们知道相机矩阵有$11$个未知参数。这意味着我们至少需要$6$个对应关系来解决这个问题。然而，在现实世界中，我们经常使用更多的方法，作为我们的衡量标准设备通常是嘈杂的。为了明确地看到这一点，我们可以推导出一对将$u_i$和$v_i$与$P_i$相关联的方程。</p><script type="math/tex; mode=display">\begin{matrix}u_i(m_3P_i)-m_1P_i=0\\v_i(m_3P_i)-m_2P_i=0\end{matrix}</script><p>给定这些对应点中的$n$​个，等式的整个线性系统变成：</p><script type="math/tex; mode=display">\begin{matrix}u_1(m_3P_1)-m_1P_1=0\\v_1(m_3P_1)-m_2P_1=0\\\vdots\\u_n(m_3P_n)-m_1P_n=0\\u_n(m_3P_n)-m_2P_n=0\end{matrix}</script><p>这可以格式化为矩阵向量乘积，如下所示：</p><script type="math/tex; mode=display">\begin{bmatrix}P_1^{\rm T} & 0^{\rm T} & -u_1P_1^{\rm T}\\[2ex]0^{\rm T} & P_1^{\rm T} & -v_1P_1^{\rm T}\\[2ex]\vdots&\vdots&\vdots\\[2ex]P_n^{\rm T} & 0^{\rm T} & -u_nP_n^{\rm T}\\[2ex]0^{\rm T} & P_n^{\rm T} & -v_nP_n^{\rm T}\end{bmatrix}\cdot\begin{bmatrix}m_1^{\rm T}\\[2ex]m_2^{\rm T}\\[2ex]m_3^{\rm T}\end{bmatrix}=P_m=0\tag{12}</script><p>当$2n&gt;11$时，我们的齐次线性系统被超确定。对于这样的系统，$m=0$总是一个简单的解决方案。此外，即使有其他一些$m$是一个非零的解决方案，那么$∀k∈R$，$km$也是一个解决方案。因此，为了约束我们的解决方案，我们完成了以下最小化操作：</p><script type="math/tex; mode=display">\begin{matrix}\min_{m} \,\,\, ||P_m||^2\\[2ex]{\rm subject\,\,\, to}\,\,\,  ||m||^2 = 1\end{matrix}\tag{13}</script><p>为了解决这个最小化问题，我们只需简单地使用奇异值分解。如果我们让$P=UDV^{\rm T}$，那么上述最小化的解是设置$m$等于$V$的最后一列。此解决方案的推导超出了本类的范围，详见哈特利和齐瑟曼公司第592-593节的第5.3节。</p><p>在将向量$m$重新格式化为矩阵$M$后，我们现在想要显式地求解外部参数和内在参数。我们知道我们的SVD求解的$M$是公认的，这意味着相机矩阵的真值是$M$​的一些标量倍数：</p><script type="math/tex; mode=display">\rho M=\begin{bmatrix}\alpha r_1^{\rm T}-\alpha \cot \theta r_2^{\rm T}+ c_x r_3^{\rm T}& \alpha t_x-\alpha\cot\theta t_y+c_xt_z\\[2ex]\frac{\beta}{\sin \theta}r_2^{\rm T}+c_yr_3^{\rm T} &\frac{\beta}{\sin \theta}t_y+c_yt_z\\[2ex]r_3^{\rm T} &t_z\end{bmatrix}\tag{14}</script><p>在这里，$r^{\rm T}_1$、$r^{\rm T}_2$和$r^{\rm T}_3$是$r$​的三行。除以缩放参数给出：</p><script type="math/tex; mode=display">M=\frac{1}{\rho}\begin{bmatrix}\alpha r_1^{\rm T}-\alpha \cot\theta r_2^{\rm T}+c_xr_3^{\rm T} &\alpha t_x-\alpha \cot\theta t_y+c_xt_z \\[2ex]\frac{\beta}{\sin \theta}r_2^{\rm T}+c_yr_3^{\rm T} &\frac{\beta}{\sin \theta}t_y+c_y t_z\\[2ex]r_3^{\rm T}&t_z\end{bmatrix}=\begin{bmatrix}A & b\end{bmatrix}=\begin{bmatrix}a_1^{\rm T}\\a_2^{\rm T}\\a_3^{\rm T}\end{bmatrix}\cdot\begin{bmatrix}b_1\\b_2\\b_3\end{bmatrix}</script><p>解决内在因素给予：</p><script type="math/tex; mode=display">\begin{matrix}\rho=\pm\frac{1}{||a_3||}\\[2ex]c_x=\rho^2(a_1\cdot a_3)\\[2ex]c_y=\rho^2(a_2\cdot a_3)\\[2ex]\Large \theta=\cos^{-1}(-\frac{(a_1\times a_3)\cdot(a_2\times a_3)}{||a_1\times a_3||\cdot||a_2\times a_3||})\\[2ex]\alpha =\rho^2||a_1\times a_3||\sin \theta\\[2ex]\beta =\rho^2||a_2\times a_3||\sin\theta\end{matrix}\tag{15}</script><p>外部因素是：</p><script type="math/tex; mode=display">\begin{matrix}r_1=\frac{a_2\times a_3}{||a_2\times a_3||}\\r_2=r_3\times r_1\\r_3=\rho a_3\\T=\rho K^{-1}b\end{matrix}\tag{16}</script><p>我们把派生作为课堂练习，或者你可以参考福赛斯和庞塞教科书的第5.3.1节。</p><p>在校准程序完成后，我们将对退化的情况发出警告。并不是所有的$n$个对应集都能工作。例如，如果点$P_i$位于同一个平面上，那么系统将无法被求解。这些不可解的点构型被称为简并构型。更一般地说，简并构型的点位于两个二次曲面的交点曲线上。虽然这超出了课程的范围，但你可以在福赛斯和庞塞教科书的第1.3节中找到更多的信息。</p><h2 id="1-6-相机校准中的失真处理"><a href="#1-6-相机校准中的失真处理" class="headerlink" title="1.6 相机校准中的失真处理"></a>1.6 相机校准中的失真处理</h2><p>到目前为止，我们一直在使用理想的没有任何失真的镜头。然而，正如前面所看到的，真实的透镜可以偏离直线投影，这需要更先进的方法。本节仅简要介绍了处理畸变。</p><p>通常，由于透镜的物理对称性，畸变是径向对称的。我们用一个各向同性的变换来模拟径向畸变：</p><script type="math/tex; mode=display">QP_i=\begin{bmatrix}\frac{1}{\lambda} & 0 & 0\\0 & \frac{1}{\lambda} & 0\\0 & 0 & 1\end{bmatrix} M P_i=\begin{bmatrix}u_i\\v_i\end{bmatrix}=p_i\tag{17}</script><p>如果我们像以前一样把它重写成一个方程组，我们得到：</p><script type="math/tex; mode=display">\begin{matrix}u_iq_3P_i=q_1P_i\\[2ex]v_iq_3P_i=q_2P_i\end{matrix}</script><p>然而，该系统不再是线性的，我们需要使用非线性优化技术，这在福赛斯和庞塞的第22.2节中已经涵盖。如果我们做出一定的假设，我们可以简化校准问题的非线性优化。在径向失真中，我们注意到两个坐标$u_i$和$v_i$之间的比值不受影响。我们可以计算这个比率为：</p><script type="math/tex; mode=display">\frac{u_i}{v_i}=\frac{\frac{m_1P_i}{m_3P_i}}{\frac{m_2P_i}{m_3P_i}}=\frac{m_1P_i}{m_2P_i}\tag{18}</script><p>假设有$n$个对应项可用，我们可以建立线性方程组：</p><script type="math/tex; mode=display">\begin{matrix}v_1(m_1P_1)-u_1(m_2P_1)=0\\\vdots\\v_n(m_1P_n)-u_n(m_2P_n)=0\end{matrix}</script><p>与之前类似，这给出了一个矩阵向量积，我们可以通过SVD来求解：</p><script type="math/tex; mode=display">L_n=\begin{bmatrix}v_1P_1^{\rm T} & -u_1P_1^{\rm T}\\\vdots & \vdots\\v_nP_n^{\rm T} & -u_nP_n^{\rm T}\end{bmatrix}\cdot\begin{bmatrix}m_1^{\rm T}\\m_2^{\rm T}\end{bmatrix}\tag{19}</script><p>一旦估计了$m_1$和$m_2$，$m_3$就可以表示为$m_1$、$m_2$和$λ$的非线性函数。这需要解决一个非线性优化问题，该非线性优化问题的复杂性比原来的问题要简单得多。</p><h2 id="1-7-附录A：刚性变形"><a href="#1-7-附录A：刚性变形" class="headerlink" title="1.7 附录A：刚性变形"></a>1.7 附录A：刚性变形</h2><p>基本的刚性转换是旋转、平移和缩放。本附录将涵盖它们的3D案例，因为它们是这类文章中的常见类型。</p><p>在三维空间中旋转一个点可以通过分别绕着三个坐标轴旋转来表示。当绕着坐标轴旋转时，通常的惯例是沿逆时针方向旋转。一个直观的旋转思考方法是我们围绕每个自由度旋转了多少次，这通常被称为欧拉角。然而，这种方法可能会导致所谓的奇点，或万向节锁，其中某些配置会导致旋转自由度的损失。</p><p>防止这种情况发生的一种方法是使用旋转矩阵，这是一种更一般的旋转表示形式。旋转矩阵是方阵，具有行列式为1的正交矩阵。给定一个旋转矩阵$R$和一个向量$v$，我们可以计算得到的向量$v’$为：</p><script type="math/tex; mode=display">v'=Rv</script><p>由于旋转矩阵是矩阵的一个非常普遍的表示，我们可以围绕每个轴表示一个旋转$α$，$β$，$γ$如下：</p><script type="math/tex; mode=display">R_x(\alpha)=\begin{bmatrix}1 & 0 & 0\\0 & \cos \alpha & - \sin\alpha\\0 & \sin\alpha & \cos\end{bmatrix}</script><script type="math/tex; mode=display">R_y(\beta)=\begin{bmatrix}\cos\beta & 0 & \sin\beta\\0 & 1 &0\\-\sin\beta & 0 & \cos \beta\end{bmatrix}</script><script type="math/tex; mode=display">R_z(\gamma)=\begin{bmatrix}\cos\gamma & -\sin \gamma & 0\\\sin \gamma & \cos \gamma & 0\\0 & 0 & 1\end{bmatrix}</script><p>根据矩阵乘法的惯例，首先绕$z$轴旋转，然后绕$y$轴旋转，然后$x$轴由矩阵乘积$R_xR_yR_z$给出。</p><p>平移或位移被用来描述在一定方向上的运动。在三维空间中，我们定义了一个有$3$个值的平移向量$t$：$3$个轴上的位移，通常表示为$t_x$、$t_y$、$t_z$。因此，给定某个点$P$通过$t$转换为另一个点$P’$，我们可以将其写成：</p><script type="math/tex; mode=display">P'=P+t=\begin{bmatrix}P_x\\P_y\\P_z\end{bmatrix}+\begin{bmatrix}t_x\\t_y\\t_z\end{bmatrix}</script><p>在矩阵形式中，平动可以用齐次坐标来写。如果我们构造一个平移矩阵为：</p><script type="math/tex; mode=display">T=\begin{bmatrix}1 & 0 & 0 & t_x\\0 & 1 & 0 & t_y\\0 & 0 & 1 & t_z\\0 & 0 & 0 & 1\end{bmatrix}</script><p>然后我们看到$P’=TP$相当于$P’=P+t$。</p><p>如果我们想将平移和旋转矩阵乘法相结合，我们可以再次使用齐次坐标。如果我们想用$R$旋转一个向量$v$，然后用$t$平移它，我们可以把得到的向量$v’$写成：</p><script type="math/tex; mode=display">\begin{bmatrix}v'\\1\end{bmatrix}=\begin{bmatrix}R & t\\0 & 1\end{bmatrix}\cdot\begin{bmatrix}v\\1\end{bmatrix}</script><p>最后，如果我们想在向量方向上按一定量的$S_x$、$S_y$、$S_z$，我们可以构造一个尺度矩阵</p><script type="math/tex; mode=display">S=\begin{bmatrix}S_x & 0 & 0\\0 & S_y & 0\\0 & 0 & S_z\end{bmatrix}</script><p>因此，如果我们想缩放一个向量，然后旋转，然后平移，我们最终的变换矩阵将是：</p><script type="math/tex; mode=display">T=\begin{bmatrix}RS & t\\0 & 1\end{bmatrix}</script><p>请注意，所有这些类型的变换都将是仿射变换的例子。回想一下，当$T$的最后一行不是$[0 \,\,\,0 \,\,\,0\,\,\, 1]$时，会发生射影变换。</p><h2 id="1-8-附录B：不同的照相机型号"><a href="#1-8-附录B：不同的照相机型号" class="headerlink" title="1.8 附录B：不同的照相机型号"></a>1.8 附录B：不同的照相机型号</h2><p>我们现在将描述一个简单的模型，称为弱透视模型。在弱透视模型中，首先利用正交投影将点投影到参考平面上，然后进行投影用射影变换变换到图像平面。</p><p>如图8所示，给定离相机中心$z_o$距离的参考平面$\Pi$，首先使用正交投影将点$P$、$Q$、$R$投影到平面$\Pi$上，生成点$P\_$, $Q\_$ , $R\_$。这是一个合理的近似，当深度与平面的偏差是很小时，与相机的距离。</p><p><img src="https://obohe.com/i/2021/12/07/ihdyrl.png" alt></p><p>​                        图8：弱透视模型：在参考平面上的正交投影</p><p><img src="https://obohe.com/i/2021/12/07/ihmts6.png" alt></p><p>​                            图9：弱透视模型：投影到图像平面上</p><p>图9说明了点$P\_$、$Q\_$、$R\_$如何使用规则的投影变换投影到图像平面上，从而产生点$p’$、$q’$、$r’$。但是，请注意，由于我们已将每个点的深度近似为$z_o$，因此投影已被简化为一个简单的、恒定的放大倍数。放大倍数等于焦距$f’$除以$z_o$，导致</p><script type="math/tex; mode=display">x'=\frac{f'}{z_0}x\,\,\,\,\,\,\,\,\,\,\,\,\,y'=\frac{f'}{z_0}y</script><p>该模型还简化了投影矩阵：</p><script type="math/tex; mode=display">M=\begin{bmatrix}A & b\\0 & 1\end{bmatrix}</script><p>如我们所见，弱透视模型的$M$最后一行为$[0 \,\,\,0 \,\,\,0\,\,\, 1]$，而普通相机模型为$[v\,\,\,1]$。我们不证明这个结果并把它作为一个练习留给你吧。当将三维点映射到图像平面时，可以清楚地证明了这种简化性。</p><script type="math/tex; mode=display">P'=MP=\begin{bmatrix}m_1\\m_2\\m_3\end{bmatrix}P=\begin{bmatrix}m_1P\\m_2P\\1\end{bmatrix}\tag{20}</script><p>因此，我们可以看到，图像平面点最终成为原始三维点的放大倍数，而与深度无关。射影变换的非线性消失了，使得弱透视变换仅仅是一个放大镜。</p><p><img src="https://obohe.com/i/2021/12/07/ihn1hf.png" alt></p><p>​                                        图10：正字法投影模型</p><p>进一步简化后，得到了正字法（或仿射）投影模型。在这种情况下，光中心位于无穷远处。投影射线现在垂直于视网膜平面。因此，这个模型完全忽略了深度。因此，</p><script type="math/tex; mode=display">\begin{matrix}x'=x\\y'=y\end{matrix}</script><p>正形投影模型经常用于建筑和工业设计。</p><p>总的来说，弱视角模型的数学结果要简单得多，但代价是有些不精确。然而，当物体较小且远离相机时，它通常会产生非常准确的结果。</p>]]></content>
    
    
    <summary type="html">本文是课程cs231a的第1节笔记</summary>
    
    
    
    <category term="计算机视觉" scheme="http://wcx2001.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="http://wcx2001.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="cs231a" scheme="http://wcx2001.github.io/tags/cs231a/"/>
    
  </entry>
  
  <entry>
    <title>cs231a Course 4：立体声系统和运动结构恢复</title>
    <link href="http://wcx2001.github.io/2021/12/07/L4/"/>
    <id>http://wcx2001.github.io/2021/12/07/L4/</id>
    <published>2021-12-06T16:00:00.000Z</published>
    <updated>2021-12-07T13:31:00.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Course-4：立体声系统和运动结构恢复"><a href="#Course-4：立体声系统和运动结构恢复" class="headerlink" title="Course 4：立体声系统和运动结构恢复"></a>Course 4：立体声系统和运动结构恢复</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1  介绍"></a>1  介绍</h2><p>在前面的注释中，我们讨论了如何添加一个场景的额外视点可以极大地增强我们对所述场景的知识。我们专注于外极性几何设置，以便将一个图像平面上的点与另一个图像平面上的点联系起来，而不提取任何关于三维场景的信息。在这些课堂讲稿中，我们将讨论如何从多个二维图像中恢复有关三维场景的信息。</p><h2 id="2-三角剖分"><a href="#2-三角剖分" class="headerlink" title="2 三角剖分"></a>2 三角剖分</h2><p>多视图几何中最基本的问题之一是三角测量问题，即给定三维点投影到两个或多个图像的三维点位置的过程。</p><p><img src="/2021/12/07/L4/blog\source\_posts\视觉4.assets\image-20211204231213693-16386307346531.png" alt="image-20211204231213693"></p><p>​        图1：当给定两个视图时的三角测量问题的设置。</p><p>在两个视图的三角测量问题中，我们分别有两个已知相机固有参数$K$​和$K_0$​的相机。我们也知道这些相机彼此之间的相对方向和偏移量$R$、$T$。假设我们在三维中有一个点$P$，这可以分别在$p$和$p’$的两个相机的图像中找到。虽然$P$的位置目前尚不清楚，但我们可以测量$p$和$p’$在图像中的确切位置。由于$K$、$K’$、$R$、$T$是已知的，我们可以计算两个视线$l$和$l’$，它们由相机中心$O_1$、$O_2$和图像位置$p$、$p’$定义。因此，$P$可以计算为$l$和$l’$的交点。</p><p><img src="/2021/12/07/L4/blog\source\_posts\视觉4.assets\image-20211204231503216-16386309041802.png" alt="image-20211204231503216"></p><p>​        图2：真实场景中的三角测量问题通常涉及到最小化重投影误差。</p><p>虽然这个过程看起来既简单又数学合理，但在实践中并不是很好。在现实世界中，由于观测值$p$和$p’$有噪声，相机校准参数不精确，寻找$l$和$l’$的交点可能存在问题。在大多数情况下，它根本不存在，因为这两条线可能永远不会相交。        </p><h2 id="2-1-A-linear-method-for-triangulation"><a href="#2-1-A-linear-method-for-triangulation" class="headerlink" title="2.1 A linear method for triangulation"></a><strong>2.1 A linear method for triangulation</strong></h2><p>在本节中，我们将描述一个简单的线性三角测量方法，以解决射线之间缺乏交点。我们在图像中给出了两点相互对应的$p=MP=(x,y,1)$和$p’=M’P=(x’,y’,1)$。根据交叉积的定义，$p×(MP)=0$​。我们可以显式地使用交叉积生成的等式来形成三个约束：</p><script type="math/tex; mode=display">\begin{matrix}x(M_3P)-(M_1P)=0\\y(M_3P)-(M_3P)=0\\x(M_2P)-y(M_1P)=0\end{matrix}\\tag{2.1}</script><p>其中$M_i$​是矩阵$M$​的第$i$​行。对于$p’$和$M’$也可以表示类似的约束。利用这两幅图像的约束条件，我们可以建立一个$AP=0$形式的线性方程，其中</p><script type="math/tex; mode=display">A=\left[\begin{matrix}xM_3-M_1\\yM_3-M_2\\x'M_3-M_1'\\y'M_3'-M_2'\end{matrix}\right ]\tag{2.2}</script><p>该方程可以用SVD来求解，从而得到点$p$的最佳线性估计。该方法的另一个有趣的方面是，它实际上也可以处理来自多个视图的三角化。为此，简单地将添加的行附加到新视图添加的约束。</p><p>然而，该方法不适合用于射影重建，因为它不是射影不变的。例如，假设我们将相机矩阵M，M’替换为受射影变换$MH^{−1}$​，$M’H^{−1}$​影响的矩阵。线性方程A的矩阵变成$AH^{−1}$​。因此，之前对$AP=0$的估计的解决方案P将对应于转换问题$(AH^{−1})(HP)=0$的解决方案HP。回想一下，SVD解决了$||P||=1$​的约束，它在射影变换H下不是不变的。因此，该方法虽然简单，但往往不是三角剖分问题的最优解。</p><h2 id="2-2对三角剖分的一种非线性方法"><a href="#2-2对三角剖分的一种非线性方法" class="headerlink" title="2.2对三角剖分的一种非线性方法"></a>2.2对三角剖分的一种非线性方法</h2><p>相反，现实世界场景中的三角剖分问题通常被数学上描述为解决一个最小化问题：</p><script type="math/tex; mode=display">\underset{\hat P} {min}\vert\vert M\hat P - p \vert \vert + \vert \vert M' \hat P-p' \vert \vert \tag{2.3}</script><p>在上述方程中，我们通过寻找两幅图像中Pˆ的重投影误差的最佳最小二乘估计值，来寻找一个最接近P的三维$\hat P$​。图像中三维点的重投影误差是图像中该点的投影与图像平面中对应的观测点之间的距离。在图2中我们的示例中，由于M是从三维空间到图像1的投影变换，所以图像1中$\hat P$​的投影点为$M\hat P$​。图1中$\hat P$​的匹配观测值为p。因此，图像1的重投影误差为距离$||M\hat P−p||$​。在公式2.3中发现的总体重投影误差是所有图像的重投影误差之和。对于有两幅以上图像的情况，我们只需在目标函数中添加更多的距离项：</p><script type="math/tex; mode=display">\underset {\hat P}{\min} \sum _i ||M \hat P_i-p_i || ^2 \tag{2.4}</script><p>在实践中，存在着各种非常复杂的优化技术，它们可以很好地近似于问题。然而，对于该类的范围，我们将只关注其中一种技术，即非线性最小二乘的高斯-牛顿算法。一般的非线性最小二乘问题是找到一个最小化的$x∈R^n$​</p><script type="math/tex; mode=display">\vert\vert r(x)\vert\vert^2 = \sum_{i=1}^mr_i(x)^2 \tag{2.5}</script><p>其中$r$是任何残差函数$r$：$R^n→R^m$​，这样对于某个函数f的$r(x)=f(x)-y$，输入$x$和观察$y$。当函数$f$为线性问题时，非线性最小二乘问题简化为正则的线性最小二乘问题。然而，回想一下，一般来说，我们的相机矩阵并不是仿射的。由于对图像平面的投影通常涉及到均匀坐标的除法，因此对图像的投影通常是非线性的。</p><p>请注意，如果我们将$e_i$​设置为一个$2×1$向量$e_i=M\hat P_i−p_i$​，那么我们可以重新表述我们的优化问题为：</p><script type="math/tex; mode=display">\underset {\hat P}{\min} \sum _i e^i(\hat P)^2 \tag{2.6}</script><p>它可以完美地表示为一个非线性最小二乘问题。</p><p>在这些注释中，我们将介绍如何使用流行的高斯-牛顿算法来找到这个非线性最小二乘问题的近似解。首先，让我们假设我们对三维点$\hat P$​有一个有点合理的估计，我们可以用前面的线性方法来计算它。高斯-牛顿算法的关键见解是更新我们的估计，将其修正为一个更好的估计，从而最小化重投影误差。在每一步，我们想更新一些估计$\hat Pδ_P：\hat P=\hat P+δ_P$​。</p><p>但是我们如何选择更新参数$δ_P$​呢？高斯-牛顿算法的关键见解是线性化在当前估计$\hat P$​附近的残差函数。在我们的问题中，这意味着一个点P的残差e可以看作是：</p><script type="math/tex; mode=display">e(\hat P+\delta_p) \approx e(\hat P)+\frac{\partial e}{\partial P}\delta_p \tag{2.7}</script><p>随后，将最小化问题转化为</p><script type="math/tex; mode=display">\underset{\delta _P}{min} \vert \vert \frac {\partial e}{\partial P} \delta_P- (-e(\hat P)) \vert \vert^2 \tag{2.8}</script><p>当我们这样表示残差时，我们可以看到它采用了标准线性最小二乘问题的格式。对于$N$幅图像的三角剖分问题，线性最小二乘解为</p><script type="math/tex; mode=display">\delta _P = -(J^TJ)^{-1}J^Te \tag{2.9}</script><p>其中</p><script type="math/tex; mode=display">e = \left[\begin {matrix}e_1\\ \vdots\\e_N\end{matrix}\right]=\left[\begin{matrix}p_1-M_1\hat P\\ \vdots\\p_n-M_n\hat P\end{matrix}\right]\tag{2.10}</script><script type="math/tex; mode=display">J=\left[\begin {matrix}\frac {\partial e_1} {\partial \hat P_1}& \frac {\partial e_1} {\partial \hat P_2}& \frac {\partial e_1} {\partial \hat P_3}\\\vdots &\vdots& \vdots \\\frac {\partial e_N} {\partial \hat P_1}& \frac {\partial e_N} {\partial \hat P_2}& \frac {\partial e_N} {\partial \hat P_3}\end{matrix}\right] \tag{2.11}</script><p>​        回想一下，一个特定图像$e_i$的残差向量是一个2×1向量，因为在图像平面上有二维空间。因此，在最简单的三角测量的两个相机情况($N=2$)中，这导致残差向量$e$是一个$2N×1=4×1$向量，雅可比矩阵$J$是一个$2N×3=4×3$矩阵。请注意该方法如何无缝地处理多个视图，因为通过将相应的行添加到e向量和J矩阵来解释额外的图像。在计算了更新$δ_P$之后，我们可以简单地对固定数量的步骤重复这个过程，或者直到它在数值上收敛。高斯-牛顿算法的一个重要性质是，我们假设残差函数接近我们的估计是线性的，这不能保证收敛。因此，在实践中，对估计数的更新次数设置一个上限总是有用的。</p><h2 id="3-从运动开始的仿射结构"><a href="#3-从运动开始的仿射结构" class="headerlink" title="3.从运动开始的仿射结构"></a>3.从运动开始的仿射结构</h2><p>在前一节的结尾，我们暗示了如何超越一个场景的两个视图来获得关于3D场景的信息。我们现在将探索将两个相机的几何形状扩展到多个相机。通过结合来自多个视角的点的观察，我们将能够同时确定场景的三维结构和摄像机的参数，即所谓的<strong>运动结构</strong>。</p><p><img src="/2021/12/07/L4/blog\source\_posts\视觉4.assets\image-20211205163943212-16386935853084.png" alt="image-20211205163943212"></p><p>​        图3：基于运动问题的总体结构的设置。</p><p>在这里，我们正式地介绍了从运动问题出发的结构。假设我们有$m$个相机与相机转换$M_i$编码相机的内在和外在参数。设$X_j$为场景中的$n$个3D点之一。每个3D点可以在多个位于$x_{ij}$位置的摄像机中可见，即使用投影变换$M_i$对摄像机$i$图像的投影。运动结构的目的是从所有观测值$x_{ij}$中恢复场景的结构（$n$三维点$X_j$）和摄像机的运动（$m$投影矩阵$M_i$​）。</p><h2 id="3-1由运动问题引起的仿射结构"><a href="#3-1由运动问题引起的仿射结构" class="headerlink" title="3.1由运动问题引起的仿射结构"></a>3.1由运动问题引起的仿射结构</h2><p>在解决运动问题的一般结构之前，我们将首先从一个更简单的问题开始，即假设相机是仿射或弱视角。最终，由于缺乏透视图的缩放操作，这使得数学推导更容易解决这个问题。</p><p>之前，我们推导了上述透视和弱透视情况的方程。请记住，在全透视模型中，相机矩阵被定义为</p><script type="math/tex; mode=display">M = \left[\begin{matrix}A & b\\ v & 1\end{matrix}\right]\tag{3.1}</script><p>其中$v$是一些非零的$1×3$向量。另一方面，对于弱透视模型，$v=0$。我们发现这个性质使$MX$的齐次坐标等于$1$：</p><script type="math/tex; mode=display">x=MX=\left[\begin{matrix}& m_1\\& m_2\\0&0&0&1\end{matrix}\right]\left[\begin{matrix}X_1\\X_2\\X_3\\1\end{matrix}\right]=\left[\begin{matrix}m_1X\\m_2x\\1\end{matrix}\right]\tag{3.2}</script><p>因此，当我们从齐次坐标移动到欧几里得坐标时，投影变换的非线性消失了，而弱透视变换仅仅作为一个放大镜。我们可以更紧凑地将投影表示为：              </p><script type="math/tex; mode=display">\left[\begin{matrix}m_1X\\m_2X\end{matrix}\right]=\left[\begin{matrix}A &b\end{matrix}\right]X=AX+    b\tag{3.3}</script><p>并以仿射$M_{affine}=[A\ \ b]$​.的格式表示任何相机矩阵因此，我们现在使用仿射相机模型来表示三维中的$X_j$​点和每个仿射相机中相应的观察结果(例如，相机$i$​中的$x_{ij}$​)。</p><p>从运动问题回到结构，我们需要从$m ,n$​观测中估计m个矩阵$M_i$​和n个世界坐标向量$X_j$​，总共有$8m+3n$个未知数。每个观测结果对每个相机产生$2$个约束，所以在$8m+3n$未知数中有$2mn$方程。我们可以用这个方程来知道我们需要拥有的每张图像中相应观测数的下界。例如，如果我们有$m=2$个相机，那么我们需要在3D中至少有$n$个$=16$点。然而，一旦我们在每张图像中都标记了足够的对应点，我们如何解决这个问题呢？</p><h2 id="3-2托马西和卡纳德分解方法"><a href="#3-2托马西和卡纳德分解方法" class="headerlink" title="3.2托马西和卡纳德分解方法"></a>3.2托马西和卡纳德分解方法</h2><p>在这部分中，我们概述了托马西和卡纳德求解仿射结构的分解方法。该方法主要包括数据定心步骤和实际分解步骤。</p><p><img src="/2021/12/07/L4/blog\source\_posts\视觉4.assets\image-20211205170859869-16386953408895.png" alt="image-20211205170859869"></p><p>图4：当应用定心步骤时，我们对所有的图像点进行平移，使其质心（记为左下红十字）位于图像平面的原点。同样地，我们将世界坐标系置为原点位于三维点的质心处（记为右上角的红十字）。</p><p>让我们从数据定中心的步骤开始。在这一步中，主要的思想是将数据集中在原点。为此，对于每个图像$i$​，我们通过减去其质心$\hat x_{ij}$​来重新定义每个图像点$x_{ij}$​的新坐标$\bar {x_{ij}}$​​：</p><script type="math/tex; mode=display">\hat x_{ij}= x_{ij}-\bar x_i=x_{ij}-\frac {1}{n}\sum_{j=1}^nx_{ij}\tag{3.4}</script><p>回想一下，来自运动问题的仿射结构允许我们定义图像点$x_{ij}$​、相机矩阵变量$A_i$​和$b_i$​，以及三维点$X_j$​之间的关系为：</p><script type="math/tex; mode=display">x_{ij}=A_jX_j+b_i\tag{3.5}</script><p>在这个定心步骤之后，我们可以结合公式$3.4$中的中心图像点$\hat x_{ij}$​的定义和公式$3.5$中的仿射表达式：</p><script type="math/tex; mode=display">\begin{align}\hat x_{ij}&=\hat x_{ij}-\frac{1}{n}\sum_{k=1}^nx_{ik}\\& =A_iX_j-\frac {1}{n}\sum_{k=1}^nA_iX_k\\& =A_i(X_j-\frac {1}{n}\sum_{k=1}^nX_k)\\& =A_i(X_j-\bar X)\\&=A_i\hat X_j \end{align}\tag{3.6}</script><p>从方程3.6中可以看出，如果我们将世界参考系统的起源转换为质心$\bar X$​​，那么图像点$x_{ij}$​​的中心坐标和3D点$\hat X_{ij}$​​的中心坐标仅通过一个$2×3$矩阵$A_i$​​进行关联。最终，分解方法的定心步骤允许我们创建一个紧凑的矩阵积表示，将三维结构与多个图像中的观测点联系起来。</p><p>但是，请注意，在矩阵乘积$\hat x_{ij}=A_i\hat X_j$​中，我们只能访问方程左侧的值。因此，我们必须以某种方式考虑出运动矩阵$A_i$​和结构$X_j$​。利用所有摄像机的所有观测结果，我们可以建立一个测量矩阵$D$，由$m$个摄像机中的$n$个观测结果组成(记住，每个$\hat x_{ij}$​入口都是一个$2×1$向量)：</p><script type="math/tex; mode=display">D=\left[\begin{matrix}\hat x_11 & \hat x_12 &\cdots &\hat x_1n\\\hat x_21 & \hat x_22 &\cdots &\hat x_2n\\\vdots&\vdots&\ddots&\vdots \\\hat x_m1 & \hat x_m2 &\cdots & \hat x_mn\\\end{matrix}\right]\tag{3.7}</script><p>现在回想一下，由于我们的仿射假设，D可以表示为$2m×3$​运动矩阵$M$(包括相机矩阵$A_1，…A_m$)和$3×n$结构矩阵$S$(包括3D点$X_1，…X_n$​​)的乘积。我们将使用的一个重要事实是秩$D$为$3$，因为$D$是两个最大维数为3的矩阵的乘积。</p><p>为了将$D$分解为$M$和$S$，我们将使用奇异值分解，$D=UΣV^T$​。因为我们知道秩为$D=3$，所以在$Σ$中只有$3$个非零奇异值$σ_1$，$σ_2$和$σ_3$。因此，我们可以进一步简化的表达式，得到以下分解方法：</p><script type="math/tex; mode=display">\begin{align}D&=U\sum V^T\\    &=\left[    \begin{matrix}u_1&\cdots&u_n    \end {matrix}\right]    \left[    \begin{matrix}    \sigma_1&0&0&0&\cdots&0\\    0&\sigma_2&0&0&\cdots&0\\    0&0&\sigma_3&0&\cdots&0\\    0&0&0&0&\cdots&0\\    \ & \ & \ & \ &\ddots &\ \\    0&0&0&0&\cdots&0\\    \end{matrix}    \right]    \left[    \begin{matrix}v_1^T\\ \vdots \\ v_n^T    \end {matrix}\right]\\    & =\left[    \begin{matrix}u_1&u_2&u_3    \end {matrix}\right]    \left[    \begin{matrix}\sigma_1&0&0\\    0&\sigma_2&0\\    0&0&\sigma_3&\\    \end {matrix}\right]        \left[    \begin{matrix}v_1^T\\ v_2^T\\ v_n^T    \end {matrix}\right]\\    &=U_3Σ_3V_3^T \end{align}    \tag{3.8}</script><p>在此分解中，$Σ_3$​定义为非零奇异值形成的对角矩阵，而$U_3$和$V_3T$分别取对应的$U$列和$V^T$​行得到。不幸的是，在实践中，由于测量噪声和仿射相机近似，秩$D&gt;3$。然而，请记住，当秩$D&gt;3$时，$U_3W_3V_3^T$​仍然是弗罗比尼乌斯范数意义上的最好的秩3近似。</p><p>经过仔细检查，我们发现矩阵积$Σ_3V_3^T$​​形成一个$3×n$​的矩阵，大小完全相同的结构矩阵$S$​类似，同样$U_3$​是一个$2m×3$矩阵，相同大小的运动矩阵M。虽然这种关联的组件SVD分解M和S导致一个物理和几何解的仿射结构从运动问题，这个选择不是一个唯一的解决方案。例如，我们也可以将运动矩阵设置为$M=U_3Σ_3$，将结构矩阵设置为$S=V_3^T$，因为在这两种情况下，观测矩阵$D$都是相同的。那么我们要选择什么因子分解呢？托马西和卡纳德得出结论，该因素分解的稳健选择是$M=U_3\sqrt{Σ_3}$和$S=\sqrt{Σ_3}V_3^T$​​。</p><h2 id="3-3-重建中的模糊性"><a href="#3-3-重建中的模糊性" class="headerlink" title="3.3 重建中的模糊性"></a>3.3 重建中的模糊性</h2><p>不过，我们发现在任何分解$D=MS$的选择中有固有的歧义，因为任何任意的、可逆的$3×3$矩阵$A$都可以插入到分解中：</p><script type="math/tex; mode=display">D = MAA^{−1}S = (MA)(A^{−1}S) \tag{3.9}</script><p>这意味着从运动$M$获得的相机矩阵和从结构$S$获得的三维点可以乘以$10$个公共矩阵$a$。因此，我们的解决方案尚未确定，需要额外的约束来解决这种仿射歧义。当重构具有仿射模糊性时，这意味着保持了并行性，但度量尺度是未知的。</p><p>重建的另一类重要的歧义是相似度歧义，当重建被修正到相似度变换（旋转、平移和缩放）时，就会发生相似度歧义。一个只有相似性歧义的重构被称为度量重构。即使相机经过本质校准，这种模糊性也存在。好消息是，对于校准的相机，相似模糊是唯一的模糊。</p><p>事实上没有办法从图像中恢复一个场景的绝对尺度。除非我们做出进一步的假设（例如，我们知道图中房子的高度）或包含更多的数据，否则一个物体的尺度、绝对位置和规范方向总是未知的。这是因为某些属性可以补偿其他属性。例如，为了获得相同的图像，我们可以简单地向后移动对象，并相应地缩放它。在相机校准过程中出现了一个消除相似性模糊性的例子，我们假设我们知道校准点相对于现实世界参考系统的位置。这使我们能够知道棋盘上的正方形的大小，以学习三维结构的度量尺度。</p><h2 id="4-1-从运动开始的透视结构"><a href="#4-1-从运动开始的透视结构" class="headerlink" title="4.1 从运动开始的透视结构"></a>4.1 从运动开始的透视结构</h2><p>在研究了运动问题的简化仿射结构后，再考虑射影相机$M_i$​的一般情况。在一般情况下使用投影摄像机，每个相机矩阵$M_i$​包含$11$个自由度，因为它是被定义为：</p><script type="math/tex; mode=display">M_i=\left[\begin{matrix}a_11 &a_12 &a_13 b_1\\a_21 &a_22 &a_23 b_1\\a_31 &a_32 &a_33 1\end{matrix}\right]\tag{4.1}</script><p>此外，类似于仿射情况下的解可以找到一个仿射变换，解决结构和运动可以确定一个射影变换在一般情况下：我们总是可以任意应用一个4×4射影变换H运动矩阵，只要我们也变换结构矩阵的逆变换$H^{−1}$​。在图像平面上得到的观测结果仍然相同。</p><p>与仿射情况类似，我们可以从运动问题建立一般结构，从$m,n$观测$x_{ij}$估计$m$运动矩阵$M_i$和$n$三维点$X_j$​。因为相机和点只能在$4×4$投影变换（$15$个参数）上恢复，我们在$2mm$方程中有$11m+3n−15$未知数。根据这些事实，我们可以确定解决未知问题所需的观点和观察结果的数量</p><h2 id="4-1-代数方法"><a href="#4-1-代数方法" class="headerlink" title="4.1 代数方法"></a><strong>4.1 代数方法</strong></h2><p><img src="/2021/12/07/L4/blog\source\_posts\视觉4.assets\image-20211205234733614-16387192544986.png" alt="image-20211205234733614"></p><p>图5：在代数方法中，我们考虑顺序的，相机对来确定相机矩阵$M_1$​和$M_2$​，直到一个透视变换。然后我们发现了一个透视变换H，即$M_1H=[I \ \ \ \  0]和M_2H=[A\ \ \ \ B]$​</p><p>我们现在将介绍代数方法，它利用基本矩阵F的概念来解决两个相机的运动问题的结构。如图5所示，代数方法的主要思想是计算两个相机矩阵$M_1$​和$M_2$​，这只能计算到一个透视变换H。由于每个Mi只能计算一个透视变换H，我们总是可以考虑一个H，这样第一个相机投影矩阵$M_1H^{−1}$​是典型的。当然，同样的转换也必须应用于第二个相机，这导致了显示的形式：</p><script type="math/tex; mode=display">M_1H^{-1}=[I \ \ \ \ \ 0]\ \ \ \ M_2H^{-1}=[A\ \ \ \ \ B]\tag{4.2}</script><p>​        为了完成这一任务，我们必须首先使用前面的课程注释中提到的八点算法来计算基本矩阵F。我们现在将使用F来估计射影相机矩阵$M_1和M_2$​。为了做这个估计，我们将P定义为图像p和p’中相应观测值的相应三维点。由于我们已经将$H^{−1}$​应用于两个相机投影矩阵，所以我们也必须将H应用于结构，给我们$\tilde P=HP$​。因此，我们可以将像素坐标$p$和$p’$与转换后的结构联系起来如下：</p><script type="math/tex; mode=display">\begin{matrix}p=M_1P=M_1H^{−1}H P=[I\ \ |\ \ 0]\tilde P\\p'=M_2P=M_2H^{−1}HP=[A\ \ |\ \ b]\tilde P\end{matrix}\tag{4.3}</script><p>两个图像对应的p和p’之间的一个有趣的属性通过一些创造性的替换而出现：</p><script type="math/tex; mode=display">\begin{align}p' &= [A|b]\tilde P\\[2ex]&=  A[I|0]\tilde P + b \\[2ex]&= Ap + b\\[2ex]\end{align} \tag{4.4}</script><p>利用公式4.4，我们可以将p’和b之间的交叉积写为：</p><script type="math/tex; mode=display">p' × b = (Ap + b) × b = Ap × b \tag{4.5}</script><p>根据交叉积的定义，p’×b垂直于p’。因此，我们可以写道：</p><script type="math/tex; mode=display">\begin{align}0&= p' ^T (p' × b)\\[2ex]&= p' ^T (Ap × b) \\[2ex]&= p' ^T · (b × Ap) \\[2ex]&= p' ^T [b]_×Ap\end{align}\tag{4.6}</script><p>看看这个约束条件，它应该会提醒你基本矩阵$p’^TFp=0$​的一般定义。如果我们设置了$F=[b]_×A$​，那么提取A和b就会简单地分解为一个分解问题。</p><p>让我们从确定$b$开始。同样，根据交叉积的定义，我们可以简单地把$Fb$写成</p><script type="math/tex; mode=display">F b = [b]_×Ab = (b × A)b = 0 \tag{4.7}</script><p>由于F是奇异的，$b$可以用SVD,在$||b||=0$的条件下计算为$k=0$的最小二乘解。</p><p>一旦$b$知道，我们就可以计算$A$。如果我们设置了一个$A=−[b]_×F$，那么我们可以验证这个定义满足$F=[b]_×A$​：</p><script type="math/tex; mode=display">\begin{align}[b_×]A' =&−[b×][b×]F\\[2ex]&= (bb^T − |b|^2I)F \\[2ex]&= bb^TF + |b|^2F\\[2ex]&= 0 + 1 · F \\[2ex]&= F\end{align}\tag{4.8}</script><p>​    因此，我们确定了相机矩阵$M_1H^{−1}$和$M_2H^{−1}$的两个表达式：</p><script type="math/tex; mode=display">\tilde M_1 = [I\ \ \ \  0] \ \ \ \ \ \ \ \tilde M_2 = [−[e_×]F \ \ \ \ e] \tag{4.10}</script><h2 id="4-2-从本征矩阵中确定运动"><a href="#4-2-从本征矩阵中确定运动" class="headerlink" title="4.2 从本征矩阵中确定运动"></a>4.2 从本征矩阵中确定运动</h2><p>改进由代数方法得到的重建的一个有用的方法是使用校准的相机。利用基本矩阵是标准化坐标基本矩阵的一种特殊情况，可以提取出相机矩阵的更精确的初始估计。回想一下，通过使用基本矩阵E，我们假设我们已经校准了相机，从而知道内在相机矩阵$K$。我们可以直接从归一化图像坐标，也可以从它与基本矩阵$F$和内在矩阵$K$的关系来计算基本矩阵$E$：</p><script type="math/tex; mode=display">E = K^TFK \tag{4.11}</script><p>因为基本矩阵假设我们有校准的相机，我们应该记住它只有$5$个自由度，因为它只有编码外部参数：相机之间的旋转$R$和平移$t$。幸运的是，这正是我们想要提取的用来创建运动矩阵的信息。首先，记住基本矩阵E可以表示为</p><script type="math/tex; mode=display">E = [t]_×R \tag{4.12}</script><p>因此，也许我们可以找到一种策略来将E纳入其两个组成部分。首先，我们应该注意到交叉积矩阵$[t]_×$是偏对称的。我们定义了两个我们将在分解中使用的矩阵：</p><script type="math/tex; mode=display">W=\left[\begin{matrix}0&-1&0\\1&0&0\\0&0&1\end{matrix}\right],\ \ \ \ \ \ \Z=\left[\begin{matrix}0&1&0\\-1&0&0\\0&0&0\end{matrix}\right]\tag{4.13}</script><p>我们稍后将使用的一个重要特性是$Z=diag(1,1,0)W$到一个标志。类似地，我们也将使用$ZW=ZW^T=diag(1,1,0)$到一个符号。</p><p>由于特征值分解的结果，我们可以创建一个已知的一般偏对称矩阵的块分解。因此，我们可以将$[t]_×$写为</p><script type="math/tex; mode=display">[t]_× = UZU^T \tag{4.14}</script><p>其中$U$是某个正交矩阵。因此，我们可以将该分解数重写为：</p><script type="math/tex; mode=display">E = Udiag(1,1,0)(W U^TR)\tag{4.15}</script><p>仔细观察这个表达式，我们发现它非常类似于奇异值分解$E=UΣV^T$，其中Σ包含两个相等的奇异值。如果我们知道E，并且我们假设它采用了$E=Udiag(1,1,0)V^T$的形式，那么我们得到了E的以下分解：</p><script type="math/tex; mode=display">[t]_×=UZU^T，\ \ R=UWV^T \ \ or\ \  UW^TV^T \tag{4.17}</script><p>通过检验，我们可以证明所给定的分解是有效的。我们还可以证明没有其他因素的分解。$[t]_×$的形式是由它的左零空间必须与E的零空间相同而决定的。给定一元矩阵U和V，任何旋转R都可以分解为$UXV^T$，其中X是另一个旋转矩阵。在替换这些值后，我们得到了$ZX=diag(1,1,0)$。因此，X必须等于W或$W^T$。</p><p>请注意，E的这种分解只保证了矩阵$UWV^T$或$UW^TV^T$是正交的。为了确保R是一个有效的旋转，我们只是要确保R的行列式是正的：</p><script type="math/tex; mode=display">R=(detUW^TV^T)UWV^T\ \ \ \ or \ \ \ \ (detUW^TV^T)UW^TV^T \tag{4.17}</script><p>与类似于旋转$R$如何取两个潜在值相似，平移向量$t$也可以取几个值。从交叉积的定义中来看，我们知道</p><script type="math/tex; mode=display">t × t = [t]_×t = UZU^T t = 0 \tag{4.18}</script><p>知道$U$是一元的，我们可以发现$||[t]_×||F=\sqrt{2}$。因此，我们从这个分解的$t$估计将从上面的方程和$E$是已知的，这意味着</p><script type="math/tex; mode=display">t= \pm U\left[\begin{matrix}0\\0\\1\end{matrix}\right]=\pm u_3 \tag{4.13}</script><p>其中$u_3$是$U$的第三列。通过检查，我们还可以通过将$[t]_×=UZU^T$重新格式化为已知的向量$t$来验证我们得到相同的结果。</p><p><img src="/2021/12/07/L4/blog\source\_posts\视觉4.assets\image-20211206004541777-16387227427507.png" alt="image-20211206004541777"></p><p>图6：从基本矩阵中提取相对相机旋转R和平移t有四种可能的解决方案。然而，只有(a)中重建点在两个摄像机前。（图片取自哈特利和齐泽尔曼出版社的教科书第260页）</p><p>如图6所示，由于$R$和$t$同时存在两种选项，因此$R$和$t$都存在两种选项。直观地说，这四对对包括所有$16$种可能的对，即在特定方向旋转相机或在相反方向旋转相机，以及在特定方向或相反方向移动相机的选择。因此，在理想条件下，我们只需要三角化一个点来确定正确的一对$R$，$t$对。对于正确的一对$R$，$t$，三角化的点$\hat P$存在于两个相机的前面，这意味着它相对于两个相机参考系统都有一个正的$z$坐标。由于测量噪声，我们通常不依赖于三角点，而是三角测量许多点，并确定正确的一对$R$，$t$，作为两个相机前包含这些点的大多数。</p><h2 id="5-一个来自运动管道的结构示例"><a href="#5-一个来自运动管道的结构示例" class="headerlink" title="5 一个来自运动管道的结构示例"></a>5 一个来自运动管道的结构示例</h2><p>在找到相对运动矩阵$M_i$后，我们可以用它们来确定点$X_j$的世界坐标。在代数方法的情况下，这些点的估计将修正透视变换h。在从基本矩阵中提取相机矩阵时，估计可以被知道。在这两种情况下，三维点都可以通过前面描述的三角测量方法从估计的相机矩阵中计算出来。</p><p>对多视图案例的扩展可以通过链接成对的摄像机来完成。利用代数方法或基本矩阵，我们可以利用代数方法得到任意一对相机的相机矩阵和三维点的解，只要有足够的点对应。重建的3D点与相机对之间可用的点对应关系相关联。我们接下来将看到，这些成对的解决方案可以以一种称为捆绑调整的方法组合在一起（优化）。</p><h2 id="5-1-套件调整"><a href="#5-1-套件调整" class="headerlink" title="5.1 套件调整"></a>5.1 套件调整</h2><p>到目前为止，我们讨论的从运动问题解决结构的方法有很大的局限性。该分解方法假设所有的点在每幅图像中都是可见的。这是不太可能发生的，因为当我们有很多图像，或者有些图像相距遥远时，就会被遮挡，无法找到对应关系。最后，代数方法产生了成对的解，可以组合成一个摄像机链，但不能解决使用所有摄像机和三维点的相干优化重建。</p><p>为了解决这些限制，我们引入了<strong>束调整</strong>，这是一种从运动问题中求解结构的非线性方法。在优化中，我们的目标是尽量减少重投影误差，即一个重建点对估计摄像机的投影与其对所有摄像机和所有点的相应观测值之间的像素距离。之前，当讨论三角剖分的非线性优化方法时，我们主要关注这两个相机盒，我们自然地假设每个相机看到了两者之间的所有对应关系。然而，由于束束调整处理几个相机，它只计算每个相机可以看到的观测结果的重投影误差。最终，这个优化问题与我们在讨论三角测量的非线性方法时引入的问题非常相似。</p><p>求解束调整非线性优化的两种常用方法包括高斯-牛顿算法和莱文伯格-马夸特算法。您可以参考上一节关于高斯牛顿算法的细节，并参考哈特利和泽瑟曼教科书，了解更多关于莱文伯格-马夸特算法的细节。</p><p>综上所述，与我们所调查的其他方法相比，管束调整有一些重要的优点和局限性。它特别有用，因为它可以平滑地处理大量的视图，而且也可以处理每个图像都不能观察到特定点时的情况。然而，主要的限制是它是一个特别大的最小化问题，因为参数随着视图数量的增长。此外，由于它依赖于非线性优化技术，因此需要一个很好的初始条件。因此，束调整经常被用作来自运动实现的大多数结构的最后一步（即，在因子分解或代数方法之后），因为一种因子分解或代数方法可以为优化问题提供一个很好的初始解决方案。</p>]]></content>
    
    
    <summary type="html">本文是课程cs231a的第4节笔记</summary>
    
    
    
    <category term="计算机视觉" scheme="http://wcx2001.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="http://wcx2001.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="cs231a" scheme="http://wcx2001.github.io/tags/cs231a/"/>
    
  </entry>
  
  <entry>
    <title>npuSE Chapter 1 绪论</title>
    <link href="http://wcx2001.github.io/2021/12/06/Chapter1/"/>
    <id>http://wcx2001.github.io/2021/12/06/Chapter1/</id>
    <published>2021-12-06T12:38:00.000Z</published>
    <updated>2021-12-07T05:09:58.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="npuSE-Chapter-1-绪论"><a href="#npuSE-Chapter-1-绪论" class="headerlink" title="npuSE Chapter 1 绪论"></a>npuSE Chapter 1 绪论</h1><h2 id="1-1-什么是计算机视觉"><a href="#1-1-什么是计算机视觉" class="headerlink" title="1.1.什么是计算机视觉"></a>1.1.什么是计算机视觉</h2><p>计算机视觉是一门研究如何使机器“看”的科学，更进一步的说，就是指用摄影机和电脑代替人眼对目标进行识别、跟踪和测量等机器视觉，并进一步做图形处理，使电脑处理成为更适合人眼观察或传送给仪器检测的图像。<br>        作为一个科学学科，计算机视觉研究相关的理论和技术，试图建立能够从图像或者多维数据中获取‘信息’的人工智能系统。</p><h2 id="1-2-计算机视觉的主要应用"><a href="#1-2-计算机视觉的主要应用" class="headerlink" title="1.2.计算机视觉的主要应用"></a>1.2.计算机视觉的主要应用</h2><p>3D建模</p><p>地图映射</p><p>计算摄影</p><p>手写字符识别</p><p>人脸检测</p><p>物体识别</p><p>生物视觉识别</p><p>目标识别</p><p>动画3D建模</p><p>AR/VR</p><p>自动驾驶</p><p>全景拼接</p><p>机器自主导航</p><p>工业视觉</p><h2 id="1-3-计算机视觉的主要过程"><a href="#1-3-计算机视觉的主要过程" class="headerlink" title="1.3.计算机视觉的主要过程"></a>1.3.计算机视觉的主要过程</h2><p>任何一个CV系统，都离不开图像理解和图像生成。</p><p><img src="https://s4.ax1x.com/2021/12/07/o6Qu4I.png" alt></p><p>生成的过程可能各不相同，理解的过程基本相似。</p><p>【notes】</p><p>图像理解（image understanding,IU）就是对图像的语义理解。它是以图像为对象，知识为核心，研究图像中有什么目标、目标之间的相互关系、图像是什么场景以及如何应用场景的一门学科。</p><p>从计算机信息处理的角度来看，认为一个完整的图像理解系统可以分为以下的四个层次：数据层、描述层、认知层和应用层</p><hr><p>计算机视觉图像理解的主要过程：</p><p>数据层：获取图像数据，这里的图像可以是二值图、灰度图、彩色的和深度图等</p><p>描述层：提取特征或搭建学习网络结构，获得数据的表征向量</p><p>认知层：学习和推理，包括知识库的建立</p><p>应用层：根据任务需求，设计相应的分类器和学习算法。</p><h2 id="1-4-计算机视觉面临的困难"><a href="#1-4-计算机视觉面临的困难" class="headerlink" title="1.4.计算机视觉面临的困难"></a>1.4.计算机视觉面临的困难</h2><h2 id="1-5-计算机视觉发展历程"><a href="#1-5-计算机视觉发展历程" class="headerlink" title="1.5.计算机视觉发展历程"></a>1.5.计算机视觉发展历程</h2><h2 id="1-6-本课程的主要内容"><a href="#1-6-本课程的主要内容" class="headerlink" title="1.6.本课程的主要内容"></a>1.6.本课程的主要内容</h2>]]></content>
    
    
    <summary type="html">本文来自西北工业大学软件学院计算机视觉课程笔记</summary>
    
    
    
    <category term="计算机视觉" scheme="http://wcx2001.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="http://wcx2001.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="npuSE" scheme="http://wcx2001.github.io/tags/npuSE/"/>
    
  </entry>
  
  <entry>
    <title>npuSE Chapter 1：绪论</title>
    <link href="http://wcx2001.github.io/2021/12/06/Chaper1%E7%BB%AA%E8%AE%BA/"/>
    <id>http://wcx2001.github.io/2021/12/06/Chaper1%E7%BB%AA%E8%AE%BA/</id>
    <published>2021-12-06T12:38:00.000Z</published>
    <updated>2021-12-07T05:09:43.650Z</updated>
    
    <content type="html"><![CDATA[<h1 id="npuSE-Chapter-1：绪论"><a href="#npuSE-Chapter-1：绪论" class="headerlink" title="npuSE Chapter 1：绪论"></a>npuSE Chapter 1：绪论</h1><h2 id="1-1-多项式拟合的例子"><a href="#1-1-多项式拟合的例子" class="headerlink" title="1.1 多项式拟合的例子"></a>1.1 多项式拟合的例子</h2><p>假设有这样一种情况，我们通过函数产生$N$个数据点，并在其中加入服从高斯分布的随机噪声，能否仅通过这$N$​个数据点找出其隐含的分布规律，也就是他们对应的函数。这就涉及到了去寻找一条曲线去拟合这些数据点，引出了本节所讲的“多项式曲线拟合”</p><p><img src="https://s4.ax1x.com/2021/12/06/oyZ224.png" alt></p><p>假设有一个训练集，其中有$N$个观测值$x$，也就是$N$个测试样本，那这个训练集可以表示为：$x\equiv(x_1,\cdots,x_N)^{\rm T}$</p><p>同时，还有$X$对应的目标值：$t\equiv(t_1,\cdots, t_N)^{\rm T}$</p><p>我们要利用这些以上数据去建立曲线去为新的预测。</p><p>多项式函数：</p><script type="math/tex; mode=display">y(x, w)= w_0+w_1x+w_2x^2+\cdots+ w_Mx^{ M}=\sum_{j=0}^{M}w_jx^{j}\tag{1.1}</script><p>我们的任务就是去寻找适当的多项式系数$w_0$,$w_1$,$w_M$，构造多项式曲线$y(x,w)$。为了寻找最优的多项式系数，我们构造出误差函数（error function,也有的地方称为损失函数）：</p><script type="math/tex; mode=display">E(w)=\frac{1}{2}\sum_{n=1}^{N}\{y(x_n,w)-t_n\}^2\tag{1.2}</script><p>$E(w)$达到最小式，我们构造的和目标值最接近，对数据拟合的最好。当$E(w)=0$,  表明$y(x_n,w)$​经过每个点。</p><p>E(w)的几何说明：</p><p><img src="https://s4.ax1x.com/2021/12/06/oyZhrR.png" alt></p><p>选择的$w$向量使得$E(w)$​越小越好，来解决曲线拟合问题。</p><p>$E(w)$​关于$w$是二次函数，他的导数是关于$w$的一次函数，因此有唯一解，记为$w*$​</p><p>不同的$M$​值对应的$E(w)$​最小所获得的曲线</p><p><img src="https://s4.ax1x.com/2021/12/06/oyZ4q1.png" alt></p><p>从上图可以看出，不同次数的多项式函数对数据的拟合程度不同，虽然次数越高对训练集的拟合程度越好，它甚至可以穿过每一个训练集的每一个数据点，让错误函数为零，但是，这会出现过拟的现象。</p><p>“过拟”是指建立的模型对训练数据拟合的非常好，但是对测试数据的预测能力非常差。</p><p>使用100个测试数据集，使用新的噪声，然后按照均方根$E_{\rm RMS}$的方法对不同的$M$值测得的误差，这个均方差错误函数可以描述出对不同样本数和不同规模的数据的拟合程度。</p><script type="math/tex; mode=display">E_{\rm RMS} =\sqrt{\frac{2E(w^*)}{N}}\tag{1.3}</script><p><img src="https://s4.ax1x.com/2021/12/06/oyZRxJ.png" alt></p><p>值得一提的是，当训练样本数越多的时候，训练出的模型越好，如下图所示同样是次数为$9$​的多项式函数曲线，左图是使用$15$​个样本训练出来的，而右图是使用$100$​个样本训练出来的，可以明显看出，$100$​​个样本训练出来的多项式函数对样本的拟合程度更好。</p><p><img src="https://s4.ax1x.com/2021/12/06/oyZoa6.png" alt></p><p>为了避免过拟现象，我们可以采用“正则化”的方法，为误差函数末尾添加正则项：</p><script type="math/tex; mode=display">\tilde{E}(w)=\frac{1}{2}\sum_{n=1}^N\{y(x_n,w)-tn\}^2+\frac{\lambda}{2}||w||^2\tag{1.4}</script><p>其中：</p><script type="math/tex; mode=display">||w||^2=w^{\rm T}w=w_0^2+w_1^2+\cdots+w_M^2</script><p>$λ$衡量$E$和惩罚项之间的权重。 $\frac{\lambda}{2}||w||^2$是惩罚项，避免获得系数过大。</p><p>可以从式子看出，当多项式系数数量级增长时，会导致错误函数值变大，这样就能有效抑制多项式系数数量级的增长。</p><p><img src="https://s4.ax1x.com/2021/12/06/oyZIVx.png" alt></p><p>对多项式的存在的重要性有控制作用，对其数值的选择也至关重要，其控制的重要性见下图。</p><p><img src="https://s4.ax1x.com/2021/12/06/oyZTIK.png" alt></p><p>可惜的是，目前作者还没有提出如何寻找出使错误函数最小的方法，在Coursera上Andrew NG的机器学习视频中，在一开始的多元线性函数参数寻优的方法中，就提及了”梯度下降”的方法。</p><p><img src="https://s4.ax1x.com/2021/12/06/oyZbGD.png" alt></p><h2 id="1-2-概率理论"><a href="#1-2-概率理论" class="headerlink" title="1.2 概率理论"></a>1.2 概率理论</h2><p>概率基本知识：</p><p>例子：</p><p><img src="https://s4.ax1x.com/2021/12/06/oyZqRe.png" alt></p><p>两个盒子，红色和蓝色。红色盒子里有两个苹果，六个橘子。蓝色盒子里有三个苹果，一个橘子。随机选取一个盒子，从这个盒子随机选取一个水果，然后观察，放回原处。</p><p>盒子变量用$B$表示包含$r($红色$)$和$b($蓝色$)$  $ p(B=r)=4/10$ </p><p>水果变量用F表示包含$a($苹果$)$和$o($橘子$)$</p><p><img src="https://s4.ax1x.com/2021/12/06/oyZLxH.png" alt></p><p>联合概率分布：</p><script type="math/tex; mode=display">P(X=x_i,Y=y_i)=\frac{n_{ij}}{N}</script><p>边缘概率分布：</p><script type="math/tex; mode=display">P(X=x_i)=\sum_{j=1}^{L}P(X=x_i, Y=y_i)</script><p>条件概率分布：</p><script type="math/tex; mode=display">P(Y=y_i|X=x_i)=\frac{n_{ij}}{c_i}</script><p>两个主要的法则和定理：</p><p>加法法则：</p><script type="math/tex; mode=display">P(X=x_i)=\sum_{j=1}^{L}P(X=x_i,Y=y_i)</script><p>乘法法则：</p><script type="math/tex; mode=display">\begin{align}P(X=x_i,Y=y_i)&=\frac{n_{ij}}{N}\\&=\frac{n_{ij}}{c_i}\cdot\frac{c_i}{N}\\&= P(Y=y_i|X=x_i)P(X=x_i)\end{align}</script><p>贝叶斯定理：</p><script type="math/tex; mode=display">P(Y|X)=\frac{P(X|Y)P(Y)}{P(X)}</script><h3 id="1-2-1概率密度"><a href="#1-2-1概率密度" class="headerlink" title="1.2.1概率密度"></a>1.2.1概率密度</h3><p>在上面考虑的都是离散值，对于连续值而言，就要使用到“概率密度”的概念。</p><p>假设$x$​​落在区间$(x,x+δx)$​​内，且$δx\to0$​，则$x$出现的概率为$p(x)δx$，其中$p(x)$称为概率密度。如下图：</p><p><img src="https://s4.ax1x.com/2021/12/06/oyZzZt.png" alt></p><p>概率密度也可称为概率密度函数，它应该满足以下两个条件：</p><script type="math/tex; mode=display">\begin{matrix}p(x)\geq0\\[2ex]\int_{-\infty}^\infty p(x) = 1\end{matrix}</script><p>落在区间$(a,b)$的概率为：</p><script type="math/tex; mode=display">p(x\in(a, b))=\int_{a}^b p(x){\rm d}x</script><p>概率密度在向量上的应用：</p><p>概率密度的概念同样可以使用在向量情况。假设我们有若干个变量$x_1, \cdots ,x_D$，可以定义一个联合概率密度$p(x)=p(x_1,\cdots,xD)$​，其同样要满足以下两个条件：</p><script type="math/tex; mode=display">\begin{matrix}p(x)\geq0\\[2ex]\int_{-\infty}^\infty p(x) = 1\end{matrix}</script><p>在连续值的情况下，加法规则和乘法规则变换成如下形式：</p><script type="math/tex; mode=display">\begin{matrix}p(x)=\int p(x, y){\rm d}y\\[2ex]p(x, y)= p(y|x)\cdot p(x)\end{matrix}</script><h3 id="1-2-2-期望和方差"><a href="#1-2-2-期望和方差" class="headerlink" title="1.2.2 期望和方差"></a>1.2.2 期望和方差</h3><h4 id="1-期望-Expectation-："><a href="#1-期望-Expectation-：" class="headerlink" title="1. 期望(Expectation)："></a>1. 期望(Expectation)：</h4><p>描述平均取值大小</p><p>对于服从$p(x)$概率分布的的函数$f(x)$，其数学期望定义如下：</p><p>若$f(x)$是离散的：</p><script type="math/tex; mode=display">E[f]=\sum_{x}p(x)f(x)</script><p>若$f(x)$是连续的：</p><script type="math/tex; mode=display">E[f]=\int p(x) f(x){\rm d}x</script><p>对于有多个变量的函数，其数学期望可参照$E_x[f(x,y)]$​​,这种形式（假设有两个变量），这表明$f(x,y)$​按照变量$x$​的概率分布$p(x)$​,然后求函数$f(x,y)$的平均值，其数学期望的结果是关于变量y的函数,对于这种情况，我们可以考虑使用”条件数学期望”，其定义如下：</p><script type="math/tex; mode=display">E_x[f|y]=\sum_{x}p(x|y)f(x)</script><h4 id="2-方差-Variance-："><a href="#2-方差-Variance-：" class="headerlink" title="2. 方差(Variance)："></a>2. 方差(Variance)：</h4><p>变量与均值的偏离程度。</p><p>定义如下：</p><script type="math/tex; mode=display">{\rm var}[f]=E[(f(x)-E[f(x)])^2]</script><p>或者展开是：</p><script type="math/tex; mode=display">{\rm var}[f]=E[f(x)^2]-E[f(x)]^2</script><h3 id="1-2-3-贝叶斯概率"><a href="#1-2-3-贝叶斯概率" class="headerlink" title="1.2.3 贝叶斯概率"></a>1.2.3 贝叶斯概率</h3><p>贝叶斯学派（Bayesian）和频率学派(Frequentist)在对待概率（或是不确定度）上的区别，从根本上说，他们是出发的理念不同，频率学派认为参数皆有定值，只是我们还没有观察到，所以可以通过做大量的实验去统计其潜在的规律，得出参数值。贝叶斯学派则认为参数是随机值，因为我们没有观察到，所以参数和随机值没什么区别，参数是可以有分布的。但是这两个学派中也有许多想通的地方。</p><p>所以这小节一开始就提出了有许多事情是无法通过大量实验去预测结果的，比如，月亮是否在绕日轨道上，北极冰盖是否在本世纪末消失。所以作者建议我们用贝叶斯的观点去看待概率，其提供了对不确定度的量化。</p><p>贝叶斯学派经常关注的是后验概率，将先验概率转化为后验概率。</p><p>现在我们结合贝叶斯定理和在1.1节中提到的多项式拟合解释一下。贝叶斯定理定义：</p><script type="math/tex; mode=display">p(w|D)=\frac{p(D|w)p(w)}{p(D)}</script><p>在多项式拟合中，我们的目的是寻找模型参数，在观察数据之前，先假设的概率分布为$p(w)$，$p(w)$就是所谓的先验概率。数据的影响可表示为条件概率$p(D|W)$，其表示不同参数向量导致不同的数据的可能性，也被称为似然函数，它的准确形式表达会在之后的章节详细介绍。$p(W|D)$被称为后验概率。其意义就是在观察$D=\{t_1,\cdots, tn\}$后，对参数向量不确定度的评价。因此，可以看出，后验概率正比于似然函数乘与先验概率：</p><script type="math/tex; mode=display">{\rm posterior }∝{\rm likelihood}\times{\rm prior}</script><p>特别地，在频率学派中，通常关注于找到最大似然函数（maximum likelihood），其中$w$将$p(w|D)$​的值最大化。似然函数的负对数是错误函数（error function），最大化似然函数等价于最小化错误函数。</p><h3 id="1-2-4-高斯分布"><a href="#1-2-4-高斯分布" class="headerlink" title="1.2.4 高斯分布"></a>1.2.4 高斯分布</h3><p>本小节主要是讲高斯分布及其应用，其也称为正态分布。定义如下：</p><script type="math/tex; mode=display">N(x|\mu,\sigma^2)=\frac{1}{(2\pi \sigma^2)^{\frac{1}{2}}}\exp\{-\frac{1}{2\sigma^2}(x-\mu)^2\}</script><p>其中，$\mu$是平均值，$\sigma^2$是方差，$\sigma$称为标准差</p><script type="math/tex; mode=display">E[x]=\int_{-\infty}^{\infty}N(x|\mu,\sigma^2)x{\rm d}x=\mu</script><script type="math/tex; mode=display">E[x]=\int_{-\infty}^{\infty}N(x|\mu,\sigma^2)x^2{\rm d}x=\mu^2+\sigma^2</script><script type="math/tex; mode=display">{\rm var}[x]=E[x^2]-E[x]^2=\sigma^2</script><p>下图是单变量的高斯分布图：</p><p><img src="https://s4.ax1x.com/2021/12/06/oyZjsA.png" alt></p><p>高斯分布应满足以下两个条件：</p><script type="math/tex; mode=display">N(x|\mu, \sigma^2)>0</script><script type="math/tex; mode=display">\int_{-\infty}^{\infty} N(x|\mu, \sigma^2){\rm d}x=1</script><p>接下来，我们讨论如何找到一个给定数据集的高斯分布。</p><p>给定一个数据集：</p><script type="math/tex; mode=display">x=(x_1,\cdots,x_n)^{\rm T}</script><p>如下图所示：</p><p><img src="https://s4.ax1x.com/2021/12/06/oyZvqI.png" alt></p><p>假设产生这些数据点的是一个均值为u，方差为σ2的高斯分布，只是这两个参数的具体值还不知道罢了。</p><p>因此，似然函数（likelihood function）如下：</p><script type="math/tex; mode=display">p(X|\mu,\sigma^2)=\Pi_{n=1}^N N(x_n|\mu,\sigma ^2)</script><p>它的直观意义是通过不断调整$u$、$σ^2$参数，让各个数据点的高斯值相乘，使得$p(x|u,σ^2)$最大，那么对应的$u$、$σ^2$就是所要求的高斯分布的参数。</p><p>为了计算和分析的方便，可以将似然函数转换成（自然）对数形式，因为（自然）对数是单调递增的，其取最大值时，似然函数也会取到最大值。（自然）对数形式如下：</p><script type="math/tex; mode=display">\ln p(X|\mu,\sigma^2)=-\frac{1}{2\sigma^2}\sum_{n=1}^N(x_n-\mu)^2-\frac{N}{2}\ln\sigma^2-\frac{N}{2}\ln(2\pi)</script><p>通过以下式子可以找到最优的$u$、$σ^2$​：</p><script type="math/tex; mode=display">\mu_{\rm ML}=\frac{1}{N}\sum_{n=1}^{N}x_n</script><p>$\ln$对$u$求导等于$0$</p><script type="math/tex; mode=display">\sigma^2_{\rm ML}=\frac{1}{N}\sum_{n=1}^{N}(x_n-\mu_{\rm ML})^2</script><p>$\ln$对$σ^2$求导等于$0$</p><p>但是，使用最大似然函数求高斯分布的方法存在一定限制，会产生”偏离（bias）”现象。具体的解释在以后的章节……（均值是正确的，但是方差存在问题）</p><p>回顾曲线拟合：</p><p>在第一章1.1中时，我们从错误函数最小化去求多项式曲线模型中的参数，在这个小节中，我们从概率的角度去解决这个问题。多项式曲线模型和错误函数如下：</p><script type="math/tex; mode=display">E(w)=\frac{1}{2}\sum_{n=1}^{N}\{y(x_n,w)-t_n\}^2\tag{1.2}</script><p>首先，假设对于给定的训练值，对应的目标值服从高斯分布，那么</p><script type="math/tex; mode=display">p(t|x,w,\beta)=N(t|y(x,w), \beta^{-1})</script><p>其中$β^{-1}=σ^2$，这个式子表示给定$x$时得到$t$的概率，可以用下图表示：</p><p><img src="https://s4.ax1x.com/2021/12/06/oyeSdP.png" alt></p><p>因此，我们可以构造似然函数用训练数据去找出最优的参数$w$和$β$，似然函数如下：</p><script type="math/tex; mode=display">p(t|x,w,\beta)=\Pi_{n=1}^N N(t_n|y(x_n, w), \beta^{-1})</script><p>转化为对数形式：</p><script type="math/tex; mode=display">\ln p(t|x,w,\beta)=-\frac{\beta}{2}\sum_{n=1}^{N}\{y(x_n,w)-t_n\}^2+\frac{N}{2}\ln\beta-\frac{N}{2}\ln(2\pi)</script><p>设：$A=\ln p(t|x,w,\beta)$，$B =-\frac{\beta}{2}\sum_{n=1}^{N}\{y(x_n,w)-t_n\}^2$，$C =\frac{N}{2}\ln\beta-\frac{N}{2}\ln(2\pi)$</p><p>$A$​​是$w$​和$β$​的函数，先将$β$​固定，那么寻求$A$​的最大值，只依赖于$w$​，可以将$C$​去掉，将$A$最大化相当于将$B$最小化，最后将系数$β/2$ 换成$1/2$。可以看出，寻找最优的$WML$时，最大化似然函数等价于最小化错误函数，对于$β$，可以使用下列式子得到最优值。</p><script type="math/tex; mode=display">\frac{1}{\beta_{\rm ML}}=\frac{1}{N}\sum_{n=1}^{N}\{y(x_n, w_{\rm ML})-t_n\}^2</script><h2 id="1-3-模型选择"><a href="#1-3-模型选择" class="headerlink" title="1.3 模型选择"></a>1.3 模型选择</h2><p>在之前提到的多项式曲线拟合中就可以看出，多项式的最高次数影响着所建模型的对测试数据（testing data）性能，项数小，拟合效果不好，项数过大，容易出现过拟合现象（over-fitting）。这就涉及到了一个模型选择的问题。</p><p>如果我们有大量的数据，可以用来建立多个模型，然后再使用同一独立的数据集去评价各个模型的性能，选取性能最好的那个模型及其参数。如果使用小数据多次迭代进行模型比较选择，容易出现过拟的现象。但是，在许多情况下，提供给建模的训练和测试数据都十分有限，又想建个好模型，怎么办呢？</p><p>解决这个窘境的办法之一就是使用交叉验证（cross-validation），将可用的数据集分成$S$份（一般是分成相同大小），用$S-1$份去训练各个模型，用剩下的一份去测试模型，如此重复$S$次，将各个模型的性能平均，选取平均性能最好的模型和参数。图解如下：</p><p><img src="https://s4.ax1x.com/2021/12/06/oyepIf.png" alt></p><p>交叉验证的主要缺点就是S决定了建模比较过程中的迭代次数，如果S过大的话，而且单个模型中还会有多个复杂的模型参数，这会造成大量的计算花费。因此，理想的情况是仅使用训练数据（training data），对多个模型和参数的选择比较在一次训练过程（training run）完成。所以我们要找到一种仅依赖于训练数据并且不会引起过拟的性能评估方法。</p><p>在历史上，其中之一就是the Akaike information criterion, or AIC (Akaike, 1974)，通过使下面的式子达到最大来选择模型：</p><h2 id="1-4-维数灾难"><a href="#1-4-维数灾难" class="headerlink" title="1.4 维数灾难"></a>1.4 维数灾难</h2><p>维数灾难的意思是模型复杂度随着空间维数的增加而成指数增长。这一节举了两个例子来说明这个问题。一个是石油、水、天然气中的成分的例子，另一个仍然是curve fitting，但扩展到高维空间，在高维空间我们的模型会变成1.74这个样子，复杂度陡增:</p><script type="math/tex; mode=display">y(x,w)=w_0+\sum_{i=1}^{D}w_i x_i+\sum_{i=1}^{D}\sum_{j=1}^{D}w_{ij}x_ix_j+\sum_{i=1}^{D}\sum_{j=1}^{D}\sum_{k=1}^{D}w_{ij}x_ix_jx_k</script><p>其中，$D$​为变量个数。</p><p>我们前面的多项式拟合问题中只有一个输入变量，在实际的问题中，可能就有多个变量，分布在高维空间中。</p><p><img src="https://s4.ax1x.com/2021/12/06/oyePJS.png" alt></p><p>三个不同的状态：</p><p>红色表同质</p><p>绿色表环形</p><p>蓝色表层状</p><p>求$x$属于哪一类</p><p><img src="https://s4.ax1x.com/2021/12/06/oyeiRg.png" alt></p><p>现在要对一个点$(x_6,x_7)$​（那个黑叉）进行分类。</p><p>我们一般的做法是将其分为多个大小相同的 cell，黑叉所在的 cell 里最多的类别作为黑叉的类别。比如上面所示，$x$​应该被分为红色那个类别。</p><p>这就引发了一个问题：现在我们的输入是$(x_6,x_7)$,是二维的，如果我们输入时三维的呢？</p><p>我们需要把训练空间需要时三维的。我们在二维的情况下有$42$个cells，三维的时候就需要分为$43$cells。同理$n$维的话，需要$4n$​个cell。如下图，可见这是随着维数呈指数增长的。</p><p><img src="https://s4.ax1x.com/2021/12/06/oyeCi8.png" alt></p><p>再例如我们有一个$D$维的球体，假设体积$V_D(r) = K_Dr^D$, $r$代表半径，其中$K_D$与 $D$ 有关。</p><p>我们需要求 $r=1$ 与 $r=1-ε$ 之间的比例</p><script type="math/tex; mode=display">\frac{V_D(1)-V_D(1-ε)}{V_D(1)}=1-(1-ε)^D</script><p><img src="https://s4.ax1x.com/2021/12/06/oyeFzQ.png" alt></p><p>最后提到维数灾难并不能阻止我们解决高维空间的问题，原因有二</p><ol><li><p>真实的数据通常在一个有限的、较低维度的空间内，尤其是目标变量发生重要改变的方向非常有限；</p></li><li><p>真实数据往往有一定的平稳性：通常来讲输入变量的细小变化也只能引起目标变量的细小变化，所以我们可以利用插值方法预测目标变量。</p></li></ol><h2 id="1-5-决策理论"><a href="#1-5-决策理论" class="headerlink" title="1.5 决策理论"></a>1.5 决策理论</h2><p> 概率论、决策理论、信息论是机器学习的三个理论基础。概率论说的已经很多了，决策理论提及的比较少。简单说就是当我们已经有了概率结果$p(t)$后，如何做出判断。如果$p(t)=0.99$，这个判断相对容易一点；如果$p(t)=0.6$，我们会觉得不太可信。</p><p>例如：</p><p>癌症的例子：</p><p>一个患者 做了 $X$ 光检查，结果用 $x$ 表示。</p><p>需要判断他是一个癌症患者或者是非癌症患者，用$C$表示。$C=0$标示癌症，$C=1$标示正常$(C_0，C_1)$ 。推测问题包括取得$p(x,ck)$,它给了我们对这问题最完整的概率描述，这是推理阶段，最后我们还是必须决定是否给这个患者治病，就是决定阶段。</p><p>现在我们关心的就是，我们获得了一张 $x$ 光照片，怎么放入癌症和正常的这两个类别中， 也就是 $p(C|x)$。</p><p>使用贝叶斯法则如下：</p><script type="math/tex; mode=display">p(C|x)=\frac{p(C)p(x|C)}{p(x)}</script><p>$P(C_1)$代表人群中癌症患者的比例（就是随机一个人在做 $X$ 光之前，是癌症患者的概率）也就是先验概率。我们的直觉告诉我们，我们的直觉告诉我们要选择一个后验概率较大的类，如果我们不想把 $x$​​ 放到错误的类别中。下面就要证明这种直觉是正确的。</p><h3 id="1-5-1-最小化错分概率"><a href="#1-5-1-最小化错分概率" class="headerlink" title="1.5.1 最小化错分概率"></a>1.5.1 最小化错分概率</h3><p>我们需要一个规则，对输入的每个$x$，将其标记类别。假设这个规则将$x$分配到$K$个区域，$R_k$ 叫做决策区域，$R_k$中的 $x$ 都将分配到 $C_k$ 中。在这些决策区域之间的部分叫做决策边界。注意：不是所有的的决策区域都是连续的。</p><script type="math/tex; mode=display">\begin{align}p({\rm mistake}) &= p(x\in R_1,C_2)+p(x\in R_2,C_1)\\[2ex]&= \int_{R_1}p(x,C_2){\rm d}x+\int_{R_2}p(x, C_1){\rm d}x\end{align}</script><p>对于一个给定的$x$：</p><script type="math/tex; mode=display">\begin{align}p({\rm correct}) &= \sum_{k=1}^{K}p(x\in R_k,C_k)\\[2ex]&= \sum_{k=1}^{K}\int_{R_k}p(x,C_k){\rm d}x\end{align}</script><p>要使得$p({\rm correct})$最大 （$p({\rm mistake})$最小），就需要选择一个 $C_k$使得 $p(x,C_k)$最大， 而 $p(x,C_k)= p(C_k|x)p(x)$,而对于所有的 $p(x,C_k)$，$p(x)$都是一样的，所以只需要使得 $p(C_k|x)$最大，而他就是后验概率。这就解释了我们为什么使用最大后验概率。</p><p>最小化误分类比例可以通过$P(x,C_1)$和$P(x,C_2)$来判断就可以了。我们可以看下图，这图很简单，假设$P(x,C_1)$和$P(x,C_2)$有着这样的两条曲线，绿色、蓝色、红色所处的概率关系各不相同。$R_1$，$R_2$称作决策区域，其分界面是决策边界。如果将分界面设置在$x-$处，红色就会是误分类的点。向左移动$x-$到$x_0$处，红色区域消失，完全按照$P(x,C_1)$和$P(x,C_2)$的大小来分类，使误分类率最低。</p><p><img src="https://s4.ax1x.com/2021/12/06/oyeAMj.png" alt></p><h3 id="1-5-2-最小化期望损失"><a href="#1-5-2-最小化期望损失" class="headerlink" title="1.5.2 最小化期望损失"></a>1.5.2 最小化期望损失</h3><p>癌症病人没病———&gt;有病</p><p>癌症病人有病———&gt;没病 事大了</p><p>代价函数来衡量损失。引入损失矩阵。</p><p><img src="https://s4.ax1x.com/2021/12/06/oyeEss.png" alt></p><p>我们的目标就是使得$\sum_k L_{kj}p(x,c_k)$​最小。</p><p>例子：</p><p>$p({\rm 癌症}|x) = 0.2$   $p({\rm 正常}|x) =0.7$ </p><p>将$x$​分类到正常：</p><script type="math/tex; mode=display">{\rm 损失函数值} = L_{\rm 癌症\,\, 正常}p({\rm 癌症}|x) + L_{\rm 正常 \,\,正常}p({\rm 正常}|x)= 0.2*1000+0=200</script><p>将$x$分类到癌症：</p><script type="math/tex; mode=display">{\rm 损失函数值} = L_{\rm 正常\,\, 癌症}p({\rm 正常}|x) + L_{\rm 癌症\,\, 癌症}p({\rm 癌症}|x)= 0.7*1=0.7</script><h3 id="1-5-3-拒绝判断"><a href="#1-5-3-拒绝判断" class="headerlink" title="1.5.3 拒绝判断"></a>1.5.3 拒绝判断</h3><p><img src="https://s4.ax1x.com/2021/12/06/oyeeZq.png" alt></p><h3 id="1-5-4-推论和决策"><a href="#1-5-4-推论和决策" class="headerlink" title="1.5.4 推论和决策"></a>1.5.4 推论和决策</h3><p>分类问题俩阶段：</p><p>推论阶段，得到$p(Ck|x)$(后验概率),</p><p>决策阶段，根据后验概率做最优的分配</p><p>另一种办法是判别函数：直接由一个函数将$x$映射到决策。</p><p>解决决策问题的方法</p><p>第一种：</p><p>先计算$p(x|Ck)$，通过贝叶斯公式得到后验概率</p><script type="math/tex; mode=display">P(C_k|x)=\frac{p(x|C_k)p(C_k)}{p(x)}</script><p>而，</p><script type="math/tex; mode=display">p(x)=\sum p(x|C_k)p(C_k)</script><p>使用决策论来决定如何分类。</p><p>第二种：</p><p>先得到后验概率$p(C_k|x)$,然后按照决策论的方法分配数据。</p><p>第三种：</p><p>找到一个函数将x直接映射到类别，这个函数叫做判别函数。在这里概率没有起到作用。</p><p>这三种方法的优缺点。</p><p>第一种方法：</p><p>需要$x$和$C_k$的联合分布，要找到$p(x|C_k)$需要很多的训练数据。</p><p>第二种方法：</p><p>如果我们只想做一个分类，计算$p(x,C_k)$是非常消耗计算资源并且需要大量的数据的。实际上我们只需要一个后验概率而已。</p><p>第三种方法：</p><p>直接将$x$映射到类别，连后验概率都省掉而来。</p><p><img src="https://s4.ax1x.com/2021/12/06/oyeVLn.png" alt></p><p>后验概率还是非常有用的：</p><p>比如：</p><p>减小风险：</p><p>使用损失矩阵进行修正，以减小我们的分类错误的风险，得到不同的决策。第三种方法需重新分析数据建模</p><p>拒绝决策：</p><p>有后验概率我们可以使用拒绝域，但是如果是第三种方法，就做不到。</p><p>补偿先验类别：</p><p>如果癌症患者的比例是$1:1000$，$99.9\%$。假设我们使用modified的data得到了后验概率分布$p(C_k|x)$. 我们可以先使用我们人工制造的数据进行分类， 然后再乘以实际中对应的癌症与正常的比例得到新的后验概率。</p><p>结合不同的模型：</p><p>分成子问题分别求解，使用$x_r$ , $X_b$​ 表示测试癌症的x-ray和验血。</p><p>后验概率:$P(C_k|x_I,x_B ) = P(x_I ,x_B |C_k) P(C_k) / P(x_I ,x_B )$​</p><script type="math/tex; mode=display">\begin{align}p(C_k|x_1, x_B) & ∝ p(x_1,x_B|C_k)p(C_K)\\[2ex]& ∝ p(x_1|C_k)p(x_B|C_k)p(C_K)\\[2ex]& ∝ \frac{p(C_k|x_1)p(C_k|x_B)}{p(C_k)}\end{align}</script><h3 id="1-5-5-回归问题中的损失函数"><a href="#1-5-5-回归问题中的损失函数" class="headerlink" title="1.5.5 回归问题中的损失函数"></a>1.5.5 回归问题中的损失函数</h3><p>损失函数：</p><script type="math/tex; mode=display">E[L]=\iint L(t,y(x))p(x,t){\rm d}x{\rm d}t</script><script type="math/tex; mode=display">E[L]=\iint(t-y(x))^2 p(x, t){\rm d}x{\rm d}t</script><p>我们目标就是取一个$y(x)$使得$E[L]$​最小</p><script type="math/tex; mode=display">\frac{\partial  E[L]}{\partial y(x)}=2\int\{y(t)-t\}p(x,t){\rm d}t=0</script><script type="math/tex; mode=display">\int y(x)p(x,t ){\rm d}t = \int tp(x,t){\rm d}t\\</script><script type="math/tex; mode=display">y(x)\int p(x,t){\rm d}t=y(x)p(x)=\int tp(x,t){\rm d}t</script><script type="math/tex; mode=display">y(x)=\frac{\int tp(x,t){\rm d}t}{p(x)}=\int tp(t|x){\rm d}t=E_t[t|x]</script><p><img src="https://s4.ax1x.com/2021/12/06/oyemd0.png" alt></p><p>解决回归问题：</p><p>第一：先找到$p(x,t)$然后找到$p(t|x)$,最后使用</p><script type="math/tex; mode=display">y(t)=\frac{\int tp(x,t){\rm d}t}{p(x)}=\int tp(t|x){\rm d}t=E_t[t|x]</script><p>得到$y(x)$</p><p>第二：先找到$p(t|x)$ 再使用</p><script type="math/tex; mode=display">y(x)=\frac{\int tp(x,t){\rm d}t}{p(x)}=\int tp(t|x){\rm d}t=E_t[t|x]</script><p>得到$y(x)$</p><p>第三：直接找到$y(x)$</p><p>优缺点与分类问题一样。</p><h2 id="1-6-信息理论"><a href="#1-6-信息理论" class="headerlink" title="1.6 信息理论"></a>1.6 信息理论</h2><p>信息量：变量的“惊讶程度”</p><p>变量的信息量：</p><p>如果 $x,y$ 独立的话，就是他们的和, $h(x, y) = h(x) + h(y)$ 。还有$p(x, y) = p(x)p(y)$. 我们可以断定 $h(x)$可以使用 $\log$ 来作为那个递增函数：</p><p>因为 $\log(p(x)p(y)) =\log(p(x))+\log(p(y))$​，因为 $p(x)$​是在$(0,1)$​的所以 $h(x) = -\log[p(x)]$​才能保证 $h(x)$​大于$0$.</p><p>如果我们选择 $\log2$的话，$h(x)$的单位叫做 bit。</p><h3 id="1-6-1-熵"><a href="#1-6-1-熵" class="headerlink" title="1.6.1 熵"></a>1.6.1 熵</h3><p>平均信息量（熵 entropy） ：</p><p>变量$x$的平均信息量为：</p><script type="math/tex; mode=display">H[x]=\sum p(x)h(x)=-\sum_{x}p(x)\log_2 p(x)</script><p>熵的意义：</p><p>例如：一个变量$x$有$ 8$种状态，每一种状态的概率都是 $\frac{1}{8}$.那么$x$的熵为：</p><script type="math/tex; mode=display">-\sum_{1}^8\frac{1}{8}\log_2\frac{1}{8}=3</script><p>再例如：如果$x$的$8 $种状态为$\{a,b,c,d,e,f,g,h\}$的概率分布为$(\frac{1}{2},\frac{1}{4},\frac{1}{8},\frac{1}{16},\frac{1}{64},\frac{1}{64},\frac{1}{64},\frac{1}{64})$，那么$x$的熵为：</p><script type="math/tex; mode=display">H[x]=-\frac{1}{2}\log_2\frac{1}{2}-\frac{1}{4}\log_2\frac{1}{4}-\frac{1}{8}\log_2\frac{1}{8}-\frac{1}{16}\log_2\frac{1}{16}-\frac{4}{64}\log_2\frac{1}{64}=2{\rm bits}</script><p>结论：非均匀分布的比均匀分布的熵更小。熵与$x$分布的杂乱程度有关。越杂乱越小。</p><h3 id="1-6-2-熵与编码"><a href="#1-6-2-熵与编码" class="headerlink" title="1.6.2 熵与编码"></a>1.6.2 熵与编码</h3><p>对于上面的例子，我们可以对每一种状态$\{a,b,c,d,e,f,g,h\}$​​编码<br>$0, 10, 110, 1110, 111100, 111101, 111110, 111111$.编码的平均长度如下。</p><script type="math/tex; mode=display">{\rm average \,\,code\,\, length} = \frac{1}{2}\times1+\frac{1}{4}\times 2+\frac{1}{8}\times3+\frac{1}{16}\times 4+4\times\frac{1}{64}\times6 = 2{\rm bits}</script><p>这与熵相等的。</p><p>使用自然对数定义熵（ natural logarithms）。</p><p>平衡热力学中的材料来分析， 也可以把它当成衡量杂乱的标准。</p><p>考虑有$N$个相同的物体，要放到一组罐子中，在$i^{\rm th}$个罐子中有$n_i$个物体。<br>这就有$N!$种分发。如果我们不考虑罐子里的物体的排列，那么有：</p><script type="math/tex; mode=display">w=\frac{N!}{\Pi^i n_i!}</script><p>熵的定义就是：</p><script type="math/tex; mode=display">H=\frac{1}{N}\ln W=\frac{1}{N}\ln N!-\frac{1}{N}\sum_i\ln n_i!</script><p>当$N$趋近无穷大时候，$\frac{n_i}{N}$是固定的。并且$\ln N! = N\ln N - N$ ,就得到$H$如下：</p><script type="math/tex; mode=display">H=-\lim_{N\to\infty}\sum(\frac{n_i}{N})\ln(\frac{n_i}{N})=-\sum p_i\ln p_i</script><p><img src="https://s4.ax1x.com/2021/12/06/oyeKiT.png" alt></p><h3 id="1-6-3-差熵"><a href="#1-6-3-差熵" class="headerlink" title="1.6.3 差熵"></a>1.6.3 差熵</h3><p>中值定理：</p><script type="math/tex; mode=display">\int_{i\Delta}^{(i+1)\Delta}p(x){\rm d}x=p(x_i)\Delta</script><p>套用离散分布的公式：</p><script type="math/tex; mode=display">H=-\lim_{N\to\infty}\sum_i(\frac{n_i}{N})\ln(\frac{n_i}{N})=-\sum_ip_i\ln p_i</script><p>使用：$\sum_i p(x_i)\Delta=1$得到：</p><script type="math/tex; mode=display">\begin{align}H_\Delta&=-\sum_i p(x_i)\Delta\ln(p(x_i)\Delta)\\[2ex]&=-\sum_ip(x_i)\Delta\ln p(x_i)-\ln\Delta\end{align}</script><p>当$Δ$趋近无穷的时候：右边第一项就等于</p><script type="math/tex; mode=display">\lim_{\Delta\to 0} \left[ \sum_ip(x_i)\Delta\ln p(x_i) \right]=-\int p(x)\ln p(x){\rm d}x</script><p>右边这项就叫做差熵 （differential entropy） 。离散和连续形式的熵相差了一个$\lnΔ(Δ\to∞)$ 。</p><p>结论：要精确地确定一个连续的变量需要大量的数据。</p><p>连续分布的最大熵</p><p>离散分布时候最大熵？？？？？</p><script type="math/tex; mode=display">\int_{-\infty}^\infty p(x){\rm d}x= 1</script><script type="math/tex; mode=display">\int_{-\infty}^\infty xp(x){\rm d}x= \mu</script><script type="math/tex; mode=display">\int_{-\infty}^\infty (x-\mu)^2p(x){\rm d}x= \sigma^2</script><p>使用拉格朗日法，</p><p>问题转变为：在上面的约束条件下，当$p(x)$为什么分布的时候，下面式子的最小。</p><script type="math/tex; mode=display">-\int_{-\infty} ^\infty p(x)\ln p(x){\rm d}x+\lambda_1\left(\int_{-\infty}^{\infty}p(x){\rm d} x-1\right)+\lambda_2\left(\int_{-\infty}^{\infty}xp(x){\rm d}x-\mu\right)+\lambda_3\left(\int_{-\infty}^\infty(x-\mu)^2p(x){\rm d}x-\sigma^2\right)</script><p>最终计算结果是高斯分布：$N(\mu,σ^2)$</p><p>在高斯分布的情况下差熵：</p><script type="math/tex; mode=display">H[x]=\frac{1}{2}(1+\ln2^\pi\sigma^2)</script><p>从这个式子我们也可以看出随着$σ^2$的增大，高斯分布变得更扁，熵变得越大。</p><h3 id="1-6-4-条件熵："><a href="#1-6-4-条件熵：" class="headerlink" title="1.6.4 条件熵："></a>1.6.4 条件熵：</h3><p>当我们有一个联合分布$p(x,y)$,如果我么 现在知道了$x$的值，需要额外的信息知道对应的$y$的值，这个额外的信息就是$-\ln p(y|x)$.平均额外的信息就表示为：</p><script type="math/tex; mode=display">H[y|x]=-\iint p(x,y)\ln p(y|x){\rm d}x{\rm d}y</script><p>这就叫做条件熵（conditional entropy）</p><p>容易得到$H[x,y] = H[y|x]+H[x]$​</p><p>结论： 需要用来描述$x$和$y$的信息是用来描述$x$的信息加上在$x$的条件下用来描述$y$​的额外信息。</p><h3 id="1-6-5-相对熵：（KL-散度）"><a href="#1-6-5-相对熵：（KL-散度）" class="headerlink" title="1.6.5 相对熵：（KL 散度）"></a>1.6.5 相对熵：（KL 散度）</h3><p>一个不知道的分布$p(x)$,我们使用$q(x)$取近似拟合它。假如我们要把$x$发送到一个接收器，我们使用$q(x)$来设计编码方案，得到的就不是最佳方案，会比最佳方案多发送一些信息。这个信息就是</p><script type="math/tex; mode=display">KL(p||q)=-\int p(x)\ln q(x){\rm d}x-\left(-\int p(x)\ln p(x)\right)=-\int p(x)\ln\frac{q(x)}{p(x)}{\rm d}x</script><p>这就叫做相对熵，或者KL 散度 。KL散度不是对称的$KL(p||q)!=KL(q||p)$</p><p>KL-divergence，俗称KL距离，常用来衡量两个概率分布的距离。</p><p>根据shannon的信息论，给定一个字符集的概率分布，我们可以设计一种编码，使得表示该字符集组成的字符串平均需要的比特数最少。假设这个字符集是$X$​，对$x∈X$，其出现概率为$P(x)$，那么其最优编码平均需要的比特数等于这个字符集的熵：$H(X)=∑x∈XP(x)\log[1/P(x)]$</p><p>在同样的字符集上，假设存在另一个概率分布$Q(X)$。如果用概率分布$P(X)$的最优编码（即字符$x$的编码长度等于$\log\left[1/P(x)\right]$） ，来为符合分布$Q(X)$的字符编码，那么表示这些字符就会比理想情况多用一些比特数。KL-divergence就是用来衡量这种情况下平均每个字符多用的比特数，因此可以用来衡量两个分布的距离。即：<br>$DKL(Q||P)= ∑ x ∈ XQ(x)[\log(1/P(x))] - ∑ x ∈ XQ(x)[\log[1/Q(x)]]= ∑ x ∈<br>XQ(x)\log[Q(x)/P(x)]$由于$-\log(u)$是凸函数，因此有下面的不等式<br>$DKL(Q||P) = -∑x∈XQ(x)\log[P(x)/Q(x)] = E[-\log[P(x)/Q(x)]] ≥ -\log E[P(x)/Q(x)] =-\log∑x∈XQ(x)P(x)/Q(x) = 0$</p><p>即KL-divergence始终是大于等于$0$的。当且仅当两分布相同时，KL-散度等于$0$</p><p>下面证明：$KL(p||q)&gt;=0$ 只有$p(x) = q(x)$的时候等于$0$。这也可以理解为只有在$p$的情况下式最优的，使用最短的平均编码。其他情况下都不是最优的。</p><p>引入凸函数：</p><p><img src="https://s4.ax1x.com/2021/12/06/oyeMJU.png" alt></p><p>凸函数满足</p><script type="math/tex; mode=display">f(\lambda a+(1-\lambda)b)\leq \lambda f(a)+(1-\lambda)f(b)</script><p>叫做凸函数。</p><p>满足</p><script type="math/tex; mode=display">f(\lambda a+(1-\lambda)b)< \lambda f(a)+(1-\lambda)f(b)</script><p>叫做严格凸函数。</p><p>我们可以证明：</p><script type="math/tex; mode=display">f(\sum_{i=1}^M\lambda_i x_i)\leq\sum_{i=1}^{M} f(\lambda_ix_i)</script><p>满足：$\sum_{i=1}^M\lambda_i=1$，并且$f(x)$是凸函数</p><p>我们可以把λi看做是$p(x_i)$ ,概率分布，满足： $\sum_{i=1}^{M}p(x_i)=1$</p><p>可以得到$f(E[x])\leq E[f(x)]$</p><p>即，$f(\int xp(x)){\rm d}x\leq \int f(x)p(x){\rm d}x$</p><p>把上式子应用于下面的$KL(p||q)$.</p><script type="math/tex; mode=display">KL(p||q)=-\int p(x)\ln\frac{q(x)}{p(x)}{\rm d}x=\int p(x)\left[-\ln\frac{q(x)}{p(x)}\right]{\rm d}x</script><p>而$-\ln(x)$是凸函数。就有：</p><script type="math/tex; mode=display">-\ln\left(\int p(x)\frac{q(x)}{p(x)}\right){\rm d}x\leq\int\ln p(x)\left[-\ln \frac{q(x)}{p(x)}\right]{\rm d}x</script><script type="math/tex; mode=display">-\ln\left(\int p(x)\frac{q(x)}{p(x)}\right){\rm d}x=-\ln\int p(x){\rm d}x=-\ln 1=0</script><p>所以：</p><script type="math/tex; mode=display">KL(p||q)=-\int p(x)\ln \frac{q(x)}{p(x)}{\rm d}x=\int p(x)\left[-\ln\frac{q(x)}{p(x)}\right]{\rm d}x \geq 0</script><p>这就可以使用KL divergence 作为一个两个分布不同程度的度量。</p><p>如果我们使用不同的分布， 那么我们就会得到一个不那么有效的编码， 这就将一些额外信息发送了，这个平均的额外信息就等于KL divergence。</p><p>最小化$KL(p||q)$与最大似然函数的等价。</p><p>假设我们通过调整参数 $θ$​​，想得到一个分布的近似的分布。我们可以使$p(x)$​​,$q(x|θ)$​​之间的$KL(p||q)$最小。但是我们不知道$p$，但是这个不影响我们的计算（下面会看到） 。</p><p>假设我们有N个观察点。</p><script type="math/tex; mode=display">\begin{align}KL(p||q)&=\sum_{n=1}^N\{-\ln q(x_n|\theta)\}-\sum_{n=1}^N\left[-\ln p(x_n)\right]\\[2ex]& = -\sum_{n=1}^N\ln q(x_n|\theta)+\sum_{n=1}^N\left[\ln p(x_n)\right]\end{align}</script><p>注意右边第二项没有$θ$，我们只需要最大化</p><script type="math/tex; mode=display">\sum_{n=1}^N\ln q(x|\theta)=\ln\{\Pi_{n=1}^N q(x_n|\theta)\}</script><p>就是我们前面将的最大似然估计。</p><p>变量间的交互信息（mutual information）</p><p>我们有$x,y$的分布$p(x,y)$,如果$x,y$是独立的，$p(x,y)=p(x)p(y)$,如果$x,y$不独立，我们也可以使用$KL$来评估$x,y$是否是近似独立的。</p><script type="math/tex; mode=display">I[x,y]=KL\{p(x, y)||[p(x)p(y)]\}=-\iint p(x,y)\frac{p(x)p(y)}{p(x,y)}{\rm d}x{\rm d}y</script><p>这叫做$x,y$的mutual information.使用加法法则和乘法法则可以得到</p><script type="math/tex; mode=display">I[x,y]=H[x]-H[x|y]</script><p>可以把$p(x)$看做是先验概率，$p(x|y)$为后验概率，$I[x,y]$从贝叶斯的角度可以解释为：当知道一个$y$后，$x$的不确定性的减少量。例如当$y$与$x$独立时候，知道$y$对$x$一点影响都没有，那么$I[x,y] = H[x]-H[x|y] =H[x]-H[x]=0$。减少量为$0$。如果$x=y$那么$h[x|y]=0$.减少量为$H[x]$,表示告诉$y$后$x$就定了。</p>]]></content>
    
    
    <summary type="html">本文是西北工业大学机器学习第1节笔记</summary>
    
    
    
    <category term="机器学习" scheme="http://wcx2001.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="npuSE" scheme="http://wcx2001.github.io/tags/npuSE/"/>
    
    <category term="机器学习" scheme="http://wcx2001.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
