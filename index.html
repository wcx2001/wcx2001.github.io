<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-big-counter.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wcx2001.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":true,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true},"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Wei">
<meta property="og:url" content="http://wcx2001.github.io/index.html">
<meta property="og:site_name" content="Wei">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="小学渣的春天">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://wcx2001.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Wei</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Wei" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wei</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wcx2001.github.io/2021/12/07/L4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/machao.jpg">
      <meta itemprop="name" content="小学渣的春天">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/07/L4/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-07 17:33:05 / 修改时间：18:57:44" itemprop="dateCreated datePublished" datetime="2021-12-07T17:33:05+08:00">2021-12-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Course4：立体声系统和运动结构恢复"><a href="#Course4：立体声系统和运动结构恢复" class="headerlink" title="Course4：立体声系统和运动结构恢复"></a>Course4：立体声系统和运动结构恢复</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1  介绍"></a>1  介绍</h2><p>在前面的注释中，我们讨论了如何添加一个场景的额外视点可以极大地增强我们对所述场景的知识。我们专注于外极性几何设置，以便将一个图像平面上的点与另一个图像平面上的点联系起来，而不提取任何关于三维场景的信息。在这些课堂讲稿中，我们将讨论如何从多个二维图像中恢复有关三维场景的信息。</p>
<h2 id="2-三角剖分"><a href="#2-三角剖分" class="headerlink" title="2 三角剖分"></a>2 三角剖分</h2><p>多视图几何中最基本的问题之一是三角测量问题，即给定三维点投影到两个或多个图像的三维点位置的过程。</p>
<p><img src="F:\blog\source\_posts\视觉4.assets\image-20211204231213693-16386307346531.png" alt="image-20211204231213693"></p>
<p>​        图1：当给定两个视图时的三角测量问题的设置。</p>
<p>在两个视图的三角测量问题中，我们分别有两个已知相机固有参数$K$​和$K_0$​的相机。我们也知道这些相机彼此之间的相对方向和偏移量$R$、$T$。假设我们在三维中有一个点$P$，这可以分别在$p$和$p’$的两个相机的图像中找到。虽然$P$的位置目前尚不清楚，但我们可以测量$p$和$p’$在图像中的确切位置。由于$K$、$K’$、$R$、$T$是已知的，我们可以计算两个视线$l$和$l’$，它们由相机中心$O_1$、$O_2$和图像位置$p$、$p’$定义。因此，$P$可以计算为$l$和$l’$的交点。</p>
<p><img src="F:\blog\source\_posts\视觉4.assets\image-20211204231503216-16386309041802.png" alt="image-20211204231503216"></p>
<p>​        图2：真实场景中的三角测量问题通常涉及到最小化重投影误差。</p>
<p>虽然这个过程看起来既简单又数学合理，但在实践中并不是很好。在现实世界中，由于观测值$p$和$p’$有噪声，相机校准参数不精确，寻找$l$和$l’$的交点可能存在问题。在大多数情况下，它根本不存在，因为这两条线可能永远不会相交。        </p>
<h2 id="2-1-A-linear-method-for-triangulation"><a href="#2-1-A-linear-method-for-triangulation" class="headerlink" title="2.1 A linear method for triangulation"></a><strong>2.1 A linear method for triangulation</strong></h2><p>在本节中，我们将描述一个简单的线性三角测量方法，以解决射线之间缺乏交点。我们在图像中给出了两点相互对应的$p=MP=(x,y,1)$和$p’=M’P=(x’,y’,1)$。根据交叉积的定义，$p×(MP)=0$​。我们可以显式地使用交叉积生成的等式来形成三个约束：</p>
<script type="math/tex; mode=display">
\begin{matrix}
x(M_3P)-(M_1P)=0\\
y(M_3P)-(M_3P)=0\\
x(M_2P)-y(M_1P)=0
\end{matrix}\\tag{2.1}</script><p>其中$M_i$​是矩阵$M$​的第$i$​行。对于$p’$和$M’$也可以表示类似的约束。利用这两幅图像的约束条件，我们可以建立一个$AP=0$形式的线性方程，其中</p>
<script type="math/tex; mode=display">
A=\left[\begin{matrix}xM_3-M_1\\
yM_3-M_2\\
x'M_3-M_1'\\
y'M_3'-M_2'
\end{matrix}
\right ]
\tag{2.2}</script><p>该方程可以用SVD来求解，从而得到点$p$的最佳线性估计。该方法的另一个有趣的方面是，它实际上也可以处理来自多个视图的三角化。为此，简单地将添加的行附加到新视图添加的约束。</p>
<p>然而，该方法不适合用于射影重建，因为它不是射影不变的。例如，假设我们将相机矩阵M，M’替换为受射影变换$MH^{−1}$​，$M’H^{−1}$​影响的矩阵。线性方程A的矩阵变成$AH^{−1}$​。因此，之前对$AP=0$的估计的解决方案P将对应于转换问题$(AH^{−1})(HP)=0$的解决方案HP。回想一下，SVD解决了$||P||=1$​的约束，它在射影变换H下不是不变的。因此，该方法虽然简单，但往往不是三角剖分问题的最优解。</p>
<h2 id="2-2对三角剖分的一种非线性方法"><a href="#2-2对三角剖分的一种非线性方法" class="headerlink" title="2.2对三角剖分的一种非线性方法"></a>2.2对三角剖分的一种非线性方法</h2><p>相反，现实世界场景中的三角剖分问题通常被数学上描述为解决一个最小化问题：</p>
<script type="math/tex; mode=display">
\underset{\hat P} {min}\vert\vert M\hat P - p \vert \vert + \vert \vert M' \hat P-p' \vert \vert \tag{2.3}</script><p>在上述方程中，我们通过寻找两幅图像中Pˆ的重投影误差的最佳最小二乘估计值，来寻找一个最接近P的三维$\hat P$​。图像中三维点的重投影误差是图像中该点的投影与图像平面中对应的观测点之间的距离。在图2中我们的示例中，由于M是从三维空间到图像1的投影变换，所以图像1中$\hat P$​的投影点为$M\hat P$​。图1中$\hat P$​的匹配观测值为p。因此，图像1的重投影误差为距离$||M\hat P−p||$​。在公式2.3中发现的总体重投影误差是所有图像的重投影误差之和。对于有两幅以上图像的情况，我们只需在目标函数中添加更多的距离项：</p>
<script type="math/tex; mode=display">
\underset {\hat P}{\min} \sum _i ||M \hat P_i-p_i || ^2 \tag{2.4}</script><p>在实践中，存在着各种非常复杂的优化技术，它们可以很好地近似于问题。然而，对于该类的范围，我们将只关注其中一种技术，即非线性最小二乘的高斯-牛顿算法。一般的非线性最小二乘问题是找到一个最小化的$x∈R^n$​</p>
<script type="math/tex; mode=display">
\vert\vert r(x)\vert\vert^2 = \sum_{i=1}^mr_i(x)^2 \tag{2.5}</script><p>其中$r$是任何残差函数$r$：$R^n→R^m$​，这样对于某个函数f的$r(x)=f(x)-y$，输入$x$和观察$y$。当函数$f$为线性问题时，非线性最小二乘问题简化为正则的线性最小二乘问题。然而，回想一下，一般来说，我们的相机矩阵并不是仿射的。由于对图像平面的投影通常涉及到均匀坐标的除法，因此对图像的投影通常是非线性的。</p>
<p>请注意，如果我们将$e_i$​设置为一个$2×1$向量$e_i=M\hat P_i−p_i$​，那么我们可以重新表述我们的优化问题为：</p>
<script type="math/tex; mode=display">
\underset {\hat P}{\min} \sum _i e^i(\hat P)^2 \tag{2.6}</script><p>它可以完美地表示为一个非线性最小二乘问题。</p>
<p>在这些注释中，我们将介绍如何使用流行的高斯-牛顿算法来找到这个非线性最小二乘问题的近似解。首先，让我们假设我们对三维点$\hat P$​有一个有点合理的估计，我们可以用前面的线性方法来计算它。高斯-牛顿算法的关键见解是更新我们的估计，将其修正为一个更好的估计，从而最小化重投影误差。在每一步，我们想更新一些估计$\hat Pδ_P：\hat P=\hat P+δ_P$​。</p>
<p>但是我们如何选择更新参数$δ_P$​呢？高斯-牛顿算法的关键见解是线性化在当前估计$\hat P$​附近的残差函数。在我们的问题中，这意味着一个点P的残差e可以看作是：</p>
<script type="math/tex; mode=display">
e(\hat P+\delta_p) \approx e(\hat P)+\frac{\partial e}{\partial P}\delta_p \tag{2.7}</script><p>随后，将最小化问题转化为</p>
<script type="math/tex; mode=display">
\underset{\delta _P}{min} \vert \vert \frac {\partial e}{\partial P} \delta_P- (-e(\hat P)) \vert \vert^2 \tag{2.8}</script><p>当我们这样表示残差时，我们可以看到它采用了标准线性最小二乘问题的格式。对于$N$幅图像的三角剖分问题，线性最小二乘解为</p>
<script type="math/tex; mode=display">
\delta _P = -(J^TJ)^{-1}J^Te \tag{2.9}</script><p>其中</p>
<script type="math/tex; mode=display">
e = \left[
\begin {matrix}
e_1\\ 
\vdots
\\e_N
\end{matrix}
\right]=
\left[
\begin{matrix}
p_1-M_1\hat P
\\ \vdots
\\p_n-M_n\hat P
\end{matrix}
\right]\tag{2.10}</script><script type="math/tex; mode=display">
J=\left[
\begin {matrix}
\frac {\partial e_1} {\partial \hat P_1}& \frac {\partial e_1} {\partial \hat P_2}& \frac {\partial e_1} {\partial \hat P_3}\\
\vdots &\vdots& \vdots \\
\frac {\partial e_N} {\partial \hat P_1}& \frac {\partial e_N} {\partial \hat P_2}& \frac {\partial e_N} {\partial \hat P_3}
\end{matrix}
\right] \tag{2.11}</script><p>​        回想一下，一个特定图像$e_i$的残差向量是一个2×1向量，因为在图像平面上有二维空间。因此，在最简单的三角测量的两个相机情况($N=2$)中，这导致残差向量$e$是一个$2N×1=4×1$向量，雅可比矩阵$J$是一个$2N×3=4×3$矩阵。请注意该方法如何无缝地处理多个视图，因为通过将相应的行添加到e向量和J矩阵来解释额外的图像。在计算了更新$δ_P$之后，我们可以简单地对固定数量的步骤重复这个过程，或者直到它在数值上收敛。高斯-牛顿算法的一个重要性质是，我们假设残差函数接近我们的估计是线性的，这不能保证收敛。因此，在实践中，对估计数的更新次数设置一个上限总是有用的。</p>
<h2 id="3-从运动开始的仿射结构"><a href="#3-从运动开始的仿射结构" class="headerlink" title="3.从运动开始的仿射结构"></a>3.从运动开始的仿射结构</h2><p>在前一节的结尾，我们暗示了如何超越一个场景的两个视图来获得关于3D场景的信息。我们现在将探索将两个相机的几何形状扩展到多个相机。通过结合来自多个视角的点的观察，我们将能够同时确定场景的三维结构和摄像机的参数，即所谓的<strong>运动结构</strong>。</p>
<p><img src="F:\blog\source\_posts\视觉4.assets\image-20211205163943212-16386935853084.png" alt="image-20211205163943212"></p>
<p>​        图3：基于运动问题的总体结构的设置。</p>
<p>在这里，我们正式地介绍了从运动问题出发的结构。假设我们有$m$个相机与相机转换$M_i$编码相机的内在和外在参数。设$X_j$为场景中的$n$个3D点之一。每个3D点可以在多个位于$x_{ij}$位置的摄像机中可见，即使用投影变换$M_i$对摄像机$i$图像的投影。运动结构的目的是从所有观测值$x_{ij}$中恢复场景的结构（$n$三维点$X_j$）和摄像机的运动（$m$投影矩阵$M_i$​）。</p>
<h2 id="3-1由运动问题引起的仿射结构"><a href="#3-1由运动问题引起的仿射结构" class="headerlink" title="3.1由运动问题引起的仿射结构"></a>3.1由运动问题引起的仿射结构</h2><p>在解决运动问题的一般结构之前，我们将首先从一个更简单的问题开始，即假设相机是仿射或弱视角。最终，由于缺乏透视图的缩放操作，这使得数学推导更容易解决这个问题。</p>
<p>之前，我们推导了上述透视和弱透视情况的方程。请记住，在全透视模型中，相机矩阵被定义为</p>
<script type="math/tex; mode=display">
M = \left[
\begin{matrix}
A & b
\\ v & 1
\end{matrix}
\right]\tag{3.1}</script><p>其中$v$是一些非零的$1×3$向量。另一方面，对于弱透视模型，$v=0$。我们发现这个性质使$MX$的齐次坐标等于$1$：</p>
<script type="math/tex; mode=display">
x=MX=\left[
\begin{matrix}
& m_1\\
& m_2\\
0&0&0&1
\end{matrix}
\right]
\left[
\begin{matrix}
X_1\\
X_2\\
X_3\\
1
\end{matrix}
\right]=
\left[
\begin{matrix}
m_1X\\
m_2x\\
1
\end{matrix}
\right]
\tag{3.2}</script><p>因此，当我们从齐次坐标移动到欧几里得坐标时，投影变换的非线性消失了，而弱透视变换仅仅作为一个放大镜。我们可以更紧凑地将投影表示为：              </p>
<script type="math/tex; mode=display">
\left[
\begin{matrix}
m_1X\\
m_2X
\end{matrix}
\right]=
\left[
\begin{matrix}
A &b
\end{matrix}
\right]X
=
AX+    b
\tag{3.3}</script><p>并以仿射$M_{affine}=[A\ \ b]$​.的格式表示任何相机矩阵因此，我们现在使用仿射相机模型来表示三维中的$X_j$​点和每个仿射相机中相应的观察结果(例如，相机$i$​中的$x_{ij}$​)。</p>
<p>从运动问题回到结构，我们需要从$m ,n$​观测中估计m个矩阵$M_i$​和n个世界坐标向量$X_j$​，总共有$8m+3n$个未知数。每个观测结果对每个相机产生$2$个约束，所以在$8m+3n$未知数中有$2mn$方程。我们可以用这个方程来知道我们需要拥有的每张图像中相应观测数的下界。例如，如果我们有$m=2$个相机，那么我们需要在3D中至少有$n$个$=16$点。然而，一旦我们在每张图像中都标记了足够的对应点，我们如何解决这个问题呢？</p>
<h2 id="3-2托马西和卡纳德分解方法"><a href="#3-2托马西和卡纳德分解方法" class="headerlink" title="3.2托马西和卡纳德分解方法"></a>3.2托马西和卡纳德分解方法</h2><p>在这部分中，我们概述了托马西和卡纳德求解仿射结构的分解方法。该方法主要包括数据定心步骤和实际分解步骤。</p>
<p><img src="F:\blog\source\_posts\视觉4.assets\image-20211205170859869-16386953408895.png" alt="image-20211205170859869"></p>
<p>图4：当应用定心步骤时，我们对所有的图像点进行平移，使其质心（记为左下红十字）位于图像平面的原点。同样地，我们将世界坐标系置为原点位于三维点的质心处（记为右上角的红十字）。</p>
<p>让我们从数据定中心的步骤开始。在这一步中，主要的思想是将数据集中在原点。为此，对于每个图像$i$​，我们通过减去其质心$\hat x_{ij}$​来重新定义每个图像点$x_{ij}$​的新坐标$\bar {x_{ij}}$​​：</p>
<script type="math/tex; mode=display">
\hat x_{ij}= x_{ij}-\bar x_i=x_{ij}-\frac {1}{n}\sum_{j=1}^nx_{ij}\tag{3.4}</script><p>回想一下，来自运动问题的仿射结构允许我们定义图像点$x_{ij}$​、相机矩阵变量$A_i$​和$b_i$​，以及三维点$X_j$​之间的关系为：</p>
<script type="math/tex; mode=display">
x_{ij}=A_jX_j+b_i\tag{3.5}</script><p>在这个定心步骤之后，我们可以结合公式$3.4$中的中心图像点$\hat x_{ij}$​的定义和公式$3.5$中的仿射表达式：</p>
<script type="math/tex; mode=display">
\begin{align}
\hat x_{ij}&=\hat x_{ij}-\frac{1}{n}\sum_{k=1}^nx_{ik}\\
& =
A_iX_j-\frac {1}{n}\sum_{k=1}^nA_iX_k
\\
& =A_i(X_j-\frac {1}{n}\sum_{k=1}^nX_k)
\\
& =A_i(X_j-\bar X)\\
&=A_i\hat X_j 

\end{align}\tag{3.6}</script><p>从方程3.6中可以看出，如果我们将世界参考系统的起源转换为质心$\bar X$​​，那么图像点$x_{ij}$​​的中心坐标和3D点$\hat X_{ij}$​​的中心坐标仅通过一个$2×3$矩阵$A_i$​​进行关联。最终，分解方法的定心步骤允许我们创建一个紧凑的矩阵积表示，将三维结构与多个图像中的观测点联系起来。</p>
<p>但是，请注意，在矩阵乘积$\hat x_{ij}=A_i\hat X_j$​中，我们只能访问方程左侧的值。因此，我们必须以某种方式考虑出运动矩阵$A_i$​和结构$X_j$​。利用所有摄像机的所有观测结果，我们可以建立一个测量矩阵$D$，由$m$个摄像机中的$n$个观测结果组成(记住，每个$\hat x_{ij}$​入口都是一个$2×1$向量)：</p>
<script type="math/tex; mode=display">
D=\left[
\begin{matrix}
\hat x_11 & \hat x_12 &\cdots &\hat x_1n\\
\hat x_21 & \hat x_22 &\cdots &\hat x_2n\\
\vdots&\vdots&\ddots&\vdots \\
\hat x_m1 & \hat x_m2 &\cdots & \hat x_mn\\
\end{matrix}
\right]\tag{3.7}</script><p>现在回想一下，由于我们的仿射假设，D可以表示为$2m×3$​运动矩阵$M$(包括相机矩阵$A_1，…A_m$)和$3×n$结构矩阵$S$(包括3D点$X_1，…X_n$​​)的乘积。我们将使用的一个重要事实是秩$D$为$3$，因为$D$是两个最大维数为3的矩阵的乘积。</p>
<p>为了将$D$分解为$M$和$S$，我们将使用奇异值分解，$D=UΣV^T$​。因为我们知道秩为$D=3$，所以在$Σ$中只有$3$个非零奇异值$σ_1$，$σ_2$和$σ_3$。因此，我们可以进一步简化的表达式，得到以下分解方法：</p>
<script type="math/tex; mode=display">
\begin{align}
D&=U\sum V^T\\
    &=\left[
    \begin{matrix}u_1&\cdots&u_n
    \end {matrix}\right]
    \left[
    \begin{matrix}
    \sigma_1&0&0&0&\cdots&0\\
    0&\sigma_2&0&0&\cdots&0\\
    0&0&\sigma_3&0&\cdots&0\\
    0&0&0&0&\cdots&0\\
    \ & \ & \ & \ &\ddots &\ \\
    0&0&0&0&\cdots&0\\
    \end{matrix}
    \right]
    \left[
    \begin{matrix}v_1^T\\ \vdots \\ v_n^T
    \end {matrix}\right]\\
    & =\left[
    \begin{matrix}u_1&u_2&u_3
    \end {matrix}\right]
    \left[
    \begin{matrix}\sigma_1&0&0\\
    0&\sigma_2&0\\
    0&0&\sigma_3&\\
    \end {matrix}\right]
        \left[
    \begin{matrix}v_1^T\\ v_2^T\\ v_n^T
    \end {matrix}\right]\\
    &=U_3Σ_3V_3^T 
\end{align}    \tag{3.8}</script><p>在此分解中，$Σ_3$​定义为非零奇异值形成的对角矩阵，而$U_3$和$V_3T$分别取对应的$U$列和$V^T$​行得到。不幸的是，在实践中，由于测量噪声和仿射相机近似，秩$D&gt;3$。然而，请记住，当秩$D&gt;3$时，$U_3W_3V_3^T$​仍然是弗罗比尼乌斯范数意义上的最好的秩3近似。</p>
<p>经过仔细检查，我们发现矩阵积$Σ_3V_3^T$​​形成一个$3×n$​的矩阵，大小完全相同的结构矩阵$S$​类似，同样$U_3$​是一个$2m×3$矩阵，相同大小的运动矩阵M。虽然这种关联的组件SVD分解M和S导致一个物理和几何解的仿射结构从运动问题，这个选择不是一个唯一的解决方案。例如，我们也可以将运动矩阵设置为$M=U_3Σ_3$，将结构矩阵设置为$S=V_3^T$，因为在这两种情况下，观测矩阵$D$都是相同的。那么我们要选择什么因子分解呢？托马西和卡纳德得出结论，该因素分解的稳健选择是$M=U_3\sqrt{Σ_3}$和$S=\sqrt{Σ_3}V_3^T$​​。</p>
<h2 id="3-3-重建中的模糊性"><a href="#3-3-重建中的模糊性" class="headerlink" title="3.3 重建中的模糊性"></a>3.3 重建中的模糊性</h2><p>不过，我们发现在任何分解$D=MS$的选择中有固有的歧义，因为任何任意的、可逆的$3×3$矩阵$A$都可以插入到分解中：</p>
<script type="math/tex; mode=display">
D = MAA^{−1}S = (MA)(A^{−1}S) \tag{3.9}</script><p>这意味着从运动$M$获得的相机矩阵和从结构$S$获得的三维点可以乘以$10$个公共矩阵$a$。因此，我们的解决方案尚未确定，需要额外的约束来解决这种仿射歧义。当重构具有仿射模糊性时，这意味着保持了并行性，但度量尺度是未知的。</p>
<p>重建的另一类重要的歧义是相似度歧义，当重建被修正到相似度变换（旋转、平移和缩放）时，就会发生相似度歧义。一个只有相似性歧义的重构被称为度量重构。即使相机经过本质校准，这种模糊性也存在。好消息是，对于校准的相机，相似模糊是唯一的模糊。</p>
<p>事实上没有办法从图像中恢复一个场景的绝对尺度。除非我们做出进一步的假设（例如，我们知道图中房子的高度）或包含更多的数据，否则一个物体的尺度、绝对位置和规范方向总是未知的。这是因为某些属性可以补偿其他属性。例如，为了获得相同的图像，我们可以简单地向后移动对象，并相应地缩放它。在相机校准过程中出现了一个消除相似性模糊性的例子，我们假设我们知道校准点相对于现实世界参考系统的位置。这使我们能够知道棋盘上的正方形的大小，以学习三维结构的度量尺度。</p>
<h2 id="4-1-从运动开始的透视结构"><a href="#4-1-从运动开始的透视结构" class="headerlink" title="4.1 从运动开始的透视结构"></a>4.1 从运动开始的透视结构</h2><p>在研究了运动问题的简化仿射结构后，再考虑射影相机$M_i$​的一般情况。在一般情况下使用投影摄像机，每个相机矩阵$M_i$​包含$11$个自由度，因为它是被定义为：</p>
<script type="math/tex; mode=display">
M_i=\left[
\begin{matrix}
a_11 &a_12 &a_13 b_1\\
a_21 &a_22 &a_23 b_1\\
a_31 &a_32 &a_33 1
\end{matrix}
\right]
\tag{4.1}</script><p>此外，类似于仿射情况下的解可以找到一个仿射变换，解决结构和运动可以确定一个射影变换在一般情况下：我们总是可以任意应用一个4×4射影变换H运动矩阵，只要我们也变换结构矩阵的逆变换$H^{−1}$​。在图像平面上得到的观测结果仍然相同。</p>
<p>与仿射情况类似，我们可以从运动问题建立一般结构，从$m,n$观测$x_{ij}$估计$m$运动矩阵$M_i$和$n$三维点$X_j$​。因为相机和点只能在$4×4$投影变换（$15$个参数）上恢复，我们在$2mm$方程中有$11m+3n−15$未知数。根据这些事实，我们可以确定解决未知问题所需的观点和观察结果的数量</p>
<h2 id="4-1-代数方法"><a href="#4-1-代数方法" class="headerlink" title="4.1 代数方法"></a><strong>4.1 代数方法</strong></h2><p><img src="F:\blog\source\_posts\视觉4.assets\image-20211205234733614-16387192544986.png" alt="image-20211205234733614"></p>
<p>图5：在代数方法中，我们考虑顺序的，相机对来确定相机矩阵$M_1$​和$M_2$​，直到一个透视变换。然后我们发现了一个透视变换H，即$M_1H=[I \ \ \ \  0]和M_2H=[A\ \ \ \ B]$​</p>
<p>我们现在将介绍代数方法，它利用基本矩阵F的概念来解决两个相机的运动问题的结构。如图5所示，代数方法的主要思想是计算两个相机矩阵$M_1$​和$M_2$​，这只能计算到一个透视变换H。由于每个Mi只能计算一个透视变换H，我们总是可以考虑一个H，这样第一个相机投影矩阵$M_1H^{−1}$​是典型的。当然，同样的转换也必须应用于第二个相机，这导致了显示的形式：</p>
<script type="math/tex; mode=display">
M_1H^{-1}=[I \ \ \ \ \ 0]\ \ \ \ M_2H^{-1}=[A\ \ \ \ \ B]\tag{4.2}</script><p>​        为了完成这一任务，我们必须首先使用前面的课程注释中提到的八点算法来计算基本矩阵F。我们现在将使用F来估计射影相机矩阵$M_1和M_2$​。为了做这个估计，我们将P定义为图像p和p’中相应观测值的相应三维点。由于我们已经将$H^{−1}$​应用于两个相机投影矩阵，所以我们也必须将H应用于结构，给我们$\tilde P=HP$​。因此，我们可以将像素坐标$p$和$p’$与转换后的结构联系起来如下：</p>
<script type="math/tex; mode=display">
\begin{matrix}
p=M_1P=M_1H^{−1}H P=[I\ \ |\ \ 0]\tilde P\\
p'=M_2P=M_2H^{−1}HP=[A\ \ |\ \ b]\tilde P
\end{matrix}\tag{4.3}</script><p>两个图像对应的p和p’之间的一个有趣的属性通过一些创造性的替换而出现：</p>
<script type="math/tex; mode=display">
\begin{align}
p' 
&= [A|b]\tilde P\\[2ex]
&=  A[I|0]\tilde P + b \\[2ex]
&= Ap + b\\[2ex]
\end{align} \tag{4.4}</script><p>利用公式4.4，我们可以将p’和b之间的交叉积写为：</p>
<script type="math/tex; mode=display">
p' × b = (Ap + b) × b = Ap × b \tag{4.5}</script><p>根据交叉积的定义，p’×b垂直于p’。因此，我们可以写道：</p>
<script type="math/tex; mode=display">
\begin{align}
0
&= p' ^T (p' × b)\\[2ex]
&= p' ^T (Ap × b) \\[2ex]
&= p' ^T · (b × Ap) \\[2ex]
&= p' ^T [b]_×Ap
\end{align}
\tag{4.6}</script><p>看看这个约束条件，它应该会提醒你基本矩阵$p’^TFp=0$​的一般定义。如果我们设置了$F=[b]_×A$​，那么提取A和b就会简单地分解为一个分解问题。</p>
<p>让我们从确定$b$开始。同样，根据交叉积的定义，我们可以简单地把$Fb$写成</p>
<script type="math/tex; mode=display">
F b = [b]_×Ab = (b × A)b = 0 \tag{4.7}</script><p>由于F是奇异的，$b$可以用SVD,在$||b||=0$的条件下计算为$k=0$的最小二乘解。</p>
<p>一旦$b$知道，我们就可以计算$A$。如果我们设置了一个$A=−[b]_×F$，那么我们可以验证这个定义满足$F=[b]_×A$​：</p>
<script type="math/tex; mode=display">
\begin{align}
[b_×]A' =
&−[b×][b×]F\\[2ex]
&= (bb^T − |b|^2I)F \\[2ex]
&= bb^TF + |b|^2F\\[2ex]
&= 0 + 1 · F \\[2ex]
&= F
\end{align}
\tag{4.8}</script><p>​    因此，我们确定了相机矩阵$M_1H^{−1}$和$M_2H^{−1}$的两个表达式：</p>
<script type="math/tex; mode=display">
\tilde M_1 = [I\ \ \ \  0] \ \ \ \ \ \ \ \tilde M_2 = [−[e_×]F \ \ \ \ e] \tag{4.10}</script><h2 id="4-2-从本征矩阵中确定运动"><a href="#4-2-从本征矩阵中确定运动" class="headerlink" title="4.2 从本征矩阵中确定运动"></a>4.2 从本征矩阵中确定运动</h2><p>改进由代数方法得到的重建的一个有用的方法是使用校准的相机。利用基本矩阵是标准化坐标基本矩阵的一种特殊情况，可以提取出相机矩阵的更精确的初始估计。回想一下，通过使用基本矩阵E，我们假设我们已经校准了相机，从而知道内在相机矩阵$K$。我们可以直接从归一化图像坐标，也可以从它与基本矩阵$F$和内在矩阵$K$的关系来计算基本矩阵$E$：</p>
<script type="math/tex; mode=display">
E = K^TFK \tag{4.11}</script><p>因为基本矩阵假设我们有校准的相机，我们应该记住它只有$5$个自由度，因为它只有编码外部参数：相机之间的旋转$R$和平移$t$。幸运的是，这正是我们想要提取的用来创建运动矩阵的信息。首先，记住基本矩阵E可以表示为</p>
<script type="math/tex; mode=display">
E = [t]_×R \tag{4.12}</script><p>因此，也许我们可以找到一种策略来将E纳入其两个组成部分。首先，我们应该注意到交叉积矩阵$[t]_×$是偏对称的。我们定义了两个我们将在分解中使用的矩阵：</p>
<script type="math/tex; mode=display">
W=\left[
\begin{matrix}
0&-1&0\\
1&0&0\\
0&0&1
\end{matrix}
\right]
,
\ \ \ \ \ \ \
Z=\left[
\begin{matrix}
0&1&0\\
-1&0&0\\
0&0&0
\end{matrix}
\right]
\tag{4.13}</script><p>我们稍后将使用的一个重要特性是$Z=diag(1,1,0)W$到一个标志。类似地，我们也将使用$ZW=ZW^T=diag(1,1,0)$到一个符号。</p>
<p>由于特征值分解的结果，我们可以创建一个已知的一般偏对称矩阵的块分解。因此，我们可以将$[t]_×$写为</p>
<script type="math/tex; mode=display">
[t]_× = UZU^T \tag{4.14}</script><p>其中$U$是某个正交矩阵。因此，我们可以将该分解数重写为：</p>
<script type="math/tex; mode=display">
E = Udiag(1,1,0)(W U^TR)\tag{4.15}</script><p>仔细观察这个表达式，我们发现它非常类似于奇异值分解$E=UΣV^T$，其中Σ包含两个相等的奇异值。如果我们知道E，并且我们假设它采用了$E=Udiag(1,1,0)V^T$的形式，那么我们得到了E的以下分解：</p>
<script type="math/tex; mode=display">
[t]_×=UZU^T，\ \ R=UWV^T \ \ or\ \  UW^TV^T \tag{4.17}</script><p>通过检验，我们可以证明所给定的分解是有效的。我们还可以证明没有其他因素的分解。$[t]_×$的形式是由它的左零空间必须与E的零空间相同而决定的。给定一元矩阵U和V，任何旋转R都可以分解为$UXV^T$，其中X是另一个旋转矩阵。在替换这些值后，我们得到了$ZX=diag(1,1,0)$。因此，X必须等于W或$W^T$。</p>
<p>请注意，E的这种分解只保证了矩阵$UWV^T$或$UW^TV^T$是正交的。为了确保R是一个有效的旋转，我们只是要确保R的行列式是正的：</p>
<script type="math/tex; mode=display">
R=(detUW^TV^T)UWV^T\ \ \ \ or \ \ \ \ (detUW^TV^T)UW^TV^T \tag{4.17}</script><p>与类似于旋转$R$如何取两个潜在值相似，平移向量$t$也可以取几个值。从交叉积的定义中来看，我们知道</p>
<script type="math/tex; mode=display">
t × t = [t]_×t = UZU^T t = 0 \tag{4.18}</script><p>知道$U$是一元的，我们可以发现$||[t]_×||F=\sqrt{2}$。因此，我们从这个分解的$t$估计将从上面的方程和$E$是已知的，这意味着</p>
<script type="math/tex; mode=display">
t= \pm U\left[\begin{matrix}0\\0\\1\end{matrix}\right]=\pm u_3 \tag{4.13}</script><p>其中$u_3$是$U$的第三列。通过检查，我们还可以通过将$[t]_×=UZU^T$重新格式化为已知的向量$t$来验证我们得到相同的结果。</p>
<p><img src="F:\blog\source\_posts\视觉4.assets\image-20211206004541777-16387227427507.png" alt="image-20211206004541777"></p>
<p>图6：从基本矩阵中提取相对相机旋转R和平移t有四种可能的解决方案。然而，只有(a)中重建点在两个摄像机前。（图片取自哈特利和齐泽尔曼出版社的教科书第260页）</p>
<p>如图6所示，由于$R$和$t$同时存在两种选项，因此$R$和$t$都存在两种选项。直观地说，这四对对包括所有$16$种可能的对，即在特定方向旋转相机或在相反方向旋转相机，以及在特定方向或相反方向移动相机的选择。因此，在理想条件下，我们只需要三角化一个点来确定正确的一对$R$，$t$对。对于正确的一对$R$，$t$，三角化的点$\hat P$存在于两个相机的前面，这意味着它相对于两个相机参考系统都有一个正的$z$坐标。由于测量噪声，我们通常不依赖于三角点，而是三角测量许多点，并确定正确的一对$R$，$t$，作为两个相机前包含这些点的大多数。</p>
<h2 id="5-一个来自运动管道的结构示例"><a href="#5-一个来自运动管道的结构示例" class="headerlink" title="5 一个来自运动管道的结构示例"></a>5 一个来自运动管道的结构示例</h2><p>在找到相对运动矩阵$M_i$后，我们可以用它们来确定点$X_j$的世界坐标。在代数方法的情况下，这些点的估计将修正透视变换h。在从基本矩阵中提取相机矩阵时，估计可以被知道。在这两种情况下，三维点都可以通过前面描述的三角测量方法从估计的相机矩阵中计算出来。</p>
<p>对多视图案例的扩展可以通过链接成对的摄像机来完成。利用代数方法或基本矩阵，我们可以利用代数方法得到任意一对相机的相机矩阵和三维点的解，只要有足够的点对应。重建的3D点与相机对之间可用的点对应关系相关联。我们接下来将看到，这些成对的解决方案可以以一种称为捆绑调整的方法组合在一起（优化）。</p>
<h2 id="5-1-套件调整"><a href="#5-1-套件调整" class="headerlink" title="5.1 套件调整"></a>5.1 套件调整</h2><p>到目前为止，我们讨论的从运动问题解决结构的方法有很大的局限性。该分解方法假设所有的点在每幅图像中都是可见的。这是不太可能发生的，因为当我们有很多图像，或者有些图像相距遥远时，就会被遮挡，无法找到对应关系。最后，代数方法产生了成对的解，可以组合成一个摄像机链，但不能解决使用所有摄像机和三维点的相干优化重建。</p>
<p>为了解决这些限制，我们引入了<strong>束调整</strong>，这是一种从运动问题中求解结构的非线性方法。在优化中，我们的目标是尽量减少重投影误差，即一个重建点对估计摄像机的投影与其对所有摄像机和所有点的相应观测值之间的像素距离。之前，当讨论三角剖分的非线性优化方法时，我们主要关注这两个相机盒，我们自然地假设每个相机看到了两者之间的所有对应关系。然而，由于束束调整处理几个相机，它只计算每个相机可以看到的观测结果的重投影误差。最终，这个优化问题与我们在讨论三角测量的非线性方法时引入的问题非常相似。</p>
<p>求解束调整非线性优化的两种常用方法包括高斯-牛顿算法和莱文伯格-马夸特算法。您可以参考上一节关于高斯牛顿算法的细节，并参考哈特利和泽瑟曼教科书，了解更多关于莱文伯格-马夸特算法的细节。</p>
<p>综上所述，与我们所调查的其他方法相比，管束调整有一些重要的优点和局限性。它特别有用，因为它可以平滑地处理大量的视图，而且也可以处理每个图像都不能观察到特定点时的情况。然而，主要的限制是它是一个特别大的最小化问题，因为参数随着视图数量的增长。此外，由于它依赖于非线性优化技术，因此需要一个很好的初始条件。因此，束调整经常被用作来自运动实现的大多数结构的最后一步（即，在因子分解或代数方法之后），因为一种因子分解或代数方法可以为优化问题提供一个很好的初始解决方案。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
    
 </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wcx2001.github.io/2021/12/07/L3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/machao.jpg">
      <meta itemprop="name" content="小学渣的春天">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/07/L3/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-07 17:21:09 / 修改时间：17:26:40" itemprop="dateCreated datePublished" datetime="2021-12-07T17:21:09+08:00">2021-12-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="course3：对极几何"><a href="#course3：对极几何" class="headerlink" title="course3：对极几何"></a>course3：对极几何</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>之前，我们已经看到了如何使用典型的相机校准程序或单视图测量方法，使用一个或多个视图来计算相机的固有和外在参数。这个过程最终是从一幅图像中推导出关于三维世界的属性。然而，一般来说，不可能仅仅从一张图像中恢复3D世界的整个结构。这是由于3D到二维映射的内在模糊性：一些信息只是丢失了。</p>
<p><img src="https://c1.im5i.com/2021/12/07/cLTdt.png" alt=""></p>
<p>图1：像现在这样的一个男人举起比萨斜塔的照片可能会导致模糊的场景。对同一个场景的多个视图可以帮助我们解决这些潜在的歧义。</p>
<p>例如，在图1中，我们最初可能会被愚弄，认为这个人是在举着比萨的斜塔。只有通过仔细的检查，我们才能发现情况并非如此，而仅仅是一种基于在图像平面上不同深度的投影的错觉。然而，如果我们能够从一个完全不同的角度来看这个场景，这个错觉就会立即消失，我们就会立即找出正确的场景布局。</p>
<p>这些课堂讲稿的重点是展示当有多个相机时，掌握几何知识是非常大的帮助。具体来说，我们将首先关注定义两个观点所涉及的几何，然后介绍这个几何如何帮助进一步理解我们周围的世界。</p>
<h2 id="3-2-对极几何"><a href="#3-2-对极几何" class="headerlink" title="3.2  对极几何"></a>3.2  对极几何</h2><p><img src="https://c1.im5i.com/2021/12/07/cL5oS.png" alt=""></p>
<p>图2：上极性几何结构的一般设置。灰色区域是上极平面。橙色的线是基线，而两条蓝色的线是上极性线。</p>
<p>通常在多视图几何图形中，多个相机、一个3D点和该点在每个相机图像平面上的投影之间存在着有趣的关系。与照相机、三维图像中的点和相应的观测结果相关联的几何形状被称为立体声对的上极性几何形状。</p>
<p>如图2所示，标准的外极性几何设置包括两个摄像机观察相同的三维点P，它们在每个图像平面上的投影分别位于$p$和$p’$处。摄像机中心位于$O_1$和$O_2$​，它们之间的线称为基线。我们称由两个相机中心定义的平面，P为上极平面。基线与两个图像相交的位置。</p>
<p><img src="https://c1.im5i.com/2021/12/07/cLHML.png" alt=""></p>
<p>图3：在图像对上绘制的上极性线及其对应点的一个例子。</p>
<p>平面被称为外极点$e$和$e’$。最后，由上极平面与两个图像平面的交点定义的线称为上极线。外极线具有在图像平面的外极上与基线相交的特性。</p>
<p><img src="D:\办公文件\大三上\CV\笔记\L3.assets\image-20211202232841394-16384589235163.png" alt="image-20211202232841394"></p>
<p>图4：当两个图像平面平行时，上极e和e0位于无穷远处。请注意，上极线平行于每个图像平面的u轴。</p>
<p>图4显示了一个有趣的上极几何情况，当图像平面彼此平行时。当图像平面相互平行时，外极$e$和$e’$位于无穷大，因此上极$e$和$e’$与图像平面平行。这种情况的另一个重要副产品是上极线平行于每个图像平面的一个轴。这种情况特别有用，并将在后面的图像校正一节中进行更详细的介绍。</p>
<p>然而，在现实世界中，我们并没有给出3D位置P的确切位置，但我们可以确定它在其中一个图像平面P中的投影。我们还应该能够知道相机的位置、方向和相机矩阵。我们能用这些知识做些什么呢？通过对相机位置$O_1$、$O_2$和图像点$p$的了解，我们可以定义上极平面。有了这个上极平面，我们就可以确定上极线1。根据定义，P对第二幅图像$p’$的投影必须位于第二幅图像的上极线上。因此，对外极几何的基本理解允许我们在不了解场景的三维结构的情况下创建图像对之间的强约束。</p>
<p><img src="https://c1.im5i.com/2021/12/07/cLthD.png" alt=""></p>
<p>图5：确定必要矩阵和基本矩阵的设置，这有助于跨视图绘制点和上极性线。</p>
<p>我们现在将尝试开发无缝的方法来绘制跨视图的点和外极性线。如果我们采用原始的外极性几何框架中给出的设置（图5），那么我们将进一步定义$M$​和$M_0$​​为将三维点映射到它们各自的二维图像平面位置的相机投影矩阵。让我们假设世界参考系统与第一个相机相关联，第二个相机的偏移首先通过旋转R，然后平移T。这指定了相机投影矩阵为：</p>
<script type="math/tex; mode=display">
M=K[I\,\,\,0]\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,M'=K'[R^{\rm T}\,\,\,-R^{\rm T}T]\tag{1}</script><h2 id="3-本质矩阵"><a href="#3-本质矩阵" class="headerlink" title="3 本质矩阵"></a>3 本质矩阵</h2><p>在最简单的情况下，让我们假设我们有典型的相机，其中$K=K’=I$。这将公式1简化为</p>
<script type="math/tex; mode=display">
M=[I\,\,\,0]\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,M'=[R^{\rm T}\,\,\,-R^{\rm T}T]\tag{2}</script><p>此外，这意味着$p’$​在第一个相机的参考系统是$Rp’+T$因为向量$Rp’+T$和$T$躺在上极平面，那么如果我们的交叉积$T×(Rp’+T)=T×(Rp’)$，我们将得到一个向量上极平面的正常。这也意味着位于上极平面的$p$与$T×(Rp’)$是正常，这给了我们它们的点积为零的约束：</p>
<script type="math/tex; mode=display">
p^{\rm T}\cdot[T\times(Rp')]=0\tag{3}</script><p>从线性代数中，我们可以引入交叉积的一个不同的、紧的表达式：我们可以将任意两个向量a和b之间的交叉积表示为矩阵-向量乘法：</p>
<script type="math/tex; mode=display">
a\times b=\begin{bmatrix}
0 & -a_x & a_y\\
a_z & 0 & -a_x\\
-a_y & a_x & 0
\end{bmatrix}\cdot\begin{bmatrix}
b_x\\b_y\\b_z
\end{bmatrix}=[a_{\times}]b\tag{4}</script><p>将此表达式与方程3相结合，我们可以将交叉积项转换为矩阵乘法，并给出</p>
<script type="math/tex; mode=display">
\begin{matrix}
p^{\rm T}\cdot[T_\times](R_p')=0\\
p^{\rm T}[T_{\times}]Rp'=0
\end{matrix}\tag{5}</script><p>矩阵$E=[T_×]R$被称为基本矩阵，为外极约束创建了一个紧凑的表达式：</p>
<script type="math/tex; mode=display">
p^{\rm T}Rp'=0\tag{6}</script><p>本质矩阵是一个$3×3$​，其秩为$2$，包含$5$个自由度的奇异矩阵。</p>
<p>本质矩阵对于计算与$p$​和$p’$相关的上极线很有用。例如，$l’=E^Tp$​​给出了相机$2$的图像平面上的上极线。同样，$l=Ep’$给出了相机$1$的图像平面上的上极线。基本矩阵的其他有趣的性质是，它带外极点的点积等于零：$E^Te=Ee’=0$。因为对于相机$1$图像中的任何点$x$（$e$以外），相机$2$图像中对应的上极线$l’=E^Tx$包含外极$e’$。因此，$e’$满足所有x的$e’^T(E^Tx)=(e’^TE^T)x=0$，因此$Ee’=0$。同样，$E^Te=0$​​.</p>
<h2 id="4-基本矩阵"><a href="#4-基本矩阵" class="headerlink" title="4 基本矩阵"></a>4 基本矩阵</h2><p>虽然当我们有规范摄像机时，我们推导出了$p$和$p’$之间的关系，但当摄像机不再是规范摄像机时，我们应该能够找到一个更普遍的表达式。回想一下我们投影矩阵</p>
<script type="math/tex; mode=display">
M=[I\,\,\,0]\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,M'=K'[R^{\rm T}\,\,\,-R^{\rm T}T]\tag{7}</script><p>首先，我们必须将$p_c=K^{−1}p$​​和$p’_c=K’^{−1}p’$​​定义为典型相机，即$P$对相应相机图像的投影。回想一下，在典型的情况：</p>
<script type="math/tex; mode=display">
p_c^{\rm T}[T_\times]Rp_c'=0\tag{8}</script><p>通过替换$p_c$和$p’_c$​​的值，我们得到了</p>
<script type="math/tex; mode=display">
p^{\rm T}K^{-\rm T}[T_\times]RK'^{-1}p'=0\tag{9}</script><p>矩阵$F=K’^{−T}[T_×]RK^{−1}$​​​被称为基本矩阵，其作用类似于前一节的基本矩阵，但也对相机矩阵$K$​​、$K’$​和摄像机之间的相对平移$T$​和旋转$R$​的信息进行编码。因此，即使相机矩阵$K$、$K’$和变换$R$、$T$未知，它也对计算与$p$和$p’$相关的上极线也很有用。与基本矩阵相似，我们可以仅从基本矩阵和相应的点计算外极线$l’=F^Tp$和$l=Fp’$​​。本质矩阵和基本矩阵之间的一个主要区别是，基本矩阵包含$7$个自由度，而本质矩阵包含$5$个自由度。</p>
<p>但是基本矩阵是怎么用的呢？就像基本矩阵一样，如果我们知道基本矩阵，那么简单地知道一个图像中的一个点就会给我们在另一个图像中对应点的一个简单的约束（上极线）。因此，在不知道$P$在三维空间中的实际位置，或相机的任何外在或内在特征的情况下，我们可以建立任何$p$和$p’$之间的关系。</p>
<h2 id="4-1-八点算法"><a href="#4-1-八点算法" class="headerlink" title="4.1 八点算法"></a>4.1 八点算法</h2><p>尽管如此，假设我们可以有基本矩阵，这是由相机参数的矩阵乘积定义的，似乎相当大。然而，在给定同一场景的两幅图像的情况下，可以通过不知道相机的外部或内在参数来估计基本矩阵。我们所讨论的方法称为八点算法；</p>
<p><img src="https://c1.im5i.com/2021/12/07/cLWXq.png" alt=""></p>
<p>图6：在各自的图像上以相同的颜色绘制相应的点。</p>
<p>该算法由朗格特-希金斯于1981年提出，并于1995年由哈特利进行扩展。如标题所示，八点算法假设两张图像之间至少有$8$对对应的点可用。</p>
<p>每个对应的$pi=(u^i，v^i，1)$和$p’i=(u’_i，v’_i，1)$都给出了外极约束$p^T_iFp’_i=0$​。我们可以重新表述该约束条件如下：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
u_iu_i' & v_i'u_i & u_i & u_i'v_i & v_iv_i' & v_i & u_i'& v_i' & 1
\end{bmatrix}\cdot\begin{bmatrix}
F_{11}\\F_{12}\\F_{13}\\F_{21}\\F_{22}\\F_{23}\\F_{31}\\F_{32}\\F_{33}
\end{bmatrix}=0\tag{10}</script><p>由于这个约束是一个标量方程，所以它只约束一个自由度。由于我们只能知道基本矩阵，我们需要其中的$8$个约束来确定基本矩阵：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
u_1u_1' & v_1'u_1 & u_1' & u_1'v_1 & v_1v_1' & v_1 & u_1' & v_1' & 1\\
u_2u_2' & v_2'u_2 & u_2' & u_2'v_2 & v_2v_2' & v_2 & u_2' & v_2' & 1\\
u_3u_3' & v_3'u_3 & u_3' & u_3'v_2 & v_3v_3' & v_3 & u_3' & v_3' & 1\\
u_4u_4' & v_4'u_4 & u_4' & u_4'v_4 & v_4v_4' & v_4 & u_4' & v_4' & 1\\
u_5u_5' & v_5'u_5 & u_5' & u_5'v_5 & v_5v_5' & v_5 & u_5' & v_5' & 1\\
u_6u_6' & v_6'u_6 & u_6' & u_6'v_6 & v_6v_6' & v_6 & u_6' & v_6' & 1\\
u_7u_7' & v_7'u_7 & u_7' & u_7'v_7 & v_7v_7' & v_7 & u_7' & v_7' & 1\\
u_8u_8' & v_8'u_8 & u_8' & u_8'v_8 & v_8v_8' & v_8 & u_8' & v_8' & 1\\
\end{bmatrix}\cdot\begin{bmatrix}4F_{11}\\F_{12}\\F_{13}\\F_{21}\\F_{22}\\F_{23}\\F_{31}\\F_{32}\\F_{33}5\end{bmatrix}=0\tag{11}</script><p>可以化简为</p>
<script type="math/tex; mode=display">
W\rm f = 0 \tag{12}</script><p>其中$W$​是由$N≥8$对应推导出的$N×9$矩阵，$f$是我们想要的基本矩阵的值。</p>
<p>在实践中，通常最好使用$8$个以上的对应项，并创建一个更大的$W$矩阵，因为它减少了噪声测量的影响。该齐次方程组的解可以通过奇异值分解(SVD)得到最小二乘意义上，因为W是有缺陷的。SVD将给出基本矩阵$\hat F$的估计值，它可能满秩。然而，我们知道真正的基本矩阵的秩为$2$。因此，我们应该寻找一个可以作为$\hat F$​的最佳秩-2近似的解决方案。为此，我们解决了以下优化问题：</p>
<script type="math/tex; mode=display">
\begin{matrix}
{\rm minimize}_{F}\,\,\,||F-\hat{F}||_{F}\\
{\rm subject\,\,\, to}\,\,\, {\rm det}\,\,F=0
\end{matrix}\tag{13}</script><p>这个问题再次用SVD解决，其中$\hat F=UΣV^T$​​，然后找到最佳的秩$-2$近似</p>
<script type="math/tex; mode=display">
F=U\begin{bmatrix}
\sum_1 & 0 & 0\\
0 & \sum_2 & 0\\
0 & 0 & 0
\end{bmatrix}V^{\rm T}=0\tag{14}</script><h2 id="4-2-八点算法的归一化"><a href="#4-2-八点算法的归一化" class="headerlink" title="4.2 八点算法的归一化"></a>4.2 八点算法的归一化</h2><p>在实际应用中，八点算法的标准最小二乘方法并不精确。通常，一个点$p_i$​与其相应的上极线$l_i=Fp’$​之间的距离会非常大，通常在$10+$像素的尺度上。为了减少这个错误，我们可以考虑一个改进版本的八点算法，称为归一化八点算法。</p>
<p>标准八点算法的主要问题源于$W$对SVD是病态的。为了使SVD能够正常工作，$W$应该有一个奇异值等于（或接近）零，而其他奇异值为非零。然而，由于现代相机的像素范围(即$p_i=(1832,1023,1)$)，对应的$pi=(u_i，v_i，1)$在第一和第二坐标中往往具有极大的值。如果用于构造$W$的图像点在图像中一个相对较小的区域，那么$p_i$和$p’_i$​的每个向量通常会非常相似。因此，所构造的$W$矩阵将有一个非常大的奇异值，而其余的则相对较小。</p>
<p>为了解决这一问题，我们将在构造$w$之前对图像中的点进行归一化。这意味着我们通过对图像坐标进行平移和缩放来进行先决条件$W$，从而满足两个要求。首先，新坐标系的原点应位于图像点的质心（平移）。其次，变换后的图像点从原点处的均方距离应为$2$像素（缩放）。我们可以用一个变换矩阵$T$，$T_0$来紧凑地表示这个过程，该矩阵通过质心和缩放因子$(\frac{2N}{\sum_{i=1}^N||x_i-\bar{x}||^2})^{1/2}$​来转换。</p>
<p>然后，我们对坐标进行归一化：</p>
<script type="math/tex; mode=display">
q_i=Tp_i\,\,\,\,\,\,\,\,\,\,\,\,q_i'=T'p_i'\tag{15}</script><p>利用新的归一化坐标，我们可以使用正则最小二乘八点算法来计算新的$F_q$​​。而矩阵$F_q$​​是归一化坐标的基本矩阵。为了使它在正则坐标空间上可用，我们需要将它去规范化，并给出</p>
<script type="math/tex; mode=display">
F=T'^{\rm T}F_qT\tag{16}</script><p>最终，这个新的基本矩阵F在实际应用中得到了很好的效果。</p>
<h2 id="5-图像整改"><a href="#5-图像整改" class="headerlink" title="5 图像整改"></a><strong>5 图像整改</strong></h2><p>回想一下，当两个图像相互平行时，上极几何的一个有趣的情况发生了。让我们首先计算平行图像平面情况下的基本矩阵$E$。我们可以假设这两个相机有个相同的$K$，并且在相机之间没有相对旋转($R=I$)。在这种情况下，让我们假设只有一个沿$x$轴的平移，给出$T=(T_x,0,0)$​。这就给出了</p>
<script type="math/tex; mode=display">
l=Ep'=\begin{bmatrix}
0 & 0 & 0\\0 & 0 & -T_x\\ 0 & T_x & 0
\end{bmatrix}\cdot\begin{bmatrix}
u'\\v'\\1
\end{bmatrix}=\begin{bmatrix}
0\\-T_x\\ T_xv'
\end{bmatrix}\tag{18}</script><p>我们可以看到$l$​的方向是水平的，$l’$​的方向也是水平的，它是用类似的计算方法计算的。</p>
<p>​        <img src="D:\办公文件\大三上\CV\笔记\L3.assets\image-20211204164507526-163860750878413.png" alt="image-20211204164507526"></p>
<p>图7：图像校正的过程包括计算两个同构态，我们可以应用于一对图像，使它们并行。</p>
<p>如果我们使用外极约束$p^TEp’=0$​，那么我们得到了$v=v’$的事实，证明了$p$和$p’$共享相同的$v$坐标。因此，在对应的点之间存在着一种非常直接的关系。因此，当识别图像中对应点之间的关系时，校正或使任意两个给定图像并行的过程变得有用。</p>
<p>​        <img src="D:\办公文件\大三上\CV\笔记\L3.assets\image-20211204164617398-163860757903614.png" alt="image-20211204164617398"></p>
<p>图8：校正问题的设置：我们计算了两个同构态，我们可以应用于图像平面，使得到的平面平行。</p>
<p>重新生成一对图像不需要知道两个相机矩阵$K$​、$K’$​或它们之间的相对变换$R$​、$T$。相反，我们可以使用由归一化八点算法估计的基本矩阵。在得到基本矩阵后，我们可以计算每个对应的$p_i$和$p’_i$的外极线$l_i$和$l’_i$​​。</p>
<p>从一组上极线中，我们可以估计每幅图像的上极e和e’。这是因为我们知道外极位于所有外极线的交点处。在现实世界中，由于噪声测量，所有的上极线不会在一个点上相交。因此，可以通过最小化拟合一个点的最小二乘误差来计算上极点。回想一下，每条上极线都可以表示为一个向量$l$​​，这样直线上的所有点（用均次坐标表示）都在集合{${x|l^Tx=0}$​​}中。如果我们将每条上极线定义为$l_i=[l_{i,1}\ \ l_{i,2} \ \ l_{i,3}]^T$​​，那么我们可以建立一个线性方程组，并使用SVD求解找到外极$e$​​：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
l_1^{\rm T}\\ \vdots\\
l_n^{\rm T}
\end{bmatrix}e = 0\tag{19}</script><p>在找到外极$e$​和$e’$​时，我们很可能会注意到它们不是沿横轴在无穷大的点。如果它们是，那么，根据定义，这些图像将已经是平行的。因此，我们获得了一些如何使图像平行的见解：我们能找到一个沿横轴映射到无穷大的同源线吗？具体来说，这意味着我们想要找到一对同形图$H_1$​，$H_2$​，我们可以应用于图像，将上极映射到无穷大。让我们从找到一个同调图$H_2$开始，即$11$将第二个外极子$e’$映射到横轴上无穷远处的一个点$(f,0,0)$。由于这种同质性有很多可能的选择，我们应该尝试选择一些合理的东西。在实践中导致良好结果的一个条件是坚持认为同源性就像一个变换，在图像中心附近的点上应用平移和旋转。</p>
<p>实现这种变换的第一步是变换第二幅图像，使其中心在齐次坐标下处于$(0,0,1)$​处。我们可以通过应用平移矩阵来实现这一点</p>
<script type="math/tex; mode=display">
T=\begin{bmatrix}
1 & 0 &  -\frac{\rm width}{2}\\
0 & 1 & -\frac{\rm height}{2}\\
0 & 0 & 1
\end{bmatrix}\tag{20}</script><p>在应用平移后，我们通过旋转将其放置在某个点$(f,0,1)$的横轴上。如果平移的外极子$Te’$位于均次坐标$(e’_1, e’_2, 1)$​，则所应用的旋转为</p>
<script type="math/tex; mode=display">
R=\begin{bmatrix}
\alpha \frac{e_1'}{\sqrt{e_1'^2+e_2'^2}} & \alpha \frac{e_2'}{\sqrt{e_1'^2+e_2'^2}} & 0\\
-\alpha \frac{e_2'}{\sqrt{e_1'^2+e_2'^2}} & \alpha \frac{e_1'}{\sqrt{e_1'^2+e_2'^2}} & 0\\
0 & 0 & 1
\end{bmatrix}\tag{21}</script><p>其中，$α=1$，如果是$e’_1≥0$​和$α=−1$，否则。应用此旋转后，请注意，给定$(f,0,1)$处的任意点，将其带到横轴$(f,0,0)$上的无穷远处，只需要应用变换</p>
<script type="math/tex; mode=display">
G=\begin{bmatrix}
1 & 0 & 0\\
0 & 1& 0\\
-\frac{1}{f} & 0 & 1
\end{bmatrix}\tag{22}</script><p>在应用这个变换后，我们最终在无穷大处有一个外极，所以我们可以转换回正则图像空间。因此，我们应用在第二幅图像上来校正它的同源性$H_2$是</p>
<script type="math/tex; mode=display">
H_2=T^{-1}GRT\tag{23}</script><p>现在找到了一个有效的$H_2$​，我们需要为第一张图像找到一个匹配的同调H1。我们通过找到一个变换H1来最小化图像对应点之间的平方距离的平方和</p>
<script type="math/tex; mode=display">
\arg\min_{H_1} \sum_{i}||H_1p_i-H_2p_i'||^{2}\tag{24}</script><p>虽然推导$2$超出了这个类的范围，但我们可以证明匹配的$H_1$的形式是：</p>
<script type="math/tex; mode=display">
H_1=H_A H_2M\tag{25}</script><p>其中，$F=[e]_×M$​​和</p>
<script type="math/tex; mode=display">
H_A=\begin{bmatrix}
a_1 & a_2 &a_3\\
0 & 1 & 0\\
0 & 0 & 1
\end{bmatrix}</script><p>用$(a1、a2、a3)$组成计算特定向量a的元素。</p>
<p>首先，我们需要知道$M$​​是什么。任何$3×3$​斜对称矩阵$a$​的一个有趣的性质是一个$=A3$。因为任何交叉积矩阵$[e]_×$​​​都是偏对称的，而且我们只能知道基本矩阵$F$</p>
<script type="math/tex; mode=display">
F=[e]_\times M =[e]_\times[e]_\times[e]_\times M=[e]_\times[e]_\times F\tag{27}</script><p>通过对正确的术语进行分组，我们可以找到它</p>
<script type="math/tex; mode=display">
M=[e]_\times F\tag{28}</script><p>请注意，如果$M$的列由$e$的任意标量倍数添加，那么$F=[e]_×M$​仍然可以按缩放。因此，定义$M$的更一般的情况是</p>
<script type="math/tex; mode=display">
M=[e]_\times F+e v^{\rm T}\tag{29}</script><p>对于一些向量$v$。在实践中，通过设置$v^{\rm T}=[1\ \  1\ \  1]$​来定义M的效果非常好。</p>
<p>为了最终求解$H_1$​，我们需要计算$H_A$​的$a$值。回想一下，我们想找到一个$H_1，H_2$来最小化公式$24$中提出的问题。因为我们已经知道$H_2$和$M$的值，那么我们可以用$\hat {p_i}=H_2Mp_i和\hat p’_i=H_2p’_i$​来代替，然后最小化问题就变成了</p>
<script type="math/tex; mode=display">
\arg\min_{H_A}\sum_i||H_A\hat{p_i}-\hat{p_i'}||^2\tag{30}</script><p>特别地，如果我们让$\hat p_i=(\hat x_i，\hat y_i，1)$​和$\hat p_i=(\hat x_i，\hat y_i，1)$​​，那么最小化问题可以替换为：</p>
<script type="math/tex; mode=display">
\arg\min_a\sum_{i}(a_1\hat{x_i}+a_2\hat{y_i}+a_3-\hat{x_i'})^2+(\hat{y_i}-\hat{y_i'})^2\tag{31}</script><p>由于$\hat y_i−\hat y’_i$​​是一个常数值，因此最小化问题进一步简化为</p>
<script type="math/tex; mode=display">
\arg\min_a\sum_i(a_i\hat{x_i}+a_2\hat{y_i}+a_3-\hat{x_i'})^2\tag{32}</script><p>最终，这将分解为解决一个最小二乘问题$Wa = b$​</p>
<script type="math/tex; mode=display">
W=\begin{bmatrix}
\hat{x_1} & \hat{y_1} & 1\\
& \vdots\\
\hat{x_n} & \hat{y_n} & 1
\end{bmatrix}\,\,\,\,\,\,\,\,b=\begin{bmatrix}
\hat{x_1'}\\\vdots\\\hat{x_n'}
\end{bmatrix}\tag{33}</script><p>在计算$a$后，我们可以计算$H_A$，最后是$H_1$。因此，我们生成了同态$H_1、H_2$​​来校正给定一些对应关系的任何图像对。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
    
 </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wcx2001.github.io/2021/12/07/L2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/machao.jpg">
      <meta itemprop="name" content="小学渣的春天">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/07/L2/" class="post-title-link" itemprop="url">cs231a Course 2:单视图计量</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-07 00:00:00 / 修改时间：13:06:18" itemprop="dateCreated datePublished" datetime="2021-12-07T00:00:00+08:00">2021-12-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" itemprop="url" rel="index"><span itemprop="name">计算机视觉</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文是课程cs231a的第2节笔记</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/12/07/L2/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
    
 </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wcx2001.github.io/2021/12/07/L1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/machao.jpg">
      <meta itemprop="name" content="小学渣的春天">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/07/L1/" class="post-title-link" itemprop="url">cs231a Course 1:相机模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-07 00:00:00 / 修改时间：13:06:24" itemprop="dateCreated datePublished" datetime="2021-12-07T00:00:00+08:00">2021-12-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" itemprop="url" rel="index"><span itemprop="name">计算机视觉</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文是课程cs231a的第1节笔记</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/12/07/L1/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
    
 </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wcx2001.github.io/2021/12/07/Chapter2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/machao.jpg">
      <meta itemprop="name" content="小学渣的春天">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/07/Chapter2/" class="post-title-link" itemprop="url">npuSE Chapter 2 图像形成</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-07 00:00:00 / 修改时间：13:10:17" itemprop="dateCreated datePublished" datetime="2021-12-07T00:00:00+08:00">2021-12-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" itemprop="url" rel="index"><span itemprop="name">计算机视觉</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文是西北工业大学软件学院计算机视觉课程第二讲课程笔记</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/12/07/Chapter2/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
    
 </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wcx2001.github.io/2021/12/06/Chapter1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/machao.jpg">
      <meta itemprop="name" content="小学渣的春天">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/06/Chapter1/" class="post-title-link" itemprop="url">npuSE Chapter 1 绪论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-06 20:38:00" itemprop="dateCreated datePublished" datetime="2021-12-06T20:38:00+08:00">2021-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-07 13:09:58" itemprop="dateModified" datetime="2021-12-07T13:09:58+08:00">2021-12-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" itemprop="url" rel="index"><span itemprop="name">计算机视觉</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文来自西北工业大学软件学院计算机视觉课程笔记</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/12/06/Chapter1/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
    
 </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wcx2001.github.io/2021/12/06/Chaper1%E7%BB%AA%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/machao.jpg">
      <meta itemprop="name" content="小学渣的春天">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/06/Chaper1%E7%BB%AA%E8%AE%BA/" class="post-title-link" itemprop="url">npuSE Chapter 1：绪论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-06 20:38:00" itemprop="dateCreated datePublished" datetime="2021-12-06T20:38:00+08:00">2021-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-07 13:09:43" itemprop="dateModified" datetime="2021-12-07T13:09:43+08:00">2021-12-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文是西北工业大学机器学习第1节笔记</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/12/06/Chaper1%E7%BB%AA%E8%AE%BA/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
    
 </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wcx2001.github.io/2021/12/06/%E8%A7%86%E8%A7%89_5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/machao.jpg">
      <meta itemprop="name" content="小学渣的春天">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/06/%E8%A7%86%E8%A7%89_5/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-06 15:39:01" itemprop="dateCreated datePublished" datetime="2021-12-06T15:39:01+08:00">2021-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-07 19:09:09" itemprop="dateModified" datetime="2021-12-07T19:09:09+08:00">2021-12-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Course-5：主动立体声和体积立体声"><a href="#Course-5：主动立体声和体积立体声" class="headerlink" title="Course 5：主动立体声和体积立体声"></a>Course 5：主动立体声和体积立体声</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>在传统立体声中，主要思想是利用相应的点$p$​和$p’$​通过三角剖分来估计三维点$P$​的位置。这里的一个关键挑战是解决对应问题：我们如何知道一个点$p$​是否真的对应于另一个图像中的一个点$p’$？我们需要处理场景中存在的许多三维点，这进一步强调了这个问题。这些注释的重点将讨论在重建三维结构中工作良好的替代技术。</p>
<h2 id="2-主动立体声"><a href="#2-主动立体声" class="headerlink" title="2 主动立体声"></a>2 主动立体声</h2><p><img src="F:\blog\source\_posts\视觉_5.assets\image-20211206212433636-16387970747231.png" alt="image-20211206212433636"></p>
<p>​        图1：将一个点投影到3D空间中的活动立体声设置。</p>
<p>首先，我们将介绍一种被称为主动立体声的技术，以帮助缓解传统立体声中的对应问题。主动立体声的主要思想是用一个与3D环境交互的设备取代两个相机中的一个，通常通过将图案投射到很容易从第二台相机的物体上识别。这种新的投影仪-相机对定义了与我们引入的相机对相同的超极几何，将替换相机的图像平面替换为投影仪虚拟平面。在图$1$中，投影仪用于将虚拟平面上的一个点$p$投影到三维空间中的物体上，在三维空间$P$中产生一个点。这个3D点$P$应该在第二台相机中作为一个点$p’$被观察到。因为我们知道我们在投影什么(例如，$p$在虚拟平面上的位置，投影的颜色和强度等)，我们可以很容易地在第二台相机$p’$中发现相应的观测结果。</p>
<p><img src="F:\blog\source\_posts\视觉_5.assets\image-20211206214854643-16387985356642.png" alt="image-20211206214854643"></p>
<p>图2：将一条直线投射到三维空间中的活动立体声设置。</p>
<p>主动立体声的一种常见策略是从虚拟平面上投影一条垂直条纹，而不是单个点。这种情况与点的情况非常相似，其中线$s$被投影到三维空间$S$中的一条条纹上，并在相机中观察为一条线为$s’$。如果投影仪和照相机是平行的或校正的，那么我们可以通过简单地将$s’$与水平的上极线相交来很容易地发现相应的点。从对应关系中，我们可以使用前面的课程注释中介绍的三角测量方法来重建条纹s上的所有三维点。通过在场景中滑动线并重复这个过程，我们可以恢复场景中所有可见物体的整个形状。</p>
<p>请注意，该算法工作的一个要求是，前投影器和相机需要校准。有源立体声系统可以使用前面注释中描述的类似技术进行校准。我们可以先使用一个校准装置来校准照相机。然后，通过将已知条纹投影到校准装置上，并利用新校准相机的相应观测结果，建立估计投影仪内在和外部参数的约束条件。一旦校准了，这种主动立体声设置可以产生非常准确的结果。2000年，马克·莱瓦伊和他在斯坦福大学的学生们证明，通过使用精细调整的激光扫描仪，他们可以以亚毫米的精度恢复米开朗基罗的圣塔的形状</p>
<p>​        然而，在某些情况下，拥有一个精心调谐的投影仪可能太昂贵或麻烦。另一种使用更便宜得多的设置的方法是利用阴影为我们想要恢复的对象生成活动模式。通过在物体和光源之间的已知位置放置一根棍子，我们可以像以前一样有效地将一条条纹投射到物体上。移动棍子可以让我们在对象上投射不同的阴影条纹，并以类似的方式恢复对象。这种方法虽然便宜得多，但往往会产生不太准确的结果，因为它需要在棒、相机和光源之间进行非常好的校准，同时需要在棒的阴影的长度和厚度之间保持权衡。</p>
<p><img src="F:\blog\source\_posts\视觉_5.assets\image-20211206215038288-16387986391903.png" alt="image-20211206215038288"></p>
<p>​        图3：使用多条彩色线从单个投影中重建对象的活动立体声设置。</p>
<p>​        将一条条纹投射到物体上的一个限制是，它相当慢，因为投影仪需要滑动整个物体。此外，这意味着这种方法不能实时捕获变形。一个自然的扩展是尝试从前￾投影单个帧或图像来重建对象。其想法是将一种已知的不同条纹图案投射到物体的整个可见区域，而不是一条条纹。这些条纹的颜色的设计方式可以从图像中唯一地识别条纹。图3说明了这种多种颜色编码的条纹方法。这个概念为许多现代版本的深度传感器提供了动力，比如最初版本的微软Kinect。在实践中，这些传感器使用红外激光投影仪，使其能够在任何环境光条件下捕获3D视频数据。</p>
<p>​        </p>
<h2 id="3-体积立体声"><a href="#3-体积立体声" class="headerlink" title="3 体积立体声"></a><strong>3 体积立体声</strong></h2><p><img src="F:\blog\source\_posts\视觉_5.assets\image-20211206215136068-16387986969364.png" alt="image-20211206215136068"></p>
<p>​        图4：体积立体声的设置，它从一个有限的工作体积中获取点，并执行一致性检查，以确定三维形状。</p>
<p>​        传统立体声和主动立体声方法的另一种替代方法是体积立体声，它扭转了利用对应关系来寻找三维结构的问题。在体积立体声中，我们假设我们试图估计的三维点在一些包含的已知体积范围内。然后，我们将假设的3D点投影到校准的相机中，并验证这些投影是否在多个视图中一致。图4说明了体积立体声问题的一般设置。因为这些技术假设我们想要重建的点包含在有限的体积中，所以这些技术主要用于恢复特定对象的三维模型，而不是恢复场景的模型，这可能是无界的。</p>
<p>​        任何体积立体方法的主要原则都是，当我们将包含体积中的三维点重新投影到多个图像视图中时，首先定义“一致”的含义。因此，根据一致观察概念的认识，可以引入不同的技术。在这些注释中，我们将简要概述三种主要的技术，即空间雕刻、阴影雕刻和体素着色。</p>
<p>​        </p>
<h2 id="3-1空间雕刻"><a href="#3-1空间雕刻" class="headerlink" title="3.1空间雕刻"></a>3.1空间雕刻</h2><p><img src="F:\blog\source\_posts\视觉_5.assets\image-20211206215226337-16387987471065.png" alt="image-20211206215226337"></p>
<p>​        图5：我们想要重建的一个对象的剪影包含了图像中该对象的可见部分的所有像素。视锥是可以投射到图像中对象的剪影中的所有可能点的集合。</p>
<p>​        空间雕刻的概念主要来源于观察到一个物体的轮廓提供了关于该物体的几何信息的丰富来源。在多个视图的上下文下，让我们首先设置图5中所示的问题。每个照相机观察一个物体的一些可见的部分，从中可以确定一个轮廓。当投影到图像平面时，该轮廓包含一组像素，称为图像平面中的对象的剪影。空间雕刻最终使用来自多个视图的对象的轮廓来加强一致性</p>
<p>​        但是，如果我们没有三维对象的信息，而只有图像，那么我们如何获得剪影信息呢？幸运的是，使用轮廓的一个实际优点是，如果我们能够控制我们想要重建的物体背后的背景，它们就可以很容易地在图像中被检测到。例如，我们可以在对象后面的“绿色屏幕”来轻松地从对象的背景分割对象。</p>
<p>​        现在我们有了轮廓，我们如何真正使用它们呢？回想一下，在体积立体声中，我们估计了物体可以容纳的一些体积。现在我们介绍视锥的概念，即由相机中心定义的物体表面和图像平面上的包络轮廓。通过构造，保证了物体将完全位于初始体积和视锥内。</p>
<p><img src="F:\blog\source\_posts\视觉_5.assets\image-20211206215353976-16387988347746.png" alt="image-20211206215353976"></p>
<p>​        图6：从多个视图估计对象的过程涉及到恢复视觉船体，这是从每个相机的视觉锥的交集。</p>
<p>​        因此，如果我们有多个视图，那么我们可以计算每个视图的视锥。因为，根据定义，该物体位于每个这些视锥中，那么它必须位于这些视锥的交叉处，如图6所示。这样的交叉口通常被称为<strong>可见外壳</strong>。</p>
<p>​        在实践中，我们首先首先定义一个我们知道对象包含在其中的工作卷。例如，如果我们的相机包围着这个物体，那么我们就可以简单地说，工作体积是被相机所包围的空间的整个内部。我们将这个体积划分为被称为体素的小单位，定义了所谓的体素网格。我们将体素网格中的每个体素，并将其投射到每个视图中。如果该体素在一个视图中不包含在剪影中，那么它将被丢弃。因此，在空间雕刻算法的最后，我们留下了包含在可见外壳中的体素。</p>
<p>​        空间雕刻方法虽然避免了对应问题，而且相对简单，但仍有很多局限性。空间雕刻的一个限制是，它与网格中的体素数量呈线性关系。当我们减小每个体素的大小时，网格所需的体素数量以立方体的形式增加。因此，为了得到更好的重建，时间大幅增加。然而，可以使用一些方法，如使用八叉树来缓解这个问题。相关的，但更简单的方法包括迭代雕刻，以减少初始体素网格的大小。</p>
<p>​        <img src="F:\blog\source\_posts\视觉_5.assets\image-20211206215558090-16387989589137.png" alt="image-20211206215558090"></p>
<p>​        图7：在体素网格上进行的空间雕刻的结果。该区域是从两个视图中雕刻后重建的对象，而内部的阴影部分是实际的对象。请注意，重建方法总是保守的。</p>
<p>​        另一个限制是，空间雕刻的效果取决于视角的数量，剪影的精确性，甚至是我们试图重建的物体的形状。如果视图的数量太少，那么我们最终将对对象的视觉船体进行一个非常松散的估计。随着视图数量的增加，可以通过一致性检查删除更多无关的体素。此外，一致性检查的有效性仅仅是因为我们相信轮廓是正确的。如果剪影过于保守，并且包含的像素超过了必要的数量，那么我们的雕刻可能并不精确。在一个可能更糟糕的情况下，剪影遗漏了实际物体的部分内容，导致了过度雕刻的重建。最后，空间雕刻的一个主要缺点是它不能建模一个对象的某些凹处，如图8所示。</p>
<p><img src="F:\blog\source\_posts\视觉_5.assets\image-20211206215740328-16387990612118.png" alt="image-20211206215740328"></p>
<p>图8：空间雕刻不能处理一些凹处，如这里所示，因为它不能雕刻到那个区域，因为这样做将在物体中雕刻。注意，这意味着通常空间雕刻可以处理的唯一凹处是物体上的洞。</p>
<h2 id="3-2阴影雕刻"><a href="#3-2阴影雕刻" class="headerlink" title="3.2阴影雕刻"></a>3.2阴影雕刻</h2><p>​        为了规避空间雕刻所带来的凹度问题，我们需要查看其他形式的一致性检查。确定一个我们可以使用的物体的三维形状的一个重要线索是自阴影的存在。自我阴影是一个对象投射在其自身上的阴影。对于凹形物体的情况，一个物体通常会在凹形区域投射自阴影。</p>
<p>​        其核心的<strong>阴影雕刻</strong>通过使用自阴影来更好地估计凹度的想法，增强了空间雕刻。如图9所示，阴影雕刻的一般设置与空间雕刻非常相似。物体放置在校准相机查看的转盘中。然而，在相机周围有一组已知位置的灯，其状态可以适当地打开和关闭。这些灯将被用来制造对象投下自己的阴影。</p>
<p><img src="F:\blog\source\_posts\视觉_5.assets\image-20211206221300008-16387999808179.png" alt="image-20211206221300008"></p>
<p>​        图9：阴影雕刻的设置，通过从相机周围的一系列灯中添加一个新的一致性检查来增强空间雕刻。</p>
<p>​        如图10所示，阴影雕刻过程从一个初始体素网格开始，通过使用与空间雕刻相同的方法对该网格进行裁剪。然而，在每个视图中，我们都可以打开和关闭相机周围阵列中的每一盏灯。每一种光都会在物体上产生不同的自影。在识别出图像平面上的阴影后，我们就可以在我们裁剪后的体素网格的表面上找到位于阴影的视锥中的体素。这些表面体素允许我们用图像源制作一个新的视觉锥体。然后，我们利用一个有用的事实，即属于两个视锥的体素不能成为对象的一部分，来消除凹度中的体素。</p>
<p>​        与空间雕刻一样，阴影雕刻的运行时也取决于体素网格的分辨率。运行时随体素网格的分辨率呈立体比例。然而，如果有N个灯，那么阴影雕刻需要的N个+大约是空间雕刻的1倍，因为每个体素都需要投射到相机和每个N个灯中。</p>
<p>​        总之，阴影雕刻总是能产生一个保守的体积估计，从而更好地重建具有凹度的三维形状。结果的质量取决于视图的数量和光源的数量。这种方法的一些缺点是，它不能处理对象包含反射区或低反照率区域的情况。这是因为在这种情况下无法准确地检测到阴影。</p>
<p>​        <img src="F:\blog\source\_posts\视觉_5.assets\image-20211206221538184-163880013911510.png" alt="image-20211206221538184"></p>
<p>​        图10：阴影雕刻依赖于一种新的一致性检查，它可以去除相机的自阴影视锥和光的视锥中的体素。</p>
<h2 id="3-3体素着色"><a href="#3-3体素着色" class="headerlink" title="3.3体素着色"></a>3.3体素着色</h2><p>​        我们在体积立体图像中介绍的最后一种技术是体素着色，它在空间雕刻中使用颜色一致性而不是轮廓一致性。</p>
<p>​        如图11所示，假设我们从一个要重建的对象的多个视图中给出了图像。对于每个体素，我们查看它在每个图像中对应的投影，并比较每个投影的颜色。如果这些投影的颜色足够匹配，那么我们将该体素标记为对象的一部分。在空间雕刻中不存在的体素着色的一个好处是，与投影相关的颜色可以转移到体素上，从而给出彩色重建。</p>
<p>​        总的来说，人们可以使用许多方法来检查颜色一致性。一个例子是在投影之间的颜色相似性之间设置一个阈值。然而，对于任何使用的颜色一致性检查都存在一个关键的假设：被重建的物体必须是<strong>兰伯特式</strong>的，这意味着物体的任何部分的感知亮度不会随着视点位置或姿态而变化。对于非兰伯式的物体，比如那些由高反射性材料制成的物体，我们很容易想象，在实际上是物体一部分的体素上，颜色一致性检查会失败。</p>
<p><img src="F:\blog\source\_posts\视觉_5.assets\image-20211206221830788-163880031174711.png" alt="image-20211206221830788"></p>
<p>​        图11：体素着色的设置，它对一个体素的所有投影的颜色进行了一致性检查。</p>
<p><img src="F:\blog\source\_posts\视觉_5.assets\image-20211206221856626-163880033767012.png" alt="image-20211206221856626"></p>
<p>​        图12：一个香草体素着色的例子。</p>
<p>​        香草体素着色的一个缺点是，它产生的解决方案不一定是唯一的，如图12所示。找到真正的、唯一的解决方案会使通过体素着色进行重建的问题变得复杂。</p>
<p>​        通过在体素上引入可见性约束，可以消除重构中的歧义，这要求体素以特定的顺序进行遍历。</p>
<p>​        特别是，我们想要一层一层地遍历体素，从更靠近相机的体素开始，然后发展到更远的体素。当使用此顺序时，我们将执行颜色一致性检查。然后，我们检查该体素是否可以被至少两个摄像机看到，这就构建了我们的可见性约束。如果至少有两个摄像机无法看到该体素，那么它必须被遮挡，因此不能成为物体的一部分。请注意，我们处理更接近体素的顺序允许我们确保保留可以封闭以后处理的体素的体素，以强制这种可见性约束。</p>
<p>​        总之，体素着色具有同时捕获物体的形状和纹理的优点。一些缺点包括假设对象是兰伯特的，相机不能在特定的位置，因为由于可见性限制，体素需要以特定的顺序处理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
    
 </div>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="小学渣的春天"
      src="/images/machao.jpg">
  <p class="site-author-name" itemprop="name">小学渣的春天</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element"><i class="fa fa-comment"></i>
    Chat
  </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3djeDIwMDE=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wcx2001"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <a href="/1430466592@qq.com" title="E-Mail → 1430466592@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly93d3cubndwdS5lZHUuY24v" title="https:&#x2F;&#x2F;www.nwpu.edu.cn&#x2F;">西北工业大学</span>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小学渣的春天</span>
</div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js"></script>
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  




  
<script src="/js/local-search.js"></script>









<script data-pjax>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

    </div>
</body>
</html>
