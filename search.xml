<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>npuSE Chapter 1 绪论</title>
    <url>/2021/12/06/Chapter1/</url>
    <content><![CDATA[<h1 id="npuSE-Chapter-1-绪论"><a href="#npuSE-Chapter-1-绪论" class="headerlink" title="npuSE Chapter 1 绪论"></a>npuSE Chapter 1 绪论</h1><h2 id="1-1-什么是计算机视觉"><a href="#1-1-什么是计算机视觉" class="headerlink" title="1.1.什么是计算机视觉"></a>1.1.什么是计算机视觉</h2><p>计算机视觉是一门研究如何使机器“看”的科学，更进一步的说，就是指用摄影机和电脑代替人眼对目标进行识别、跟踪和测量等机器视觉，并进一步做图形处理，使电脑处理成为更适合人眼观察或传送给仪器检测的图像。<br>        作为一个科学学科，计算机视觉研究相关的理论和技术，试图建立能够从图像或者多维数据中获取‘信息’的人工智能系统。</p>
<h2 id="1-2-计算机视觉的主要应用"><a href="#1-2-计算机视觉的主要应用" class="headerlink" title="1.2.计算机视觉的主要应用"></a>1.2.计算机视觉的主要应用</h2><p>3D建模</p>
<p>地图映射</p>
<p>计算摄影</p>
<p>手写字符识别</p>
<p>人脸检测</p>
<p>物体识别</p>
<p>生物视觉识别</p>
<p>目标识别</p>
<p>动画3D建模</p>
<p>AR/VR</p>
<p>自动驾驶</p>
<p>全景拼接</p>
<p>机器自主导航</p>
<p>工业视觉</p>
<h2 id="1-3-计算机视觉的主要过程"><a href="#1-3-计算机视觉的主要过程" class="headerlink" title="1.3.计算机视觉的主要过程"></a>1.3.计算机视觉的主要过程</h2><p>任何一个CV系统，都离不开图像理解和图像生成。</p>
<p><img src="https://s4.ax1x.com/2021/12/07/o6Qu4I.png" alt></p>
<p>生成的过程可能各不相同，理解的过程基本相似。</p>
<p>【notes】</p>
<p>图像理解（image understanding,IU）就是对图像的语义理解。它是以图像为对象，知识为核心，研究图像中有什么目标、目标之间的相互关系、图像是什么场景以及如何应用场景的一门学科。</p>
<p>从计算机信息处理的角度来看，认为一个完整的图像理解系统可以分为以下的四个层次：数据层、描述层、认知层和应用层</p>
<hr>
<p>计算机视觉图像理解的主要过程：</p>
<p>数据层：获取图像数据，这里的图像可以是二值图、灰度图、彩色的和深度图等</p>
<p>描述层：提取特征或搭建学习网络结构，获得数据的表征向量</p>
<p>认知层：学习和推理，包括知识库的建立</p>
<p>应用层：根据任务需求，设计相应的分类器和学习算法。</p>
<h2 id="1-4-计算机视觉面临的困难"><a href="#1-4-计算机视觉面临的困难" class="headerlink" title="1.4.计算机视觉面临的困难"></a>1.4.计算机视觉面临的困难</h2><h2 id="1-5-计算机视觉发展历程"><a href="#1-5-计算机视觉发展历程" class="headerlink" title="1.5.计算机视觉发展历程"></a>1.5.计算机视觉发展历程</h2><h2 id="1-6-本课程的主要内容"><a href="#1-6-本课程的主要内容" class="headerlink" title="1.6.本课程的主要内容"></a>1.6.本课程的主要内容</h2>]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
        <tag>npuSE</tag>
      </tags>
  </entry>
  <entry>
    <title>npuSE Chapter 3：线性模型</title>
    <url>/2021/12/11/Chapter3%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Chapter-3：线性模型"><a href="#Chapter-3：线性模型" class="headerlink" title="Chapter 3：线性模型"></a>Chapter 3：线性模型</h1><h2 id="3-1-基本形式"><a href="#3-1-基本形式" class="headerlink" title="3.1 基本形式"></a>3.1 基本形式</h2><p>线性模型是通过属性的线性组合来进行预测的函数</p>
<ul>
<li>给定由$d$个属性的示例$x=(x_1;\cdots x_i,\cdots,x_d)$，则：</li>
</ul>
<script type="math/tex; mode=display">
\begin{align}
f(x) &= w_1x_1+\cdots+w_ix_i+\cdots+w_dx_d+b\\
&=w^{\rm T}x+b
\end{align}</script><p>通过学习，$w^{\rm T}$、$b$可确定</p>
<ul>
<li><p>特点</p>
<p>形式简单、易于建模</p>
<p>基本，许多非线性模型可在此基础上通过高维映射得到</p>
<p>解释性好，$w^{\rm T}$直观表达了各属性的重要性</p>
</li>
</ul>
<h2 id="3-2-线性回归"><a href="#3-2-线性回归" class="headerlink" title="3.2 线性回归"></a>3.2 线性回归</h2><p>线性回归，试图学得一个线性模型以尽可能准确地预测实值输出标记。</p>
<h3 id="3-2-1-一元线性回归"><a href="#3-2-1-一元线性回归" class="headerlink" title="3.2.1 一元线性回归"></a>3.2.1 一元线性回归</h3><ul>
<li><p>给定一维属性数据集$D=\{(x_i,y_i)\}^m_{i=1}$​，要得到$f(x_i)=wx_i+b$，使$f(x_i)\approx y_i$</p>
<p>对离散属性，若属性值间存在序关系，可通过连续化将其转化为连续值</p>
<p>如二分类$0.0$、$1.0$，三分类$0.0$、$0.5$、$1.0$</p>
</li>
<li><p>确定 $w$、$b$​</p>
<p>性能度量</p>
</li>
</ul>
<p><img src="/2021/12/11/Chapter3%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/image-20211210215541011.png" alt="图1"></p>
<p>​        令均方误差最小化</p>
<script type="math/tex; mode=display">
(w^*,b^*)=\arg \min_{(w,b)}\sum_{i=1}^m(f(x_i)-y_i)^2=\arg\min_{(w,b)}\left(y_i-wx_i-b\right)^2</script><p>​            最小二乘法，最小二乘参数估计</p>
<p>​            找到一直线，使所有样本到直线的欧氏距离之和最小</p>
<p>​        令$E_{(w,b)}=\sum_{i=1}^m(y_i-wx_i-b)^2$，分别对$w$，$b$求导并令导数为$0$，可得</p>
<script type="math/tex; mode=display">
w=\frac{\sum_{i=1}^m y_i(x_i-\overline{x})}{\sum_{i=1}^mx_i^2-\frac{1}{m} \left( \sum_{i=1}^m x_i \right)^2}</script><script type="math/tex; mode=display">
b=\frac{1}{m}\sum_{i=1}^m(y_i-wx_i)</script><h3 id="3-2-2-多元线性回归"><a href="#3-2-2-多元线性回归" class="headerlink" title="3.2.2 多元线性回归"></a>3.2.2 多元线性回归</h3><ul>
<li>对于$d$维属性数据集</li>
</ul>
<script type="math/tex; mode=display">
\begin{matrix}
D=\{(x_i,y_i)\}_{i=1}^m\\[2ex]
x_i=(x_{i1};\cdots;x_{id})
\end{matrix}</script><ul>
<li><p>要得到$f(x_i)=wx_i+b$，使$f(x_i)\approx y_i$</p>
</li>
<li><p>令$\hat{w}=(w;b)$，$y=(y_1;\cdots;y_m)$，数据集表示为</p>
</li>
</ul>
<script type="math/tex; mode=display">
X=\begin{pmatrix}
x_{11} & x_{12} & \cdots & x_{1d} & 1\\
x_{21} & x_{22} & \cdots & x_{2d} & 1\\
\cdots & \cdots & \cdots & \cdots & \cdots\\
x_{m1} & x_{m2} & \cdots & x_{md} & 1
\end{pmatrix} = \begin{pmatrix}
x_1^{\rm T} & 1\\
x_2^{\rm T} & 1\\
\cdots & \cdots\\
x_m^{\rm T} & 1
\end{pmatrix}</script><ul>
<li>采用最小二乘法求解，有</li>
</ul>
<script type="math/tex; mode=display">
\frac{\partial E_{\hat{w}}}{\partial \hat{w}}=2X^{\rm T}(X\hat{w}-y)</script><p>​        若$X^{\rm T}X$满秩或正定，则</p>
<script type="math/tex; mode=display">
\hat{w}^*=(X^{\rm T}X)^{-1}X^{\rm T}y</script><p>​        若$X^{\rm T}X$​不满秩，则可解出多个$\hat{w}$</p>
<p>​            此时需求助于归纳偏好，或引入正则化项</p>
<ul>
<li>令$\hat{x_i}=(x_i;1)$，则学得的多元线性回归模型为</li>
</ul>
<script type="math/tex; mode=display">
f(\hat{x_i})=\hat{x_i}^{\rm T}(X^{\rm T}X)^{-1}X^{\rm T}y</script><h3 id="3-2-3-线性模型的衍生"><a href="#3-2-3-线性模型的衍生" class="headerlink" title="3.2.3 线性模型的衍生"></a>3.2.3 线性模型的衍生</h3><ul>
<li>对于样例$(x,y),y\in R$ ，若希望线性模型的预测值逼近真实标记，则得到线性回归模型</li>
</ul>
<script type="math/tex; mode=display">
y=w^{\rm T}x+b</script><ul>
<li><p>如果输出的标记是在指数尺度上变化    </p>
<p>若令$\ln y=w^{\rm T}x+b$，就是对数线性回归</p>
<p>​    实际是在用$e^{w^{\rm T}+b}$逼近</p>
<p>​    实质上在求取输入空间到输出空间的非线性函数映射</p>
</li>
</ul>
<p><img src="/2021/12/11/Chapter3%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/image-20211210222541388.png" alt="图2"></p>
<ul>
<li><p>广义线性模型</p>
<p>一般形式</p>
<p>​    考虑单调可微函数$g(\cdot)$</p>
<script type="math/tex; mode=display">
\begin{matrix}
y=g^{-1}(w^{\rm T}x+b)\\[2ex]
g(y)=w^{\rm T}x+b
\end{matrix}</script><p>$g$​称为联系函数</p>
<p>$g$不同，就有不同的线性回归</p>
</li>
</ul>
<h2 id="3-3-对数几率回归"><a href="#3-3-对数几率回归" class="headerlink" title="3.3 对数几率回归"></a>3.3 对数几率回归</h2><h3 id="3-3-1-二分类任务"><a href="#3-3-1-二分类任务" class="headerlink" title="3.3.1 二分类任务"></a>3.3.1 二分类任务</h3><ul>
<li>期望输出$y\in\{0,1\}$</li>
<li>线性回归模型产生的实值输出$z=w^{\rm T}x+b$</li>
<li>找$z$和$y$的联系函数</li>
<li>理想的函数，单位阶跃函数</li>
</ul>
<script type="math/tex; mode=display">
\begin{cases}
0,\,\,\,\,\,\,\,\,\,\,\,\,z<0;\\
0.5,\,\,\,\,\,\,\,\,\,\,\,\, z=0;\\
1,\,\,\,\,\,\,\,\,\,\,\,\, z>0;
\end{cases}</script><p>​        性质不好，</p>
<p>​        函数不连续，</p>
<p>​        没有$g^{-1}$</p>
<p>​        需找替代函数</p>
<p><img src="/2021/12/11/Chapter3%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/image-20211210223406905.png" alt="图3"></p>
<h3 id="3-3-2-对率回归"><a href="#3-3-2-对率回归" class="headerlink" title="3.3.2 对率回归"></a>3.3.2 对率回归</h3><ul>
<li>对数几率函数</li>
</ul>
<script type="math/tex; mode=display">
y=\frac{1}{1+e^{-z}}</script><p>​        常用的替代函数</p>
<p>​        一种Sigmoid函数</p>
<p>​        单调可微、任意阶可导</p>
<p>​        它将$z$值转化为一个接近$0$或$1$的$y$值，输出值在$z=0$附近变化很陡</p>
<ul>
<li><p>以对率函数为联系函数</p>
<p>对数几率回归</p>
<script type="math/tex; mode=display">
y = \frac{1}{1+e^{-(w^{\rm T}x+b)}},\,\,\,\,\ln\frac{y}{1-y}=w^{\rm T}x+b</script><p>​    若将$y$视为样本二作为正例的可能性，则$1-y$是其反例可能性</p>
<p>​    两者的比值$y/(1-y)$称为几率，反映了$x$作为正例的相对可能性。              </p>
<p>​    $\ln \left[y/1-y\right]$称为对数几率</p>
</li>
<li><p>以对率函数为联系函数</p>
<p>优点：</p>
<p>直接对分类可能性进行建模，无需事先假设数据分布，这样就避免了假设分布不准确所带来的问题</p>
<p>不是仅预测出类别，而是得到近似概率预测，这对许多需利用概率辅助决策的任务很有用</p>
<p>对率函数是任意阶可导的凸函数，有很好的数学性质，现有许多数值优化算法都可直接用于求取最优解</p>
</li>
<li><p>求解$w$，$b$</p>
<p>将$y$看作类后验概率估计$p(y=1|x)$，则</p>
<script type="math/tex; mode=display">
\ln\frac{p(y=1|x)}{p(y=0|x)}=w^{\rm T}x+ b</script></li>
</ul>
<p>其中，</p>
<script type="math/tex; mode=display">
\begin{matrix}
(y=1|x)=\frac{e^{w^{\rm T}x+b}}{1+e^{w^{\rm T}x+b}}\\[2ex]
(y=0|x)=\frac{1}{1+e^{w^{\rm T}x+b}}\\[2ex]
\end{matrix}</script><p>可使用极大似然法估计$w$,$b$​</p>
<p>给定数据集$\{(x_i,y_i)\}_{i=1}^m$，则最大化如下对数似然函数</p>
<script type="math/tex; mode=display">
l(w,b)=\sum_{i=1}^m\ln p(y_i|x_i;w,b)</script><p>求$w$,$b$ ，使每个样本属于其真实标记的概率越大越好    </p>
<p>令：$\beta=(w;b),\hat{x}=(x;1)$，则$w^{\rm T}x+b$简写为$\beta^{\rm T}\hat{x}$</p>
<p>令：</p>
<script type="math/tex; mode=display">
p_1(\hat{x_i};\beta)=p(y=1|\hat{x};\beta)=\frac{e^{w^{\rm T}x+b}}{1+e^{w^{\rm T}x+b}}</script><script type="math/tex; mode=display">
p_0(\hat{x_i};\beta)=p(y=0|\hat{x}; \beta)=1-p_i(\hat{x_i};\beta)=\frac{1}{1+e^{w^{\rm T}x+b}}</script><p>则似然项：</p>
<script type="math/tex; mode=display">
p(y_i|x_i;w,b)=y_ip_1(\hat{x_i}; \beta)+(1-y_i)p_0(\hat{x_i};\beta)</script><p>最大化似然函数$l(w,b)=\sum_{i=1}^m\ln p(y_i|x_i;w,b)$等价于最小化</p>
<script type="math/tex; mode=display">
l(\beta)=\sum_{i=1}^m\left[-y_i\beta^{\rm T}\hat{x_i}+\ln(1+e^{\beta ^{\rm T}\hat{x_i}})\right]</script><p>即：</p>
<script type="math/tex; mode=display">
\beta^*=\arg\min_\beta l(\beta)</script><p>关于$β$的高阶可导连续凸函数，可用经典的数值优化方法（梯度下降法、牛顿法）</p>
<h2 id="3-4-线性判别分析"><a href="#3-4-线性判别分析" class="headerlink" title="3.4 线性判别分析"></a>3.4 线性判别分析</h2><p><img src="/2021/12/11/Chapter3%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/image-20211211125831205.png" alt="图4"></p>
<ul>
<li>LDA(线性判别分析)</li>
</ul>
<p>线性判别分析Lincar Discriminant Analysis</p>
<p>由Fisher 1936提出，亦称Fishy判别分析</p>
<ul>
<li>思想</li>
</ul>
<p>给定训练样例集，设法将训练样例投影到一条直线上</p>
<p>使得同类样例投影点尽可能接近、异类样例投影点尽可能远离</p>
<p>将新样本投影到这条直线上，根据投影点位置来确定新样本的类别</p>
<h3 id="3-4-1-目标函数"><a href="#3-4-1-目标函数" class="headerlink" title="3.4.1 目标函数"></a>3.4.1 目标函数</h3><ul>
<li>函数的表达</li>
</ul>
<p>令给定数据集$D=\{(x_i,y_i)\}_{i=1^m}$</p>
<p>第$i$类示例的集合$X_i$</p>
<p>第$i$类示例的均值向量$\mu_i$</p>
<p>第$i$类示例的协方差矩阵</p>
<p>两类样本的中心在直线上的投影$w^{\rm T}\mu_0$，$w^{\rm T}\mu_1$</p>
<p>两类样本的协方差$w^{\rm T}\Sigma_0w$，$w^{\rm T}\Sigma_1w$</p>
<p>使同类样例的投影点尽可能近，可让同类样例投影点的协方差$w^{\rm T}\Sigma_0w+w^{\rm T}\Sigma_1w$​尽可能小</p>
<p>使异类样例的投影点尽可能远，可让类中心之间的距离$|w^{\rm T}\mu_0-w^{\rm T}\mu_1|^2$​尽可能大</p>
<p>欲最大化的目标函数为</p>
<script type="math/tex; mode=display">
J=\frac{||w^{\rm T}\mu_0-w^{\rm T}\mu_1||_2^2}{w^{\rm T}\Sigma_0w+w^{\rm T}\Sigma_1w}=\frac{w^{\rm T}(\mu_0-\mu_1)(\mu_0-\mu_1)^{\rm T}w}{w^{\rm T}(\Sigma_0+\Sigma_1)w}</script><p>定义类内散度矩阵</p>
<script type="math/tex; mode=display">
\begin{align}
S_w &= \sum_0+ \sum_1\\
&=\sum_{x\in X_0}(x-\mu_0)(x-\mu_0)^{\rm T}+\sum_{x\in X_1}(x-\mu_1)(x-\mu_1)^{\rm T}

\end{align}</script><p>定义类间散度矩阵</p>
<script type="math/tex; mode=display">
S_b=(\mu_0-\mu_1)(\mu_0-\mu_1)^{\rm T}</script><p>目标函数可以写成：</p>
<script type="math/tex; mode=display">
J=\frac{w^{\rm T}S_bw}{w^{\rm T}S_ww}</script><p>​        即$S_b$与$S_w$的广义瑞利商</p>
<p>​        成倍缩放不影响$J$值仅考虑方向</p>
<p>求解$w$</p>
<p>​    令$w^{\rm T}S_w w=1$，最大化广义瑞利商等价为</p>
<script type="math/tex; mode=display">
\min_{w}\,\,\,\,-w^{\rm T}S_bw</script><script type="math/tex; mode=display">
s.t.\,\,\,\,w^{\rm T}S_ww=1</script><p>用拉格朗日乘子法，有</p>
<script type="math/tex; mode=display">
S_bw=\lambda S_w w</script><p>$S_bw$的方向恒为$\mu_0-\mu_1$，可令$S_bw=\lambda(\mu_0-\mu_1)$，有：</p>
<script type="math/tex; mode=display">
w=S_w^{-1}(\mu_0-\mu_1)</script><p>实践中通常是进行奇异值分解$S_w=U\Sigma V^{\rm T}$，然后：</p>
<script type="math/tex; mode=display">
S_w^{-1}=V\Sigma^{-1}U^{\rm T}</script><h3 id="3-4-2-推广到多类"><a href="#3-4-2-推广到多类" class="headerlink" title="3.4.2 推广到多类"></a>3.4.2 推广到多类</h3><ul>
<li>有$N$个类，第$i$类示例数为$m_i$，所有示例的均值向量为$\mu$</li>
</ul>
<p>定义类间散度矩阵</p>
<script type="math/tex; mode=display">
S_b=\sum_{i=1}^N m_i(\mu_i-\mu)(\mu_i-\mu)^{\rm T}</script><p>类内散度矩阵</p>
<script type="math/tex; mode=display">
S_w=\sum_{i=1}^NS_{w_i},\,\,\,\,S_{w_i}=\sum_{x\in X_i}(x-\mu_i)(x-\mu_i)^{\rm T}</script><p>全局散度矩阵</p>
<script type="math/tex; mode=display">
S_i=\sum_{i=1}^{m}(x_i-\mu)(x_i-\mu)^{\rm T}=S_b+S_w</script><ul>
<li>多分类LDA有多种实现方法，可使用三者中的任何两个即可</li>
</ul>
<p>如优化目标</p>
<script type="math/tex; mode=display">
\max_w\frac{tr(W^{\rm T}S_bW)}{tr(W^{\rm T}S_wW)}\implies S_bW=\lambda S_wW</script><p>$W$​的闭式解是$S_w^{-1}S_b$​的$N-1$个最大广义特征值所对应的特征向量矩阵</p>
<p>若将$W$视为一个投影矩阵，则多分类LDA将样本投影到$N-1$维空间</p>
<p>​    $N-1$通常远小于数据原有的属性数，可通过这个投影来减小样本点的维数，且投影过程中使用了类别信息</p>
<p>​    LDA也常被视为一种经典的监督降维技术</p>
<h2 id="3-5-多分类学习"><a href="#3-5-多分类学习" class="headerlink" title="3.5 多分类学习"></a>3.5 多分类学习</h2><ul>
<li>思路</li>
</ul>
<p>有些二分类学习方法直接推广到多分类</p>
<p>通常基于一些基本策略，利用二分类学习器解决多分类问题</p>
<h3 id="3-5-1-拆解法"><a href="#3-5-1-拆解法" class="headerlink" title="3.5.1 拆解法"></a>3.5.1 拆解法</h3><ul>
<li><p>多分类任务拆为若干个二分类任务求解</p>
</li>
<li><p>对问题进行拆分，为拆出的每个二分类任务训练一个分类器</p>
</li>
<li><p>测试时，对这些分类器的预测结果进行集成以获得最终的多分类结果</p>
</li>
<li><p>关键：如何对多分类任务进行拆分，如何对多个分类器进行集成</p>
<p>给定数据集：</p>
<script type="math/tex; mode=display">
D=\{(x_1,y_1),\cdots,(x_i,y_i),\cdots,(x_m,y_m)\},y_i\in\{C_1,C_2,\cdots,C_N\}</script></li>
</ul>
<h4 id="3-5-1-1-一对一拆分策略-One-vs-One，Ov0"><a href="#3-5-1-1-一对一拆分策略-One-vs-One，Ov0" class="headerlink" title="3.5.1.1 一对一拆分策略(One vs.One，Ov0)"></a>3.5.1.1 一对一拆分策略(One vs.One，Ov0)</h4><p>$N$个类别两两配对，产生$N(N-1)/2$个二分类任务</p>
<p>为类别$C_i$​和$C_j$​训练一个分类器，把$C_i$​类样例作为正例，$C_j$类样例作为反例</p>
<p>测试阶段，新样本同时提交给所有分类器，得到$N(N-1)/2$个分类结果，把被预测的最多类别作为最终结果</p>
<p>特点</p>
<p>​    训练$N(N-1)/2$个分类器，存储开销和测试时间大</p>
<p>​    每个分类器训练只用两个类的样例，训练时间短</p>
<p><img src="/2021/12/11/Chapter3%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/image-20211211135844318.png" alt="图5"></p>
<h4 id="3-5-1-2-一对其余-One-vs-Rest，OvR"><a href="#3-5-1-2-一对其余-One-vs-Rest，OvR" class="headerlink" title="3.5.1.2 一对其余(One vs.Rest，OvR)"></a>3.5.1.2 一对其余(One vs.Rest，OvR)</h4><p>每次将一个类的样例作为正例，其他类的样例作为反例，训练$N$个分类器</p>
<p>测试时若仅有一个分类器预测为正类，则对应的类别标记作为最终分类结果</p>
<p>若有多个分类器预测为正类，则通常考虑各分类器的预测置信度，选择置信度最大的类别标记</p>
<p>特点</p>
<p>​    训练$N$个分类器，存储开销和测试时间小</p>
<p>​    每个分类器训练用到全部训练样例，训练时间长</p>
<p><img src="/2021/12/11/Chapter3%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/image-20211211135929336.png" alt="图6"></p>
<h4 id="3-5-1-3-多对多-Many-vs-Many，MvM"><a href="#3-5-1-3-多对多-Many-vs-Many，MvM" class="headerlink" title="3.5.1.3 多对多(Many vs.Many，MvM)"></a>3.5.1.3 多对多(Many vs.Many，MvM)</h4><p>每次将若干类作为正类，若干其他类作为反类</p>
<p>OvO和OvR是MvM的特例</p>
<p>正反类构造必须有特殊的设计，不能随意选取，下面介绍一种</p>
<p>纠错输出码(ECOC)（一种MvM技术）</p>
<p>​    将编码思想引入类别拆分，尽量使解码过程具有容错性</p>
<p>​    工作过程</p>
<p>​        编码<br>​                    对$N$个类别做$M$次划分</p>
<p>​              每次划分将一部分划为正类一部分划为反类</p>
<p>​              共产生M个训练集，可训练出M个分类器</p>
<p>​        解码</p>
<p>​              $M$个分类器分别预测，预测标记组成一个编码</p>
<p>​              将预测编码与每个类别编码比较，返回距离最小的类别预测结果</p>
<p>纠错输出码(ECOC)</p>
<p>工作过程</p>
<p><img src="/2021/12/11/Chapter3%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/image-20211211140258236.png" alt="图7"></p>
<p>编码矩阵</p>
<p>类别划分通过编码矩阵指定</p>
<p>二元码：将每个类别分别指定为正类和反类</p>
<p>三元码：在正、反类之外，可指定停用类</p>
<p><img src="/2021/12/11/Chapter3%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/image-20211211140319206.png" alt="图8"></p>
<p>ECOC编码对分类器错误有一定容忍和修正能力，编码越长、纠错能力越强，因此称为纠错输出码</p>
<p>编码越长，所需训练的分类器越多，计算、存储开销都会增大</p>
<p>对有限类别数，可能的组合数目是有限的，码长超过一定范围后就失去了意义</p>
<p>对同等长度的编码，理论上来说，任意两个类别之间的编码距离越远，则纠错能力越强</p>
<p>码长较小时可计算出理论最优编码</p>
<p>码长稍大难以有效地确定最优编码，是NP难问题</p>
<p>不是编码理论性质越好，分类性能就越好，机器学习问题涉及很多因素，如以下两个很难比较</p>
<p>理论纠错性质很好、二分类问题较难的编码</p>
<p>理论纠错性质差一些、二分类问题较简单的编码</p>
<h2 id="3-6-类别不平衡问题"><a href="#3-6-类别不平衡问题" class="headerlink" title="3.6 类别不平衡问题"></a>3.6 类别不平衡问题</h2><ul>
<li>类别不平衡是指分类任务中不同类别的训练样例数目差别很大的情况</li>
</ul>
<p>会对学习过程造成困扰，如$998$个反例$2$正例</p>
<ul>
<li>解决思路</li>
</ul>
<p>① 假设二分类$y=w^{\rm T}x+b$</p>
<p>进行分类时，用预测出的$y$值与阈值比较，如$y&gt;0.5$时为正例，否则为反例</p>
<p>$y$实际上表达了正例的可能性，几率$y/(1-y)$反映了正例可能性与反例可能性之比</p>
<p>若阈值为$0.5$，分类器决策规则可写为“$y/(1-y)&gt;1$，则为正例”</p>
<p>当训练集正反例的数目不同，令$m^+$表示正例数，$m^-$表示反例数，则观测几率是$m^+/m^-$，因此，若$\frac{y}{1-y}&gt;\frac{m^+}{m^-}$，则为正例</p>
<p>② 再缩放：对其预测值进行调整</p>
<script type="math/tex; mode=display">
\frac{y'}{1-y'}=\frac{y}{1-y}\times\frac{m^-}{m^+}</script><p>简单，但实际不易，因为未必能基于训练集观测几率来推断真实几率，训练集不是无偏采样</p>
<p>③ 欠采样</p>
<p>去除一些反例使正反例数目接近，然后进行学习</p>
<p>学习时间开销小</p>
<p>④ 过采样</p>
<p>增加一些正例使正反例数目接近，然后进行学习</p>
<p>学习时间开销大</p>
<p>不能简单进行重复采样，否则过拟合</p>
<p>对正例进行插值来产生额外的正例</p>
<p>⑤ 阈值移动</p>
<p>基于原始训练集进行学习，将上式嵌入到决策过程中</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>npuSE</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>npuSE Chapter 4：决策树</title>
    <url>/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    <content><![CDATA[<h1 id="Chapter-4：决策树"><a href="#Chapter-4：决策树" class="headerlink" title="Chapter 4：决策树"></a>Chapter 4：决策树</h1><h2 id="4-1-基本流程"><a href="#4-1-基本流程" class="headerlink" title="4.1 基本流程"></a>4.1 基本流程</h2><h3 id="4-1-1-决策树模型"><a href="#4-1-1-决策树模型" class="headerlink" title="4.1.1 决策树模型"></a>4.1.1 决策树模型</h3><ul>
<li>决策树基于树结构进行决策</li>
</ul>
<ol>
<li><p>一棵决策树包含一个根结点、若干个内部结点和若干个叶结点</p>
</li>
<li><p>每个内部结点对应于某个属性上的测试</p>
</li>
</ol>
<p>​    每个测试的结果或是导出最终结论，或是导出进一步的判定问题，其考虑范围是在上次决策结果的限定范围之内</p>
<ol>
<li>每个分支对应于该测试的一种可能结果，即该属性的某取值</li>
</ol>
<p>​    每个结点包含的样本集合根据属性测试的结果被划分到子结点中</p>
<p>​    根结点包含样本全集</p>
<ol>
<li>每个叶结点对应于一个预测结果</li>
</ol>
<p>​    从根结点到每个叶结点的路径对应了一个判定测试序列</p>
<ul>
<li>学习过程：通过对训练样本的分析来确定划分属性，即内部结点所对应的属性，从而产生一棵泛化能力强的决策树</li>
<li>预测过程：将未知示例从根结点开始，沿着划分属性所构成的判定测试序列下行，直到叶结点得到结果</li>
</ul>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212110614396.png" alt="图1"></p>
<h3 id="4-1-2-从树到规则"><a href="#4-1-2-从树到规则" class="headerlink" title="4.1.2 从树到规则"></a>4.1.2 从树到规则</h3><ul>
<li><p>一棵决策树对应于一个规则集</p>
</li>
<li><p>每个从根结点到叶结点的分支路径对应于一条规则</p>
</li>
</ul>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212110801253.png" alt="图2"></p>
<h3 id="4-1-3-基本学习算法流程"><a href="#4-1-3-基本学习算法流程" class="headerlink" title="4.1.3 基本学习算法流程"></a>4.1.3 基本学习算法流程</h3><p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212110848918.png" alt="图3"></p>
<ul>
<li>策略：分而治之</li>
<li>决策树的生成是一个自根至叶的递归过程</li>
<li>在每个中间结点寻找一个划分属性</li>
<li>三种递归停止条件</li>
</ul>
<ol>
<li><p>当前结点包含的样本全属于同一类别，无需划分</p>
<p>当前结点标记为叶结点</p>
</li>
<li><p>当前属性集为空或是所有样本在所有属性上取值相同，无法划分</p>
<p>当前结点标记为叶结点</p>
<p>类别设定为该结点所含样本最多的类别</p>
<p>利用当前结点的后验分布</p>
</li>
<li><p>当前结点包含的样本集合为空，不能划分</p>
<p>当前结点标记为叶结点</p>
<p>类别设定为其父结点所含样本最多的类别</p>
<p>将父结点的样本分布作为当前结点的先验分布</p>
</li>
</ol>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212111027921.png" alt="图4"></p>
<h2 id="4-2-划分选择"><a href="#4-2-划分选择" class="headerlink" title="4.2 划分选择"></a>4.2 划分选择</h2><p>如何选择最优划分属性</p>
<p>希望分支结点所包含的样本尽可能属于同一类别(纯度)，即结点的纯度越来越高</p>
<h3 id="4-2-1-信息增益"><a href="#4-2-1-信息增益" class="headerlink" title="4.2.1 信息增益"></a>4.2.1 信息增益</h3><ul>
<li><p>信息熵</p>
<p>度量样本集合纯度最常用的一种指标</p>
<p>样本集$D$中第$k$类样本的比例为$p_k$，则$D$的信息熵</p>
</li>
</ul>
<script type="math/tex; mode=display">
{\rm Ent}(D)=-\sum_{k=1}^{|y|}p_k\log_2p_k</script><p>​     若$p=0$，则$p\log_2p=0$<br>​            ${\rm Ent}(D)$的值越小，则$D$的纯度越高</p>
<ul>
<li>信息增益以信息熵为基础，计算当前划分对信息熵造成的变化</li>
</ul>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212111557726.png" alt="图5"></p>
<ol>
<li>设离散属性$a$有$V$个可能的取值$\{a^1,a^2,\cdots,a^V\}$</li>
<li>用$a$划分样本集$D$，会产生$V$个分支结点，第$v$个分支结点包含属性$a$取值为   的样本，记为$D^V$</li>
<li>不同分支结点所包含的样本数不同，影响不同，给分支结点赋予权重$|D^v|/|D|$</li>
<li>于是可得属性$a$划分样本集$D$的信息增益</li>
</ol>
<script type="math/tex; mode=display">
{\rm Gain}(D,a)={\rm Ent}(D)-\sum_{v=1}^V\frac{|D^v|}{D}{\rm Ent}(D^v)</script><p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212112042643.png" alt="图6"></p>
<p>一般信息增益越大，使用属性a进行划分获得的纯度提升越大</p>
<p>可用信息增益进行决策树的划分属性选择，即</p>
<script type="math/tex; mode=display">
a_*=\arg\max_{\alpha\in A}{\rm Gain}(D,a)</script><p>在ID3决策树学习算法中使用</p>
<p>例子：计算根结点的信息熵</p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212112331056.png" alt="图7"></p>
<p>计算当前属性集合{色泽，根蒂，敲声，纹理，脐部，触感}中每个属性的信息增益</p>
<p>属性色泽对应$3$个数据子集，$D^1$ (色泽=青绿)，$D^2$(色泽=乌黑)，$D^3$(色泽=浅白)</p>
<p>子集$D^1$包含$6$个样例，其中正例$p_1=3/6$，反例$p_1=3/6$，$D^2$、$D^3$同理，$3$个结点的信息熵</p>
<script type="math/tex; mode=display">
\begin{matrix}
{\rm Ent}(D^1)=-(\frac{3}{6}\log_2\frac{3}{6}+\frac{3}{6}\log_2\frac{3}{6})=1.000\\[2ex]
{\rm Ent}(D^2)=-(\frac{4}{6}\log_2\frac{4}{6}+\frac{2}{6}\log_2\frac{2}{6})=0.918\\[2ex]
{\rm Ent}(D^2)=-(\frac{1}{5}\log_2\frac{1}{5}+\frac{4}{5}\log_2\frac{4}{5})=0.722
\end{matrix}</script><p>属性“色泽”的信息增益为</p>
<script type="math/tex; mode=display">
{\rm Gain}(D,{\rm 色泽})={\rm Ent}(D)-\sum_{v=1}^3\frac{|D^v|}{D}{\rm Ent}(D^v)=0.109</script><p>类似可得其他属性的信息增益</p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212113325155.png" alt="图8"></p>
<p>属性纹理的信息增益最大，被选为划分属性</p>
<p>然后决策树学习算法将对每个分支结点做进一步划分</p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212113348979.png" alt="图9"></p>
<p>基于$D^1$计算出各属性的信息增益</p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212114107798.png" alt="图10"></p>
<p>根蒂、脐部、触感3个属性均取得了最大的信息增益，可任选其中之一作为划分属性</p>
<p>对每个分支结点进一步划分，最终得到决策树</p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212114241687.png" alt="图11"></p>
<h3 id="4-2-2-增益率"><a href="#4-2-2-增益率" class="headerlink" title="4.2.2 增益率"></a>4.2.2 增益率</h3><ul>
<li>信息增益的缺陷</li>
</ul>
<p>如果属性划分每个分支结点仅包含一个样本，这些分支结点的纯度最大，其信息</p>
<p>增益然远大于其他候选属性</p>
<p>这样的决策树不具有泛化能力，无法对新样本进行有效预测</p>
<p>信息增益对可取值数目较多的属性有偏好</p>
<ul>
<li>增益率定义(C4.5决策树算法)</li>
</ul>
<script type="math/tex; mode=display">
{\rm Gain\_ratio}(D,a)=\frac{ {\rm Gain}(D,a)} { {\rm IV}(a)}</script><script type="math/tex; mode=display">
{\rm IV}(a)=-\sum_{v=1}^V\frac{D^v}{D}\log_2\frac{|D^v|}{D}</script><p>称为属性$d$的固有值</p>
<p>属性$a$的可能取值数目越多，即$V$越大，则$IV(a)$的值通常就越大</p>
<p>增益率准则对可取值数目较少的属性有所偏好</p>
<ul>
<li>C4.5算法不直接选择增益率最大的候选划分属性，而是使用启发式方法</li>
</ul>
<p>从候选划分属性中找出信息增益高于平均水平的</p>
<p>再从中选取增益率最高的</p>
<h3 id="4-2-3-基尼指数-CART决策树"><a href="#4-2-3-基尼指数-CART决策树" class="headerlink" title="4.2.3 基尼指数(CART决策树)"></a>4.2.3 基尼指数(CART决策树)</h3><ul>
<li>数据集$D$的纯度可用基尼值来度量</li>
</ul>
<script type="math/tex; mode=display">
{\rm Gini}(D)=\sum_{k=1}^{|y|}\sum_{k'\neq k} p_k p_{k'}=1-\sum_{k=1}^{|y|}p_k^2</script><p>反映了从$D$中随机抽取两个样例，其类别标记不一致的概率</p>
<p>${\rm Gini}(D)$越小，数据集D的纯度越高</p>
<ul>
<li>属性$a$的基尼指数</li>
</ul>
<script type="math/tex; mode=display">
{\rm Gini\_index}(D,a)=\sum_{v=1}^V\frac{|D^v|}{|D|}{\rm Gini}(D^v)</script><ul>
<li>在候选属性集合中，选取那个使划分后基尼指数最小的属性，即</li>
</ul>
<script type="math/tex; mode=display">
a_*=\arg\max {\rm Gini\_index}(D,a)</script><h2 id="4-3-剪枝处理"><a href="#4-3-剪枝处理" class="headerlink" title="4.3 剪枝处理"></a>4.3 剪枝处理</h2><ul>
<li>过拟合</li>
</ul>
<p>为尽可能正确分类训练样本，结点划分不断重复，会造成决策树分支过多，导致过拟合</p>
<p>可通过去掉一些分支来降低过拟合的风险，剪枝是决策树对付“过拟合”的主要手段</p>
<ul>
<li>剪枝影响</li>
</ul>
<p>研究表明划分选择的各种准则虽然对决策树的尺寸有较大影响，但对泛化性能的影响很有限，如信息增益与基尼指数产生的结果，仅在约2%的情况下不同</p>
<p>剪枝方法和程度对决策树泛化性能的影响更为显著，在数据带噪时甚至可能将泛化性能提升25%</p>
<p>基本策略</p>
<ul>
<li><p>预剪枝：提前终止某些分支的生长</p>
<p>对结点在划分前先进行估计</p>
<p>若当前结点的划分不能带来泛化性能提升，则停止划分并将当前结点标记为叶结点</p>
</li>
<li><p>后剪枝：生成一棵完全树，再剪枝</p>
<p>先生成完整决策树</p>
<p>然后自底向上对非叶结点进行考察</p>
<p>若将该结点子树替换为叶结点能带来泛化性能提升，则将该子树替换为叶结点</p>
</li>
</ul>
<p>如何判断泛化性能提升</p>
<p>可用第2章的性能评估方法</p>
<p>例子</p>
<p>假定使用留出法，即预留部分数据用作验证集进行能评估</p>
<p>采用信息增益准则进行划分属性选择</p>
<p>数据集如下(后)</p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212123220313.png" alt="图12"></p>
<p>未剪枝生成的决策树</p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212123238069.png" alt="图13"></p>
<h3 id="4-3-1-预剪枝"><a href="#4-3-1-预剪枝" class="headerlink" title="4.3.1 预剪枝"></a>4.3.1 预剪枝</h3><p>基于信息增益准则，选取属性脐部进行划分</p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212123405308.png" alt="图14"></p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212123414114.png" alt="图15"></p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212123614892.png" alt="图16"></p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212125047036.png" alt="图17"></p>
<ul>
<li>优缺点</li>
</ul>
<p>很多分支都没有展开，降低了过拟合的风险，减少了训练时间开销和测试时间开销</p>
<p>有些分支的当前划分虽不能提升泛化性能，但在其基础上的后续划分却有可能显著提高性能</p>
<p>预剪枝基于贪心本质禁止这些分支展开，给预剪枝决策树带来了欠拟合的风险</p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212125704980.png" alt="图18"></p>
<h3 id="4-3-2-后剪枝"><a href="#4-3-2-后剪枝" class="headerlink" title="4.3.2 后剪枝"></a>4.3.2 后剪枝</h3><p>先生成一棵完整的决策树，其验证集精度测得为$42.9\%$</p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212125803987.png" alt="图19"></p>
<p>考虑结点$6$，若替换为叶结点，根据其上训练样例$\{7,5\}$将其标记为好瓜，测得验证集精度提高至$57.1\%$，于是决定剪枝</p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212125936197.png" alt="图20"></p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212125942374.png" alt="图21"></p>
<p>考虑结点$5$，若将其替换为叶结点，根据其上训练样例$\{6,7,15\}$将其标记为好瓜，测得验证集精度仍为$57.1\%$，可以不剪枝</p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212130015570.png" alt="图22"></p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212130025775.png" alt="图23"></p>
<p>考虑结点$2$，若将其替换为叶结点，根据其上训练样例$\{1,2,3,14\}$，将其标记为好瓜，测得验证集精度提升至$71.4\%$，决定剪枝</p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212130122241.png" alt="图24"></p>
<p>对结点$3$和$1$，先后替换为叶结点，均未测得验证集精度提升，于是不剪枝</p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212130139708.png" alt="图25"></p>
<p>最终后剪枝得到的决策树，其验证集精度为$71.4\%$（原先为$42.9\%$）</p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212130158638.png" alt="图26"></p>
<ul>
<li>优缺点</li>
</ul>
<p>保留了更多的分支，欠拟合风险很小，泛化性能往往优于预剪枝决策树</p>
<p>在生成完全决策树之后进行，自底向上对所有非叶结点进行考察，训练开销大</p>
<h3 id="4-3-3-预剪枝vs-后剪枝"><a href="#4-3-3-预剪枝vs-后剪枝" class="headerlink" title="4.3.3 预剪枝vs.后剪枝"></a>4.3.3 预剪枝vs.后剪枝</h3><ul>
<li>时间开销</li>
</ul>
<p>预剪枝：训练时间开销降低，测试时间开销降低</p>
<p>后剪枝：训练时间开销增加，测试时间开销降低</p>
<ul>
<li>过/欠拟合风险</li>
</ul>
<p>预剪枝：过拟合风险降低，欠拟合风险增加</p>
<p>后剪枝：过拟合风险降低，欠拟合风险基本不变</p>
<ul>
<li>泛化性能：后剪枝通常优于预剪枝</li>
</ul>
<h2 id="4-4-连续与缺失值"><a href="#4-4-连续与缺失值" class="headerlink" title="4.4 连续与缺失值"></a>4.4 连续与缺失值</h2><h3 id="4-4-1-连续值处理"><a href="#4-4-1-连续值处理" class="headerlink" title="4.4.1 连续值处理"></a>4.4.1 连续值处理</h3><ul>
<li><p>问题：</p>
<p>生成决策树基于离散属性，使用连续属性，连续属性的可取值数目不再有限</p>
<p>不能直接根据连续属性的可取值来对结点进行划分</p>
</li>
<li><p>基本思路</p>
<p>连续属性离散化</p>
<p>如何离散化</p>
</li>
<li><p>二分法（C4.5）</p>
</li>
</ul>
<p>设样本集$D$和连续属性$a$，$a$在$D$上出现$n$个不同取值，将值从小到大排序，记为$\{a^1,a^2,\cdots,a^n\}$  </p>
<p>基于划分点$t$可将$D$分为子集$D_t^-$和$D_t^+$，其中$D_t^1$包含不大于$t$的样本，$D_t^ +$包含大于$t$的样本</p>
<p>$n$个属性值可形成$n-1$个候选离散划分点集合</p>
<script type="math/tex; mode=display">
T_a=\{(a^i+a^{i+1}/2|1\leq i\leq n-1\}</script><p>根据划分纯度，选取最优的划分点</p>
<p>如基于信息增益的最优划分点</p>
<script type="math/tex; mode=display">
\begin{align}
t &= \arg\min_{t\in T_a} {\rm Gain}(D,a,t)\\
&= \arg\min_{t\in T_a}\left[{\rm Ent}(D)-\sum_{\lambda\in\{-,+\}}\frac{|D_i^\lambda|}{|D|} {\rm Ent}(D_i^\lambda)\right]
\end{align}</script><p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212133040085.png" alt="图27"></p>
<p>例：基于信息增益的最优划分点</p>
<p>对属性密度，候选划分点集合包含$16$个候选值根据前面的式子可得$t_{\rm 密度}=0.381$</p>
<p>对属性含糖率，候选划分点集合也包含$16$个候选值根据前面的式子可得$t_{\rm 含糖率}=0.126$</p>
<p>然后根据各属性的信息增益最终生成决策树</p>
<p>与离散属性不同，连续属性还可作为其后代结点的划分属性</p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212133245957.png" alt="图28"></p>
<h3 id="4-4-2-缺失值处理"><a href="#4-4-2-缺失值处理" class="headerlink" title="4.4.2 缺失值处理"></a>4.4.2 缺失值处理</h3><ul>
<li><p>属性值缺失现象</p>
<p>不完整样本，即样本的某些属性值缺失</p>
<p>由于属性较多、隐私保护等因素</p>
<p>仅使用无缺失值的样例，对数据信息是极大浪费</p>
</li>
<li><p>使用带缺失值的样例</p>
<p>如何在属性值缺失的情况下进行划分属性选择</p>
<p>给定划分属性，样本在该属性值缺失，如何划分</p>
</li>
</ul>
<p>基本思路：样本赋权，权重划分</p>
<p>给定训练集$D$和属性，表示$D$中属性上没有缺失值的样本子集(问题1)</p>
<p>对于划分属性选择，根据判断属性的优劣</p>
<p>设$a$有$V$个取值，$\tilde{D^v}$表示$\tilde{D}$中属性取值$a^v$的样本子集</p>
<p>$\tilde{D_k}$表示$D$中属于第$k$类$(k=1,2,\cdots,|y|)$的样本子集 </p>
<p>为每个样本$x$赋予一个权重$w_x$，定义</p>
<script type="math/tex; mode=display">
\rho=\sum_{x\in\tilde{D}} \frac{w_x}{\sum_{x\in D}w_x}</script><p>无缺失值样本所占比例</p>
<script type="math/tex; mode=display">
\tilde{p_k}=\frac{\sum_{x\in\tilde{D_k}}w_x}{\sum_{x\in\tilde{D}}w_x},(1\leq k \leq |y|)</script><p>无缺失值样本中第$k$类所占比例</p>
<script type="math/tex; mode=display">
\tilde{r_v}=\frac{\sum_{x\in \tilde{D^v}} w_x}{\sum_{x\in \tilde{D}}w_x},(1\leq v\leq V)</script><p>无缺失值样本属性$a$​取值$a^v$样本所占比例</p>
<p>基本思路：样本赋权，权重划分</p>
<p>对于划分属性选择，根据$\tilde{D}$判断属性$a$的优劣</p>
<p>信息增益计算式变为</p>
<script type="math/tex; mode=display">
\begin{align}
{\rm Gain}(D, a) &= p\times {\rm Gain}(\tilde{D},a)\\[2ex]
& = \rho\times \left[{\rm Ent}(\tilde{D})-\sum_{v=1}^V\tilde{r_v}{\rm Ent}(\tilde{D^v})\right]
\end{align}</script><p>其中</p>
<script type="math/tex; mode=display">
{\rm Ent}(\tilde{D})=-\sum_{k=1}^{|y|}\tilde{p_k}\log_2\tilde{p_k}</script><p>对于属性值缺失(问题2)</p>
<p>若样本$x$的$a$属性取值已知，将$x$划入对应的子结点，且样本权值在子结点中保持为</p>
<p>若样本$x$的$a$属性取值未知，将$x$同时划入所有子结点，且样本权值调整为$\tilde{r_v}w_x$</p>
<p>例子：</p>
<p>学习开始，根结点包含样例集$D$全部样例，权重均为$1$</p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212135812486.png" alt="图29"></p>
<p>属性色泽的信息增益</p>
<p>对于属性色泽，无缺失值样例子集  包含$14$个样例，信息熵为</p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212135824780.png" alt="图30"></p>
<p>令$\tilde{D^1},\tilde{D^2},\tilde{D^3}$分别表示在属性色泽取值为青绿、乌黑、浅白的样本子集，则有</p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212135912940.png" alt="图31"></p>
<p>样本子集$\tilde{D}$上属性色泽的信息增益为</p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212135947643.png" alt="图32"></p>
<p>属性色泽的信息增益</p>
<p>对于属性色泽，样本集D的属性色泽信息增益为</p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212140014945.png" alt="图33"></p>
<p>通过属性纹理的划分</p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212140411213.png" alt="图34"></p>
<p>结点划分过程递归执行，最终生成的决策树</p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212140428075.png" alt="图35"></p>
<h2 id="4-5-多变量决策树"><a href="#4-5-多变量决策树" class="headerlink" title="4.5 多变量决策树"></a>4.5 多变量决策树</h2><p>轴平行划分</p>
<p>单变量决策树在每个非叶结点仅考虑一个划分属性</p>
<p>若把每个属性视为坐标空间中的一个坐标轴，则$d$个属性描述的样本就对应了$d$维空间中的一个数据点</p>
<p>对样本分类意味着在这个坐标空间中寻找不同类样本之间的分类边界</p>
<p>形成的分类边界有一个明显的特点，轴平行，即它的分类边界由若干个与坐标轴平行的分段组成</p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212140541762.png" alt="图36"></p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212140544808.png" alt="图37"></p>
<p>轴平行vs.倾斜</p>
<ul>
<li><p>轴平行分类边界有较好的可解释性</p>
</li>
<li><p>当学习任务所对应的分类边界很复杂时，需要非常多段划分才能获得较好的近似</p>
<p>决策树复杂，要大量的属性测试，预测时间也大</p>
</li>
<li><p>若使用斜的划分边界，决策树将大为简化</p>
<p>多变量决策树 </p>
</li>
</ul>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212140622436.png" alt="图38"></p>
<p>多变量决策树</p>
<ul>
<li><p>能实现斜划分甚至更复杂划分</p>
</li>
<li><p>如斜划分的多变量决策树</p>
<p>非叶结点不是对某个属性，而是对属性的线性组合进行测试，即每个非叶结点是一个线性分类器</p>
</li>
</ul>
<script type="math/tex; mode=display">
\sum_{i=1}^d w_i a_i = t</script><p>​        $w_i$和$t$在该结点所含的样本集和属性集上学得</p>
<ul>
<li>每个非叶结点不是寻找最优划分属性，而是试图建立一个合适的线性分类器</li>
</ul>
<p>如斜划分的多变量决策树</p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212140812789.png" alt="图39"></p>
<p><img src="/2021/12/12/Chapter4%E5%86%B3%E7%AD%96%E6%A0%91/image-20211212140817701.png" alt="图40"></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>npuSE</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>cs231a Course 2:单视图计量</title>
    <url>/2021/12/07/L2/</url>
    <content><![CDATA[<h1 id="Course-2-单视图计量"><a href="#Course-2-单视图计量" class="headerlink" title="Course 2: 单视图计量"></a>Course 2: 单视图计量</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>在之前的课堂讲稿中，我们讨论了如何利用相机的外部和内在特性将点从真实的三维世界转换为数字图像。我们研究了如何在校准装置中使用已知的结构及其相应的图像来推断出这些相机的特性。这一次，我们将研究一个相关的问题：如果我们有一张图像，并知道拍摄图像的相机的属性，我们能恢复三维世界的已知结构吗？然后，我们将更一般地讨论，从单个图像中可以推导出哪些信息。</p>
<h2 id="2-2-二维变换"><a href="#2-2-二维变换" class="headerlink" title="2.2 二维变换"></a>2.2 二维变换</h2><p>为了更好地理解我们如何从图像中学习，我们应该能够首先了解二维空间中的各种转换。</p>
<p>等距变换是指保持距离的变换。在其最基本的形式中，等距法可以被描述为旋转矩阵$R$和平移矩阵$t$​。因此，在数学上，它们被定义为：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
x'\\y'\\1
\end{bmatrix}=\begin{bmatrix}
R & t\\
0 &1
\end{bmatrix}\cdot\begin{bmatrix}
x \\ y \\ 1
\end{bmatrix}</script><p>其中，R是$2\times 2$的矩阵​​，$t$​是一个$2\times1$​的向量，$[x’\,\,\,y’\,\,\, 1]^{\rm T}$​​​​是经过等距变换后得到的点。</p>
<p>附：此处推导</p>
<script type="math/tex; mode=display">
\begin{align}
\begin{bmatrix}
R & t\\
0 &1
\end{bmatrix}\cdot\begin{bmatrix}
x \\ y \\ 1
\end{bmatrix}& =\begin{bmatrix}
R_{11} & R_{12} & t_1\\
R_{21} & R_{22} & t_2\\
0 & 0 & 1
\end{bmatrix}\cdot\begin{bmatrix}
x\\y\\1
\end{bmatrix}\\[2ex]
& =\begin{bmatrix}
R_{11}\cdot x+R_{12}\cdot y + t_1\\
R_{21}\cdot x+ R_{22} \cdot y+ t_2\\
1
\end{bmatrix}=\begin{bmatrix}
x'\\y'\\1
\end{bmatrix}
\end{align}</script><p>相似变换是指保持形状的转换。直观地说，它们可以做所有等距变换加上缩放的事情。在数学上，它们被记为：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
x'\\y'\\1
\end{bmatrix}=\begin{bmatrix}
SR & t\\
0 &1
\end{bmatrix}\cdot\begin{bmatrix}
x \\ y \\ 1
\end{bmatrix},S=\begin{bmatrix}
s & 0 \\
0 & s
\end{bmatrix}</script><p>由于它们保留形状，它们也保持了长度和角度的比例。注意，当$s=1$时，每个等距转换都是相似变换的一种特定形式。然而，反之亦然，但事实并不成立。</p>
<p>仿射变换是保留点、直线和并行性的变换。对于某些向量$v$，一个仿射变换$T$被去定义为：</p>
<script type="math/tex; mode=display">
T(v)=AV+t</script><p>其中，$A$是$R^{n}$的线性变换。在齐次坐标中，仿射变换通常被写成：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
x'\\y'\\1
\end{bmatrix}=\begin{bmatrix}
A & t\\
0 & 1
\end{bmatrix}\cdot\begin{bmatrix}
x \\ y \\ 1
\end{bmatrix}</script><p>从上面的方程可以很容易看到所有的相似之处（因此等距）都是亲缘的特殊情况。</p>
<p>投影变换或同态变换是任何将线映射到线的变换，但不一定保持并行性。在齐次坐标下，射影变换被表示为：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
x'\\y'\\1
\end{bmatrix}=\begin{bmatrix}
A & t\\
v & b
\end{bmatrix}\cdot\begin{bmatrix}
x \\ y \\ 1
\end{bmatrix}</script><p>我们看到该形式是仿射变换的进一步推广，因为额外的自由度与$v$。</p>
<p>尽管没有保持并行性，但射影变换仍然保持了点的共线性，因为它将线映射到线之间。此外，我们还证明了四个共线点的交比在射影变换下保持不变。交叉比在一条直线上取4个点$P_1$​、$P_2$、$P_3$、$P_4$​并进行计算</p>
<script type="math/tex; mode=display">
{\rm cross \,\, radio  }= \frac{||P_3-P_1|| \,\,||P_4-P_2||}{||P_3-P_2||\,\,||P_4-P_1||}\tag{1}</script><p>我们将证明射影变换下交叉比的不变性作为一个类练习。</p>
<h2 id="2-3-在无限处的点和界限"><a href="#2-3-在无限处的点和界限" class="headerlink" title="2.3 在无限处的点和界限"></a>2.3 在无限处的点和界限</h2><p>线条对于确定图像中的结构很重要，所以了解它们在二维和三维中的定义是至关重要的。二维中的一条线可以用齐次向量$l=[a\,\,\,b\,\,\,c]^{\rm T}$来表示。他的比率$-\frac{a}{c}$捕获直线的斜率，比率$-\frac{c}{b}$捕获$y$截距。在形式上，二维线的定义为：</p>
<script type="math/tex; mode=display">
\forall p =\begin{bmatrix}
x\\
y
\end{bmatrix}\in l ,\begin{bmatrix}
a & b &c
\end{bmatrix}\cdot\begin{bmatrix}
x\\
y
\\z
\end{bmatrix}=0\tag{2}</script><p>一般来说，两直线$l$和$l’$将在一个点$x$处相交。该点定义为$l$和$l’$之间的交叉积。</p>
<p>证明：给定两条相交的线$l$​和$l’$​，交点$x$​应该同时位于直线$l$​和$l’$​上。因此，$x^{\rm T}l=0$​，$x^{\rm T}l’=0$​。如果我们设置$x=l×l’$​，那么根据叉积的定义，向量$x$​与向量$l$​和$l’$​都正交。根据正交性的定义，$x^{\rm T}l=0$​​，$x^{\rm T}l’=0$​。因此，$x$的这个定义满足了约束条件。</p>
<p>那么平行线的情况又如何呢？日常的知识期望这些线永远不会相交。然而，这个定义可以重写为这些线相交于无穷大。在齐次坐标下，在无穷远处的一个点被写为$[x\,\,\,y\,\,\,0]^{\rm T}$。回想一下，欧几里得坐标是通过将所有坐标除以最后一个坐标来收集的。在这种情况下，坐标为零，在无穷远处达到一个点。因此，齐次坐标给出了一个很好的确定交集的公式，即使是在平行线的情况下。</p>
<p>现在，让我们考虑两条平行线$l$和$l’$。当两条线平行时，它们的斜率相等，因此$\frac{a}{b}=\frac{a’}{b’}$。如果我们用均匀坐标来计算交点，那么我们可以验证</p>
<script type="math/tex; mode=display">
l\times l' ∝\begin{bmatrix}
b\\-a\\0
\end{bmatrix}=x_{\infty}\tag{1}</script><p>因此，我们证实了我们的直觉，即两条平行线在最终相交。两条平行线在无穷大处的交点也称为理想点。在无穷远处的一个点的一个有趣的特性是，所有斜率相同的$-\frac{a}{b}$的平行线都通过这个理想点，如下图所示：</p>
<script type="math/tex; mode=display">
l^{\rm T}x_{\infty}=\begin{bmatrix}
a & b & c
\end{bmatrix}\cdot\begin{bmatrix}
b\\-a\\0
\end{bmatrix}=0\tag{4}</script><p>无穷点的概念可以推广到定义有限度下的直线。考虑两对或更多对平行线。每一对平行线相交无穷远处$\{x_{∞，1}，…，x_{∞，n}\}$。在无穷远处通过所有这些点的线$l_∞$必须满足$\forall i,l_\infty^{\rm T}x_{\infty,i}=0$。这意味着$l_\infty=\begin{bmatrix} 0 &amp; 0 &amp;c\end{bmatrix}^{\rm T}$。由于$c$是一个任意的值，所以我们可以简单地定义$l_\infty=\begin{bmatrix} 0 &amp; 0 &amp;c\end{bmatrix}^{\rm T}$​​。</p>
<p><img src="https://c1.im5i.com/2021/12/07/cAje5.png" alt="图1：无穷大处的点形成无穷大处的线。"></p>
<p>如果我们将一个一般的射影变换$H$应用到无穷大$p_∞$处的一个点，那么将会发生什么呢？</p>
<script type="math/tex; mode=display">
p'=Hp_{\infty}=\begin{bmatrix}
A & t\\
v & b
\end{bmatrix}\cdot\begin{bmatrix}
1\\1\\0
\end{bmatrix}=\begin{bmatrix}
p_x'\\p_y'\\p_z'
\end{bmatrix}\tag{5}</script><p>请注意，$p’$的最后一个元素可能会变成非零，这表明射影变换通常将在无穷远处的点映射到不再在无穷远处的点。然而，仿射变换的情况并非如此，它将无穷远处的点映射到无穷远处的点：</p>
<script type="math/tex; mode=display">
p'=Hp_{\infty}=\begin{bmatrix}
A & t\\
0 & 1
\end{bmatrix}\cdot\begin{bmatrix}
1\\1\\0
\end{bmatrix}=\begin{bmatrix}
p_x'\\p_y'\\0
\end{bmatrix}\tag{6}</script><p>现在让我们将投影变换$H$应用到线$l$上，得到一个新的线$l’$。通过一条直线的所有点x都必须满足属性$x^{\rm T}l=0$。在转换后的空间中，我们知道线仍然映射到线，这意味着$x’l’=0$。我们可以使用身份属性来得到：</p>
<script type="math/tex; mode=display">
x^{\rm T}I l = x^{\rm T}H^{\rm T}H^{\rm -T}l=0</script><p>如果我们对直线应用射影变换，那么所有的点也被变换，给出$x’=Hx$。这样我们就得到了$x^{\rm T}H^{\rm T}H^{\rm -T}l=x’^{\rm T}l’$，我们发现一条直线的射影变换是$l’=H^{\rm -T}l$。与我们在无穷远处的观测点相似，我们发现无穷远处的一条线的射影变换并不一定映射到无穷远处的另一条线。此外，仿射反式地层仍然将无穷远处的线映射到无穷远处的线。</p>
<h2 id="2-4-消失点和线条"><a href="#2-4-消失点和线条" class="headerlink" title="2.4 消失点和线条"></a>2.4 消失点和线条</h2><p>到目前为止，我们已经在二维中引入了无穷远处的线和点的概念。现在让我们在其相应的齐次坐标中引入三维的等价概念。</p>
<p>在3D世界中，我们现在被介绍到了平面的概念。我们可以将一个平面表示为一个向量$[a\,\,\,b\,\,\,c\,\,\,d]^{\rm T}$，其中$(a，b，c)$形成一个法向量，$d$是从原点到该法向量方向上的平面的距离。在形式上，一个平面被定义为满足的所有点$x$</p>
<script type="math/tex; mode=display">
x^{\rm T}\begin{bmatrix}
a\\b\\c\\d 
\end{bmatrix}=ax_1+ bx_2+cx_3+d=0\tag{7}</script><p>三维平面中的线被定义为两个平面的交点。由于它们有四个自由度（在每个三维空间中都定义了截距位置和斜率），因此它们很难在三维空间中很好地表示。更多细节请参见哈特利和齐瑟曼教科书的第3.2.2节。</p>
<p>然而，点在3D中的定义与在2D中的定义相似。三维中无穷远处的点再次被定义为三维中平行线的交点。此外，如果我们对无穷大$x_∞$处的其中一个点应用一个射影变换，那么我们就可以得到在图像平面上的$p_∞$点中，它在均匀坐标下不再在无穷远处。这个点$p_∞$被称为一个消失点。但是，我们能如何处理消失的点呢？</p>
<p>我们可以推导出三维平行线及其在图像中对应的消失点与相机参数$K$、$R$、$T$之间的有用关系。让我们将$d=(a、b、c)$定义为照相机参考系统中一组三维平行线的方向。这些线与无穷远处的一个点相交，在图像中这样一个点的投影返回消失点$v$，它被定义为：</p>
<script type="math/tex; mode=display">
v=Kd\tag{8}</script><p>我们把上述方程的推导作为一个练习。可改写此方程，提取方向$d$：</p>
<script type="math/tex; mode=display">
d=\frac{K^{-1}v}{||K^{-1}v||}\tag{9}</script><p>如果我们把一个平面$Π$作为一个平行线的超集，每一组平行线在无穷大的一点上相交。在无穷远处通过这一组点的线是在无穷远处与$Π$相关联的$l_∞$处的线。在无穷远处的一条线也被定义为两个平行平面相交的线。投影变换$l_\infty$到图像平面不再是无穷远处的一条线，被称为消失线或视界线$l_{\rm horiz}$。视界线是穿过图像中相应的消失点的一条线。视界线可以计算为：</p>
<script type="math/tex; mode=display">
l_{\rm horiz}= H_p^{-T}l_{\infty}\tag{10}</script><p><img src="https://c1.im5i.com/2021/12/07/cA2iU.png" alt="图2：从一组消失点中计算出的视界线。"></p>
<p>​                                图2：从一组消失点中计算出的视界线。</p>
<p>视界线的概念允许我们像人类一样直观地推断出那些可能在数学上不容易表现出来的图像的属性。例如，在图2中，虽然地面上的线在图像坐标上不是平行的，但我们很自然地理解，它们在3D世界中是平行的。</p>
<p>此外，视界线允许我们计算关于这个世界的有用属性。例如，我们可以推导出三维平面的正规$n$与图像中相应的视界线$l_{\rm horiz}$​之间的有趣关系：</p>
<script type="math/tex; mode=display">
n=K^{\rm T} l_{\rm horiz}\tag{11}</script><p>这意味着，如果我们能够识别与一个平面相关的视平线，如果我们的相机被校准，那么我们就可以估计该平面的方向。在引入有关消失点和线的最后一个性质之前，我们首先需要定义在无穷大$Π_∞$​处的平面。此平面的定义为一组2条或更多的消失线，由向量描述$[0\,\,\,0\,\,\,0\,\,\,1]^{\rm T}$​在均匀坐标。</p>
<p><img src="https://c1.im5i.com/2021/12/07/cAXU8.png" alt="图3：一组两条或多个消失线（蓝色线）定义了位于无穷大$Π_∞$处的平面（黄色平面）。"></p>
<p><img src="https://c1.im5i.com/2021/12/07/cAW66.png" alt="图4：推导出两行之间的夹角。"></p>
<p>最后引入的性质是将三维平面上的线和平面与图像平面上相应的消失点和线联系起来。假设三维中的两对平行线的方向分别为$d_1$​和$d_2$​，并与无穷大$x_{1,∞}$和$x_{2,∞}$处的点相关联。设$v_1$和$v_2$为相应的消失点。然后，我们发现利用余弦规则给出了$d_1$和$d_2$之间的夹角$θ$：</p>
<script type="math/tex; mode=display">
\begin{align}
\cos \theta &=\frac{d_1\cdot d_2}{||d_1||\,\,||d_2||}\\[2ex]
& = \frac{v_1^{\rm T}\omega v_2}{\sqrt{v_1^{\rm T}\omega v_1}\sqrt{v_2^{\rm T}\omega v_2}}
\end{align}\tag{12}</script><p>其中，$\omega=(KK^{\rm T})^{-1}$</p>
<p>我们可以将这个想法进一步扩展到三维平面的情况下，其中我们想在三维平面中关联不同的平面。回想一下，对于任何一个平面，我们都可以计算出它相关的消失线$l_{\rm horiz}$和他的标准化$K^{\rm T}l_{\rm horiz}$。因此，我们可以通过计算每个平面的法向量$n_1$和$n_2$之间的角来确定两个平面之间的角$θ$。我们推导出了分别有消失线$l_1$和$l_2$的两个平面之间的角$θ$：</p>
<script type="math/tex; mode=display">
\begin{align}
\cos\theta &=\frac{n_1\cdot n_2}{||n_1||\,\,||n_2||}\\[2ex]
&=\frac{l_1^{\rm T}w^{-1}l_2}{\sqrt{l_1^{\rm ^{\rm T}}\omega^{-1}l_1}\sqrt{l_2^{\rm T}w^{-1}l_2}}
\end{align}\tag{13}</script><h2 id="2-5-一个单个视图的计量学示例"><a href="#2-5-一个单个视图的计量学示例" class="headerlink" title="2.5 一个单个视图的计量学示例"></a>2.5 一个单个视图的计量学示例</h2><p><img src="https://c1.im5i.com/2021/12/07/cARQw.png" alt="图5：具有针对一对垂直平面的两个消失点的示例设置。"></p>
<p>假设我们可以在一个三维世界的图像中识别出两个平面。另外，让我们假设我们可以在每个平面上识别出一对平行的线。这允许我们估计图像中的两个消失点$v_1$​和$v_2$​​。最后，假设我们知道这些平面在三维空间上是垂直的。在这种情况下，我们从方程$12$中知道，$v_1ωv_2=0$​。</p>
<p>但请回想一下，$ω$依赖于相机矩阵$K$，这在此时可能是未知的。因此，知道这两个消失点足以准确估计相机参数吗？考虑到$K$有$5$个自由度，而$v_1ωv_2=0$只提供了一个约束，我们没有足够的信息来计算$K$。如果我们能为另一个相互正交的平面找到另一个消失的$v_3$呢？然后我们就知道了$v_1ωv_2=v_1ωv_3=v_2ωv_3=0$。由于每对都给出一个约束，我们只得到计算$K$所需的$5$个约束中的$3$个。然而，如果我们假设相机有零偏角和正方形像素，那么我们可以添加所需的额外的两个约束条件。通过这些假设，我们就知道$ω$具有这种形式：</p>
<script type="math/tex; mode=display">
w=\begin{bmatrix}
w_1 & 0 & w_4\\
0 & w_1 & w_5\\
w_4 & w_5 & w_6
\end{bmatrix}\tag{14}</script><p>如果您仔细注意到，在$ω$的定义中有四个变量。然而，我们只能大规模地了解$ω$，这将实际变量的数量减少到三个，从而可以解决它。一旦我们有了$ω$，那么我们就可以使用Cholesky分解来计算$K$。因此，我们已经设法用一张图像来校准照相机！</p>
<p>一旦知道了$K$，我们就可以重建场景的三维几何形状。例如，我们可以计算上述所有平面的方向。因此，一幅图像可以很容易地用来揭示它所捕获的场景的丰富信息。</p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
        <tag>cs231a</tag>
      </tags>
  </entry>
  <entry>
    <title>cs231a Course 5：主动立体声和体积立体声</title>
    <url>/2021/12/07/L5/</url>
    <content><![CDATA[<h1 id="Course-5：主动立体声和体积立体声"><a href="#Course-5：主动立体声和体积立体声" class="headerlink" title="Course 5：主动立体声和体积立体声"></a>Course 5：主动立体声和体积立体声</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>在传统立体声中，主要思想是利用相应的点$p$​和$p’$​通过三角剖分来估计三维点$P$​的位置。这里的一个关键挑战是解决对应问题：我们如何知道一个点$p$​是否真的对应于另一个图像中的一个点$p’$？我们需要处理场景中存在的许多三维点，这进一步强调了这个问题。这些注释的重点将讨论在重建三维结构中工作良好的替代技术。</p>
<h2 id="2-主动立体声"><a href="#2-主动立体声" class="headerlink" title="2 主动立体声"></a>2 主动立体声</h2><p><img src="/2021/12/07/L5/image-20211207214750730.png" alt="图1：将一个点投影到3D空间中的活动立体声设置。"></p>
<p>首先，我们将介绍一种被称为主动立体声的技术，以帮助缓解传统立体声中的对应问题。主动立体声的主要思想是用一个与3D环境交互的设备取代两个相机中的一个，通常通过将图案投射到很容易从第二台相机的物体上识别。这种新的投影仪-相机对定义了与我们引入的相机对相同的超极几何，将替换相机的图像平面替换为投影仪虚拟平面。在图$1$中，投影仪用于将虚拟平面上的一个点$p$投影到三维空间中的物体上，在三维空间$P$中产生一个点。这个3D点$P$应该在第二台相机中作为一个点$p’$被观察到。因为我们知道我们在投影什么(例如，$p$在虚拟平面上的位置，投影的颜色和强度等)，我们可以很容易地在第二台相机$p’$中发现相应的观测结果。</p>
<p><img src="/2021/12/07/L5/2.PNG" alt="图2：将一条直线投射到三维空间中的活动立体声设置。"></p>
<p>主动立体声的一种常见策略是从虚拟平面上投影一条垂直条纹，而不是单个点。这种情况与点的情况非常相似，其中线$s$​被投影到三维空间$S$​中的一条条纹上，并在相机中观察为一条线为$s’$​。如果投影仪和照相机是平行的或校正的，那么我们可以通过简单地将$s’$​与水平的上极线相交来很容易地发现相应的点。从对应关系中，我们可以使用前面的课程注释中介绍的三角测量方法来重建条纹$s$上的所有三维点。通过在场景中滑动线并重复这个过程，我们可以恢复场景中所有可见物体的整个形状。</p>
<p>请注意，该算法工作的一个要求是，前投影器和相机需要校准。有源立体声系统可以使用前面注释中描述的类似技术进行校准。我们可以先使用一个校准装置来校准照相机。然后，通过将已知条纹投影到校准装置上，并利用新校准相机的相应观测结果，建立估计投影仪内在和外部参数的约束条件。一旦校准了，这种主动立体声设置可以产生非常准确的结果。2000年，马克·莱瓦伊和他在斯坦福大学的学生们证明，通过使用精细调整的激光扫描仪，他们可以以亚毫米的精度恢复米开朗基罗的圣塔的形状。</p>
<p>然而，在某些情况下，拥有一个精心调谐的投影仪可能太昂贵或麻烦。另一种使用更便宜得多的设置的方法是利用阴影为我们想要恢复的对象生成活动模式。通过在物体和光源之间的已知位置放置一根棍子，我们可以像以前一样有效地将一条条纹投射到物体上。移动棍子可以让我们在对象上投射不同的阴影条纹，并以类似的方式恢复对象。这种方法虽然便宜得多，但往往会产生不太准确的结果，因为它需要在棒、相机和光源之间进行非常好的校准，同时需要在棒的阴影的长度和厚度之间保持权衡。</p>
<p><img src="/2021/12/07/L5/3.PNG" alt="图3：使用多条彩色线从单个投影中重建对象的活动立体声设置。"></p>
<p>将一条条纹投射到物体上的一个限制是，它相当慢，因为投影仪需要滑动整个物体。此外，这意味着这种方法不能实时捕获变形。一个自然的扩展是尝试从前投影单个帧或图像来重建对象。其想法是将一种已知的不同条纹图案投射到物体的整个可见区域，而不是一条条纹。这些条纹的颜色的设计方式可以从图像中唯一地识别条纹。图3说明了这种多种颜色编码的条纹方法。这个概念为许多现代版本的深度传感器提供了动力，比如最初版本的微软Kinect。在实践中，这些传感器使用红外激光投影仪，使其能够在任何环境光条件下捕获3D视频数据。</p>
<h2 id="3-体积立体声"><a href="#3-体积立体声" class="headerlink" title="3  体积立体声"></a>3  体积立体声</h2><p><img src="/2021/12/07/L5/4.PNG" alt="图4：体积立体声的设置，它从一个有限的工作体积中获取点，并执行一致性检查，以确定三维形状。"></p>
<p>传统立体声和主动立体声方法的另一种替代方法是体积立体声，它扭转了利用对应关系来寻找三维结构的问题。在体积立体声中，我们假设我们试图估计的三维点在一些包含的已知体积范围内。然后，我们将假设的3D点投影到校准的相机中，并验证这些投影是否在多个视图中一致。图4说明了体积立体声问题的一般设置。因为这些技术假设我们想要重建的点包含在有限的体积中，所以这些技术主要用于恢复特定对象的三维模型，而不是恢复场景的模型，这可能是无界的。</p>
<p>任何体积立体方法的主要原则都是，当我们将包含体积中的三维点重新投影到多个图像视图中时，首先定义“一致”的含义。因此，根据一致观察概念的认识，可以引入不同的技术。在这些注释中，我们将简要概述三种主要的技术，即空间雕刻、阴影雕刻和体素着色。        </p>
<h3 id="3-1-空间雕刻"><a href="#3-1-空间雕刻" class="headerlink" title="3.1 空间雕刻"></a>3.1 空间雕刻</h3><p><img src="/2021/12/07/L5/5.PNG" alt="图5：我们想要重建的一个对象的剪影包含了图像中该对象的可见部分的所有像素。视锥是可以投射到图像中对象的剪影中的所有可能点的集合。"></p>
<p>空间雕刻的概念主要来源于观察到一个物体的轮廓提供了关于该物体的几何信息的丰富来源。在多个视图的上下文下，让我们首先设置图5中所示的问题。每个照相机观察一个物体的一些可见的部分，从中可以确定一个轮廓。当投影到图像平面时，该轮廓包含一组像素，称为图像平面中的对象的剪影。空间雕刻最终使用来自多个视图的对象的轮廓来加强一致性。</p>
<p>但是，如果我们没有三维对象的信息，而只有图像，那么我们如何获得剪影信息呢？幸运的是，使用轮廓的一个实际优点是，如果我们能够控制我们想要重建的物体背后的背景，它们就可以很容易地在图像中被检测到。例如，我们可以在对象后面的“绿色屏幕”来轻松地从对象的背景分割对象。</p>
<p>现在我们有了轮廓，我们如何真正使用它们呢？回想一下，在体积立体声中，我们估计了物体可以容纳的一些体积。现在我们介绍视锥的概念，即由相机中心定义的物体表面和图像平面上的包络轮廓。通过构造，保证了物体将完全位于初始体积和视锥内。</p>
<p><img src="/2021/12/07/L5/6.PNG" alt="图6：从多个视图估计对象的过程涉及到恢复视觉船体，这是从每个相机的视觉锥的交集。"></p>
<p>因此，如果我们有多个视图，那么我们可以计算每个视图的视锥。因为，根据定义，该物体位于每个这些视锥中，那么它必须位于这些视锥的交叉处，如图6所示。这样的交叉口通常被称为<strong>可见外壳</strong>。</p>
<p>在实践中，我们首先首先定义一个我们知道对象包含在其中的工作卷。例如，如果我们的相机包围着这个物体，那么我们就可以简单地说，工作体积是被相机所包围的空间的整个内部。我们将这个体积划分为被称为体素的小单位，定义了所谓的体素网格。我们将体素网格中的每个体素，并将其投射到每个视图中。如果该体素在一个视图中不包含在剪影中，那么它将被丢弃。因此，在空间雕刻算法的最后，我们留下了包含在可见外壳中的体素。</p>
<p>空间雕刻方法虽然避免了对应问题，而且相对简单，但仍有很多局限性。空间雕刻的一个限制是，它与网格中的体素数量呈线性关系。当我们减小每个体素的大小时，网格所需的体素数量以立方体的形式增加。因此，为了得到更好的重建，时间大幅增加。然而，可以使用一些方法，如使用八叉树来缓解这个问题。相关的，但更简单的方法包括迭代雕刻，以减少初始体素网格的大小。</p>
<p>​        <img src="/2021/12/07/L5/7.PNG" alt="图7：在体素网格上进行的空间雕刻的结果。该区域是从两个视图中雕刻后重建的对象，而内部的阴影部分是实际的对象。请注意，重建方法总是保守的。"></p>
<p>另一个限制是，空间雕刻的效果取决于视角的数量，剪影的精确性，甚至是我们试图重建的物体的形状。如果视图的数量太少，那么我们最终将对对象的视觉船体进行一个非常松散的估计。随着视图数量的增加，可以通过一致性检查删除更多无关的体素。此外，一致性检查的有效性仅仅是因为我们相信轮廓是正确的。如果剪影过于保守，并且包含的像素超过了必要的数量，那么我们的雕刻可能并不精确。在一个可能更糟糕的情况下，剪影遗漏了实际物体的部分内容，导致了过度雕刻的重建。最后，空间雕刻的一个主要缺点是它不能建模一个对象的某些凹处，如图8所示。</p>
<p><img src="/2021/12/07/L5/8.PNG" alt="图8：空间雕刻不能处理一些凹处，如这里所示，因为它不能雕刻到那个区域，因为这样做将在物体中雕刻。注意，这意味着通常空间雕刻可以处理的唯一凹处是物体上的洞。"></p>
<h3 id="3-2-阴影雕刻"><a href="#3-2-阴影雕刻" class="headerlink" title="3.2 阴影雕刻"></a>3.2 阴影雕刻</h3><p>为了规避空间雕刻所带来的凹度问题，我们需要查看其他形式的一致性检查。确定一个我们可以使用的物体的三维形状的一个重要线索是自阴影的存在。自我阴影是一个对象投射在其自身上的阴影。对于凹形物体的情况，一个物体通常会在凹形区域投射自阴影。</p>
<p>其核心的<strong>阴影雕刻</strong>通过使用自阴影来更好地估计凹度的想法，增强了空间雕刻。如图9所示，阴影雕刻的一般设置与空间雕刻非常相似。物体放置在校准相机查看的转盘中。然而，在相机周围有一组已知位置的灯，其状态可以适当地打开和关闭。这些灯将被用来制造对象投下自己的阴影。</p>
<p><img src="/2021/12/07/L5/9.PNG" alt="图9：阴影雕刻的设置，通过从相机周围的一系列灯中添加一个新的一致性检查来增强空间雕刻。"></p>
<p>如图10所示，阴影雕刻过程从一个初始体素网格开始，通过使用与空间雕刻相同的方法对该网格进行裁剪。然而，在每个视图中，我们都可以打开和关闭相机周围阵列中的每一盏灯。每一种光都会在物体上产生不同的自影。在识别出图像平面上的阴影后，我们就可以在我们裁剪后的体素网格的表面上找到位于阴影的视锥中的体素。这些表面体素允许我们用图像源制作一个新的视觉锥体。然后，我们利用一个有用的事实，即属于两个视锥的体素不能成为对象的一部分，来消除凹度中的体素。</p>
<p>与空间雕刻一样，阴影雕刻的运行时也取决于体素网格的分辨率。运行时随体素网格的分辨率呈立体比例。然而，如果有N个灯，那么阴影雕刻需要的N个+大约是空间雕刻的1倍，因为每个体素都需要投射到相机和每个N个灯中。</p>
<p>总之，阴影雕刻总是能产生一个保守的体积估计，从而更好地重建具有凹度的三维形状。结果的质量取决于视图的数量和光源的数量。这种方法的一些缺点是，它不能处理对象包含反射区或低反照率区域的情况。这是因为在这种情况下无法准确地检测到阴影。</p>
<p><img src="/2021/12/07/L5/10.PNG" alt="图10：阴影雕刻依赖于一种新的一致性检查，它可以去除相机的自阴影视锥和光的视锥中的体素。"></p>
<h3 id="3-3-体素着色"><a href="#3-3-体素着色" class="headerlink" title="3.3 体素着色"></a>3.3 体素着色</h3><p>我们在体积立体图像中介绍的最后一种技术是体素着色，它在空间雕刻中使用颜色一致性而不是轮廓一致性。</p>
<p>如图11所示，假设我们从一个要重建的对象的多个视图中给出了图像。对于每个体素，我们查看它在每个图像中对应的投影，并比较每个投影的颜色。如果这些投影的颜色足够匹配，那么我们将该体素标记为对象的一部分。在空间雕刻中不存在的体素着色的一个好处是，与投影相关的颜色可以转移到体素上，从而给出彩色重建。</p>
<p>总的来说，人们可以使用许多方法来检查颜色一致性。一个例子是在投影之间的颜色相似性之间设置一个阈值。然而，对于任何使用的颜色一致性检查都存在一个关键的假设：被重建的物体必须是<strong>兰伯特式</strong>的，这意味着物体的任何部分的感知亮度不会随着视点位置或姿态而变化。对于非兰伯式的物体，比如那些由高反射性材料制成的物体，我们很容易想象，在实际上是物体一部分的体素上，颜色一致性检查会失败。</p>
<p><img src="/2021/12/07/L5/11.PNG" alt="图11：体素着色的设置，它对一个体素的所有投影的颜色进行了一致性检查。"></p>
<p><img src="/2021/12/07/L5/12.PNG" alt="图12：一个香草体素着色的例子。"></p>
<p>香草体素着色的一个缺点是，它产生的解决方案不一定是唯一的，如图12所示。找到真正的、唯一的解决方案会使通过体素着色进行重建的问题变得复杂。</p>
<p>通过在体素上引入可见性约束，可以消除重构中的歧义，这要求体素以特定的顺序进行遍历。</p>
<p>特别是，我们想要一层一层地遍历体素，从更靠近相机的体素开始，然后发展到更远的体素。当使用此顺序时，我们将执行颜色一致性检查。然后，我们检查该体素是否可以被至少两个摄像机看到，这就构建了我们的可见性约束。如果至少有两个摄像机无法看到该体素，那么它必须被遮挡，因此不能成为物体的一部分。请注意，我们处理更接近体素的顺序允许我们确保保留可以封闭以后处理的体素的体素，以强制这种可见性约束。</p>
<p>总之，体素着色具有同时捕获物体的形状和纹理的优点。一些缺点包括假设对象是兰伯特的，相机不能在特定的位置，因为由于可见性限制，体素需要以特定的顺序处理。</p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
        <tag>cs231a</tag>
      </tags>
  </entry>
  <entry>
    <title>npuSE Chapter 2 图像形成</title>
    <url>/2021/12/07/Chapter2/</url>
    <content><![CDATA[<h1 id="npuSE-Chapter-2-图像形成"><a href="#npuSE-Chapter-2-图像形成" class="headerlink" title="npuSE Chapter 2 图像形成"></a>npuSE Chapter 2 图像形成</h1><h2 id="1-1-针孔相机"><a href="#1-1-针孔相机" class="headerlink" title="1.1.针孔相机"></a>1.1.针孔相机</h2><p>(ref: cs231a notes 1-camera-models)</p>
<h3 id="什么是针孔相机？"><a href="#什么是针孔相机？" class="headerlink" title="什么是针孔相机？"></a>什么是针孔相机？</h3><p><img src="https://s4.ax1x.com/2021/12/07/o6QXGt.png" alt></p>
<p>​                        图1：一个简单的工作相机模型：针孔相机模型。</p>
<p>让我们设计一个简单的照相系统——一个可以在3D世界中记录物体或场景图像的系统。这种相机系统可以通过在3D物体和摄影胶片或传感器之间放置一个小孔圈的屏障来设计。如图1所示，3D对象上的每个点都会向外发出多条光线。如果没有适当的屏障，薄膜上的每一个点都会受到3D物体上每个点发出的光线的影响。由于障碍物，只有一条（或少数）这些光线穿过孔径并击中薄膜。因此，我们可以在三维物体和薄膜上的点之间建立一个一对一的映射。其结果是，通过这种映射，胶片被三维物体的“图像”曝光。这个简单的模型被称为针孔照相机模型。</p>
<p><img src="https://s4.ax1x.com/2021/12/07/o6QOPI.png" alt></p>
<p>​                                图2：针孔照相机模型的正式构造。</p>
<p>针孔照相机的一个更正式的结构如图$2$所示。在这种结构中，薄膜（像）通常被称为图像或视网膜平面。这个孔径被称为针孔$O$或中心相机。图像平面与针孔$O$之间的距离为焦距$f$。有时，视网膜平面被放置在$O$和三维物体之间，距离$O$为$f$。在这种情况下，它被称为虚拟图像或虚拟视网膜平面。请注意，对象在图像平面中的投影与对象在虚拟图像平面中的图像的投影在一定比例内是相同的（相似性）转换。</p>
<h3 id="针孔相机是如何是如何实现的变化？"><a href="#针孔相机是如何是如何实现的变化？" class="headerlink" title="针孔相机是如何是如何实现的变化？"></a>针孔相机是如何是如何实现的变化？</h3><p>现在，我们如何使用针孔照相机呢？设$P=[x\,\,\,\,y\,\,\,\,z]^{\rm T}$​​是针孔相机可见的某些三维物体上的一个点。$P$​​将被映射或投影到图像平面$\Pi’$​​上，得到$P’=[x’\,\,\,y’]^{\rm T}$​​（将三维图形投影到二维平面，因此$P’$比$P$少了一个维度）。类似地，针孔本身也可以投射到图像平面上，给出一个新的点$C’$​。</p>
<p>在这里，我们可以定义一个以针孔$O$​为中心的坐标系$[i\,\,\,j\,\,\,k]$​，使轴$k$​垂直于图像平面并指向它。这个坐标系通常被称为照相机参考系统或照相机坐标系。由$ C’$​和$O$​定义的线称为照相机系统的光轴。</p>
<p>回想一下，该点$P’$​是由三维点$P$​在图像平面$\Pi’$​​上的投影产生而得到的。因此，如果我们推导出三维点$P$​和图像平面点$P’$​之间的关系，我们就可以理解如何理解3D世界把自己印在针孔相机拍摄的图像上。请注意，三角形$P’C’O$​类似于由$P$​、$O$​和$(0、0、z)$​形成的三角形。因此，利用相似三角形定律我们发现：</p>
<script type="math/tex; mode=display">
P'=[x'\,\,\, y']^{\rm T}=[f\frac{x}{z}\,\,\,f\frac{y}{z}]^{\rm T}\tag{1}</script><p><img src="https://s4.ax1x.com/2021/12/07/o6QqIA.png" alt></p>
<p><img src="https://s4.ax1x.com/2021/12/07/o6Qbad.png" style="zoom:50%;"></p>
<p>请注意，我们在这个针孔模型中所做的一个很大的假设是，孔径是一个单点。然而，在大多数真实世界的场景中，我们不能假设孔径可以无限小。钍孔径大小的影响是什么？</p>
<p><img src="https://s4.ax1x.com/2021/12/07/o6Qvxf.png" alt></p>
<p>图3：孔径大小对图像的影响。随着孔径尺寸的减小，图像会变得更清晰，但颜色会更暗。</p>
<p>随着孔径尺寸的增加，通过势垒的光线数量因此增加。随着更多的光线通过，薄膜上的每个点都会受到l的影响光线来自三维空间中的多点，模糊图像。虽然我们可能倾向于试图使孔径尽可能小，但请记住，较小的孔径尺寸会导致光线减少通过，导致更清晰但更暗的图像。因此，我们得出了针孔公式提出的基本问题：我们能开发出拍摄清晰明亮图像的相机吗?</p>
<h2 id="1-2-透镜"><a href="#1-2-透镜" class="headerlink" title="1.2.透镜"></a>1.2.透镜</h2><p>(ref: <span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xNDc4NjI2Nzg=">计算机图形学十六：照相机与透镜(光圈,快门和景深) - 知乎 (zhihu.com)<i class="fa fa-external-link-alt"></i></span>)</p>
<h3 id="透镜概念"><a href="#透镜概念" class="headerlink" title="透镜概念"></a>透镜概念</h3><p><img src="https://img-blog.csdnimg.cn/2020061215504231.png" alt="img"></p>
<p>(1) 所有平行射入透镜的光都会集中于一点，称该点为焦点</p>
<p>(2) 所有从焦点射入透镜的光都会平行射出(光路可逆性)</p>
<p>(3) 焦距可以被随意改变(这里单个透镜当然不行，但在现实中大部分的照相机都是一个透镜组，可以做到焦距随意改变)</p>
<p><img src="https://s4.ax1x.com/2021/12/07/o6QzM8.png" alt></p>
<p>细透镜方程：</p>
<script type="math/tex; mode=display">
\frac{1}{f}=\frac{1}{u}+\frac{1}{v}</script><h3 id="景深"><a href="#景深" class="headerlink" title="景深"></a>景深</h3><p>了解了上述的透镜成像规律之后，让我们一起观察一下景深模糊所产生的的原因：</p>
<p><img src="https://img-blog.csdnimg.cn/20200612160611963.png" alt="img"></p>
<p>当一个传感器平面不在一个物体真正精确的成像平面之上时，便会出现模糊。如上图所示，当传感器平面在根据透镜成像规律所计算出的成像平面Image之后时，一个点经过透镜到传感器上变成了一条线(从三维去看就是一个圆)，因此就出现了模糊，把上图中模糊之后的长度C称为 Circle of Confusion，同样利用三角形相似推导如下：</p>
<script type="math/tex; mode=display">
\frac{C}{A}=\frac{d'}{z_i}=\frac{|z_s-z_i|}{z_i}</script><p>不难看出，C与棱镜长度A成正比，而棱镜长度也与光圈的直径成正比，因此当光圈越大，C也就越大，此时出现的景深模糊也就越明显。</p>
<p><img src="https://s4.ax1x.com/2021/12/07/o6lCZQ.png" alt></p>
<p>​                (左图大光圈，右图小光圈)明显看出右图要更加的清晰。</p>
<p>回顾一下在之前曾提到，光圈大小F-Number值与光圈直径的倒数成正比，更具体来说，$N = \frac{f}{D}$， 即焦距比上直径，因此换算Circle of Confusion当中的光圈直径$A=\frac{f}{N}$，得到如下图当中的式子：<br><img src="https://img-blog.csdnimg.cn/2020061216211332.png" alt="img"></p>
<p>同时这里也给出了不同光圈大小拍照的例子，小光圈锐利，景深模糊不明显，大光圈则有明显的景深模糊</p>
<p>那么回归到本章的主题，Depth of Field，它与景深模糊并不是同一个东西，景深模糊是一种情形，而景深则是一个具体的数值，其具体指</p>
<p>当我们固定一个可以接受的Circle of Confusion C值之后，可以逆向推导出小于该C值的对应的一段距离是多少，这个距离就是景深，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200612164410710.png" alt="img"></p>
<p>孔径如何影响景深？</p>
<p><img src="https://s4.ax1x.com/2021/12/07/o6lPaj.png" alt></p>
<p>孔径小使得更大范围的目标近似聚焦。</p>
<h3 id="视场角-FOV"><a href="#视场角-FOV" class="headerlink" title="视场角(FOV)"></a>视场角(FOV)</h3><p>视场(角)：相机能够拍摄的最大角度范围</p>
<p><img src="https://s4.ax1x.com/2021/12/07/o6lAGq.png" alt></p>
<p>视场角取决于焦距大小</p>
<ul>
<li><p>随着焦距变小，图像能够观察更大角度范围</p>
</li>
<li><p>随着焦距增大，图像能够观察得更远</p>
</li>
</ul>
<p>视场角的定义：</p>
<ol>
<li>在光学仪器中，以光学仪器的镜头为顶点，以被测目标的物像可通过镜头的最大范围的两条边缘构成的夹角，称为视场角。如图一。 视场角的大小决定了光学仪器的视野范围，视场角越大，视野就越大，光学倍率就越小。通俗地说，目标物体超过这个角就不会被收在镜头里。</li>
</ol>
<p><img src="https://www.colorspace.com.cn/wiki/uploads/201801/151493499806jjJQoP.jpg" alt="img"></p>
<ol>
<li>在显示系统中，视场角就是显示器边缘与观察点（眼睛）连线的夹角。例如在图二中，AOB角就是水平视场角，BOC就是垂直视场角。</li>
</ol>
<p>一台相机的FOV</p>
<p><img src="/2021/12/07/Chapter2/image-20211201231725526.png" alt="image-20211201231725526"></p>
<p><img src="https://s4.ax1x.com/2021/12/07/o6liIs.png" alt></p>
<script type="math/tex; mode=display">
φ=\tan^{-1}(\frac{d}{2f})</script><p>可以得到结论：$f$（焦距）越大，FOV越小</p>
<h2 id="1-3-几何模型"><a href="#1-3-几何模型" class="headerlink" title="1.3.几何模型"></a>1.3.几何模型</h2><p>(ref: cs231a notes 1-camera-models)</p>
<p>在本节中，我们将讨论在建模从三维空间到我们所知道的数字图像的投影时必须考虑的参数的细节。所有得到的结果都将使用烟晕但它们也适用于近轴折射模型。</p>
<p>如前所述，三维空间中的一个点P可以被映射（或投影）到图像平面$\Pi’$中的一个二维点$P’$​中。这种$R^3→R^2$映射被称为射影变换。这个投影图像平面上的三维点并不直接对应于我们在实际数字图像中看到的，有几个原因。首先，数字图像中的点通常是用不同的参考中比图像平面上的系统要高。第二，数字图像被划分为离散的像素，而图像平面上的点是连续的。最后，物理传感器可以引入非线性传感器比如对映射的失真。为了解释这些差异，我们将引入一些额外的转换，允许我们将来自三维世界的任何点映射到像素坐标。</p>
<p>图像坐标的原点$C’$在k轴与图像平面相交的图像中心。另一方面，数字图像通常来自于i图像的左下角法师。因此，图像平面上的二维点和图像中的二维点被平移向量偏移$[c_x,c_y]^{\rm T}$。为了适应坐标系统的这种变化，映射现在变为：</p>
<script type="math/tex; mode=display">
P'=
\begin{bmatrix}
x'\\
y'
\end{bmatrix}
=
\begin{bmatrix}
f\frac{x}{z}+c\\
f\frac{y}{z}+c\\
\end{bmatrix}\tag{3}</script><p>下一个效果是，我们必须考虑到数字图像中的点用像素表示，而图像平面上的点用物理测量值表示（例如厘米）。为了适应这个单位的变化，我们必须引入两个新的参数$k$和$l$。这些参数，其单位大概是像“像素/厘米”，对应于图像平面的两个轴上单位的变化。请注意，$k$和$l$可能会有所不同，因为单元元素的长宽比不保证为$1$。如果$k=l$，我们通常说相机有方形像素。我们调整了我们之前的映射为：</p>
<script type="math/tex; mode=display">
P'=
\begin{bmatrix}
x'\\
y'
\end{bmatrix}=
\begin{bmatrix}
fk\frac{x}{z}+c_x\\
fl\frac{y}{z}+c_y
\end{bmatrix}=
\begin{bmatrix}
\alpha\frac{x}{z}+c_x\\
\beta\frac{y}{z}+c_y
\end{bmatrix}\tag{4}</script><p>有没有更好的方法从$P→P’$来表示这个投影？如果这个投影是一个线性变换，那么它可以表示为一个矩阵和输入向量的乘积(在这种情况下，它将是$P$。然而，从方程4中，我们可以看到这个问题$P→P’$不是线性的，因为操作划分了其中一个输入参数(即z)。尽管如此，将这个投影表示为矩阵向量乘积对于未来的推导将是有用的。因此，我们是否可以将我们的变换表示为矩阵向量积，尽管它具有非线性？</p>
<p>解决这个问题的一种方法是改变坐标系。例如，我们引入了一个新的坐标，从而使任何点$P’=(x’、y’)$变成$(x’、y’、1)$。类似地，任何点$P=(x、y、z)$变成$(x、y、z、1)$。这个增广空间被称为齐次坐标系。如前所示，为了将一些欧几里得向量$(v_1，…，v_n)$转换为齐次坐标，我们简单地在一个新的维数中附加一个$1$来得到$(v_1，…，v_n，1)$。请注意，向量及其齐次坐标之间的相等只在最终坐标等于$1$时才会发生。 因此，当从任意齐次坐标$(v_1、…，v_n，w)$转换回时，我们得到欧几里得坐标$(\frac{v_1}{w}，…，\frac{v_n}{w})$。利用齐次坐标，我们可以表示：</p>
<script type="math/tex; mode=display">
P_h'=\begin{bmatrix}
\alpha x+c_x z\\
\beta y+c_y z\\
z
\end{bmatrix}=
\begin{bmatrix}
\alpha & 0 & c_x & 0\\
0 & \beta & c_y & 0\\
0 & 0 & 1 & 0
\end{bmatrix}\cdot
\begin{bmatrix}
x\\
y\\
z\\
1
\end{bmatrix}=
\begin{bmatrix}
\alpha & 0 & c_x & 0\\
0 & \beta & c_y & 0\\
0 & 0 & 1 & 0
\end{bmatrix}P_h\tag{5}</script><p>从这一点起，假设我们将在齐次坐标下工作，除非另有说明。我们将去掉$h$指数，这样任何点$P$或$P’$都可以假定在齐次坐标中。从公式$5$中可以看出，我们可以用矩阵向量关系来表示三维空间中的一个点与其图像坐标之间的关系：</p>
<script type="math/tex; mode=display">
P'=\begin{bmatrix}
x'\\y'\\z
\end{bmatrix}=
\begin{bmatrix}
\alpha & 0 & c_x & 0\\
0 & \beta & c_y & 0\\
0 & 0 & 1 & 0
\end{bmatrix}\cdot
\begin{bmatrix}
x\\y\\z\\1
\end{bmatrix}=
\begin{bmatrix}
\alpha & 0 & c_x & 0\\
0 & \beta & c_y & 0\\
0 & 0 & 1 & 0
\end{bmatrix}\cdot P
=MP\tag{6}</script><p>我们可以把这个转换进一步分解为：</p>
<script type="math/tex; mode=display">
P'=MP=\begin{bmatrix}
\alpha & 0 & c_x \\
0 & \beta & c_y \\
0 & 0 & 1 
\end{bmatrix}\cdot
\begin{bmatrix}
I & 0
\end{bmatrix}\cdot P=
K\cdot\begin{bmatrix}
I & 0
\end{bmatrix}\cdot P\tag{7}</script><p>矩阵$K$通常被称为相机矩阵。这个矩阵包含了一些对表征照相机模型很有用的关键参数。我们的公式目前缺少两个参数：偏度和失真。我们经常说，当相机坐标系倾斜时，图像是倾斜的。在这种情况下，两个轴之间的夹角略大于或小于$90$​度。大多数相机都有零偏态，但由于传感器制造错误，可能会出现一定程度的偏态。证明新的相机矩阵超出了这类的范围，我们给你如下：</p>
<script type="math/tex; mode=display">
K=\begin{bmatrix}
x'\\
y'\\
z
\end{bmatrix}=
\begin{bmatrix}
\alpha & -\alpha\cot \theta & c_x\\
0 & \frac{\beta}{\sin\theta} & c_y
\end{bmatrix}\tag{8}</script><p>我们在这类中引入的大多数方法都忽略了失真效应。因此，我们最终的相机矩阵有$5$个自由度：$2$焦距，$2$偏移量，$1$偏度。</p>
<p>到目前为止，我们已经描述了三维相机参考系统中的一个点$P$到二维图像平面中的一个点$P’$之间的映射。但是如果关于3D世界的信息是不同的呢坐标系？然后，我们需要包括一个额外的转换，将点从世界参考系统到相机参考系统联系起来。这个转换被一个旋转器捕获离子矩阵$R$和平移向量$t$。因此，如果给定世界参考系统$P_w$中的一个点，我们可以计算其相机坐标如下：</p>
<script type="math/tex; mode=display">
P=\begin{bmatrix}
R & T\\
0 & 10
\end{bmatrix} P_w\tag{9}</script><p>将其代入方程（7）并简化给出：</p>
<script type="math/tex; mode=display">
P'=K\begin{bmatrix}
R&T
\end{bmatrix} P_w=MP_w\tag{10}</script><p>这就完成了从任意世界参考系统中的三维点$P$​​到图像平面的映射。我们可以看到投影矩阵$M$​由两种类型的参数组成：固有参数和外部参数$c$​参数。相机矩阵$K$​中包含的所有参数都为固有参数，它们随相机类型的变化而变化。外在参数包括旋转和平移我并不依赖于相机的结构。总的来说，我们发现$3×4$​投影矩阵$M$​有$11$个自由度：$5$个来自内在相机矩阵，$3$个来自外在旋转，$3$个来自外在外在转化。</p>
<h2 id="1-4-光照模型"><a href="#1-4-光照模型" class="headerlink" title="1.4.光照模型"></a>1.4.光照模型</h2><p>(ref: <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NTUyODg2L2FydGljbGUvZGV0YWlscy83OTA4OTQxOA==">(51条消息) 经典光照模型（illumination model）_miaobeihai的博客-CSDN博客_光照模型<i class="fa fa-external-link-alt"></i></span>)</p>
<h3 id="光照模型分类"><a href="#光照模型分类" class="headerlink" title="光照模型分类"></a>光照模型分类</h3><p>光照模型（ illumination model ），也称为明暗模型，用于计算物体某点处的光强（颜色值）。</p>
<h4 id="①-从算法理论基础而言"><a href="#①-从算法理论基础而言" class="headerlink" title="① 从算法理论基础而言"></a>① 从算法理论基础而言</h4><p>从算法理论基础而言，光照模型分为两类：一种是基于物理理论的，另一种是基于经验模型的。</p>
<p>基于物理理论的光照模型，偏重于使用物理的度量和统计方法，比较典型的有 ward BRDF 模型，其中的不少参数是需要仪器测量的，使用这种光照模型的好处是 “ 效果非常真实” ，但是 “计算复杂，实现起来也较为困难 ” </p>
<p>经验模型更加偏重于使用特定的概率公式，使之与一组表面类型相匹配，所以经验模型大都比较简洁，效果偏向理想化。</p>
<p>其实两者之间的界限并不是明确到 “非黑即白” 的地步，无论何种光照模型本质上还是基于物理的，只不过在求证方法上各有偏重而已。</p>
<h4 id="②-从使用角度而言"><a href="#②-从使用角度而言" class="headerlink" title="② 从使用角度而言"></a>② 从使用角度而言</h4><p>从使用角度而言，光照模型分为局部光照模型和全局光照模型。</p>
<p>所谓局部光照模型，是将光照的种类进行分解，在计算时只考虑其中的一种；</p>
<p>而全局光照模型则是考虑到所有的光照种类。</p>
<p>一个比较类似的例子是物理力学，牛顿力学最初是考虑理想状态下的运动方式，无摩擦力；然后慢慢的会在力的条件中考虑到摩擦力因素；接着会学习弹性系数。</p>
<p>总之是将一个原本复杂的过程分解为各种子过程，然后渐进叠加。</p>
<p>当光照射到物体表面时，一部分被物体表面吸收，另一部分被反射，对于透明物体而言，还有一部分光穿过透明体，产生透射光。被物体吸收的光能转化为热量，只有反射光和透射光能够进入眼睛，产生视觉效果。通过反射和透射产生的光波（光具有波粒二相性）决定了物体呈现的亮度和颜色，即反射和投射光的强度决定了物体表面的亮度，而它们含有的不同波长光的比例决定了物体表面的色彩。所以，物体表面光照颜色由入射光、物体材质，以及材质和光的交互规律共同决定。光与物体最基本的交互方式就是反射，遵循反射定律：反射光与入射光位于表面法向两侧，对理想反射面（如镜面），入射角等于反射角，观察者只能在表面法向的反射方向一侧才能看到反射光。 不过世界上并不存在真正的理想反射体，正如物理学中绝对的匀速状态是不存在的。</p>
<h3 id="光源"><a href="#光源" class="headerlink" title="光源"></a>光源</h3><p>环境光 (Ambient Light): 从物体表面所产生的反射光的统一照明，称为环境光或背景光（计算机图形学第二版 389 页）。例如房间里面并没有受到灯光或者太阳光的直接照射，而是由墙壁、天花板、地板及室内各物体之间光的多次反射进行自然照明。通常我们认为理想的环境光具有如下特性：没有空间或方向性；在所有方向上和所有物体表面上投射的环境光强度是统一的恒定值。</p>
<p>由于环境光给予物体各个点的光照强度相同，且没有方向之分，所以在只有环境光的情况下，同一物体各点的明暗程度均一样，因此，只有环境光是不能产生具有真实感的图形效果。</p>
<p>环境光是对光照现象的最简单抽象，局限性很大。它仅能描述光线在空间中无方向并均匀散布时的状态。真实的情况是：光线通常都有方向。点光源是发光体的最简单的模型，光线由光源出发向四周发散。还有一种是平行光，即光线都从同一个方向照射。通过模拟方向光和物体表面的交互模式，可以渲染出具有高真实感（明暗变化、镜面反射等）的三维场景。</p>
<h3 id="漫反射与-Lambert-模型"><a href="#漫反射与-Lambert-模型" class="headerlink" title="漫反射与 Lambert 模型"></a>漫反射与 Lambert 模型</h3><p>粗糙的物体表面向各个方向等强度地反射光，这种等同地向各个方向散射的现象称为光的漫反射（ diffuse reflection ）。产生光的漫反射现象的物体表面称为理想漫反射体，也称为朗伯（ Lambert ）反射体。</p>
<p>粗糙的物体表面向各个方向等强度地反射光，这种等同地向各个方向散射的现象称为光的漫反射（ diffuse reflection ）。产生光的漫反射现象的物体表面称为 理想漫反射体，也称为朗伯（ Lambert ）反射体。</p>
<p>对于仅暴露在环境光下的朗伯反射体，可以用公式(9-1)表示某点处漫反射的光强：</p>
<script type="math/tex; mode=display">
I_{\rm ambiff}=k_dI_a\tag{9-1}</script><p>其中$I$表示环境光强度（简称光强），$k(0&lt;k &lt;1)$为材质对环境光的反射系数，I  ambdiff是漫反射体与环境光交互反射的光强。</p>
<p>即使一个理想的漫反射体在所有方向上具有等量的反射光线，但是表面光强还依赖于光线的入射方向（方向光）。例如，入射光方向垂直的表面与入射光方向成斜角的表面相比，其光强要大的多。这种现象可以用 Lambert 定律进行数学上的量化。即，当方向光照射到朗伯反射体上时，漫反射光的光强与入射光的方向和入射点表面法向夹角的余弦成正比，这称之为 Lambert 定律，并由此构造出 Lambert漫反射模型：</p>
<script type="math/tex; mode=display">
I_{\rm ibiff}=k_dI_i\cos \theta\tag{9-2}</script><p>$I$ 是点光源强度， $θ$ 是入射光方向与顶点法线的夹角，称为入射$(0≤ θ ≤90°)$，ldiff  I 是漫反射体与方向光交互反射的光强。入射角为零时，说明光线垂直于物体表面，漫反射光强最大；$90°$时光线与物体表面平行，物体接收不到任何光线。若 $N$ 为顶点单位法向量， $L$ 表示从顶点指向光源的单位向量（注意，是由顶点指向光源，不要弄反了），则 $cos θ$ 等价于 $N$ 与 $L$ 的点积。所以公式(9-2)可以表示为公式(9-3)：</p>
<script type="math/tex; mode=display">
I_{idiff}=k_dI_i(N\cdot L)\tag{9-3}</script><p>综合考虑环境光和方向来，Lambert光照模型可写为：</p>
<script type="math/tex; mode=display">
I_{diff}=I_{ambdiff}+I_{idiff}=k_dI_a+k_dI_i(N\cdot L)\tag{9-4}</script><h3 id="镜面反射与-Phong-模型"><a href="#镜面反射与-Phong-模型" class="headerlink" title="镜面反射与 Phong 模型"></a>镜面反射与 Phong 模型</h3><p>Lambert 模型较好地表现了粗糙表面上的光照现象，如石灰粉刷的墙壁、纸张等，但在用于诸如金属材质制成的物体时，则会显得呆板，表现不出光泽，主要原因是该模型没有考虑这些表面的镜面反射效果。一个光滑物体被光照射时，可以在某个方向上看到很强的反射光，这是因为在接近镜面反射角的一个区域内，反射了入射光的全部或绝大部分光强，该现象称为镜面反射。故此，Phong Bui Tuong 提出一个计算镜面反射光强的经验模型，称为 phong模型，认为镜面反射的光强与反射光线和视线的夹角相关，其数学表达如公式(9-5)所示：</p>
<script type="math/tex; mode=display">
I_{\rm spec}=k_sI_i(V\cdot R)^{n_i}\tag{9-5}</script><p>$k$​​ 为材质的镜面反射系数，$n$​​ 是高光指数， $V$​​ 表示从顶点到视点的观察方向， $R$​​ 代表反射光方向。高光指数反映了物体表面的光泽程度。$n$​ 越大，反射光越集中，当偏离反射方向时，光线衰减的越厉害，只有当视线方向与反射光线方向非常接近时才能看到镜面反射的高光现象，此时，镜面反射光将会在反射方向附近形成亮且小的光斑；$n$​ 越小，表示物体越粗糙，反射光分散，观察到的光斑区域小，强度弱。反射光的方向 $R$​ 可以通过入射光方向 $L$​ （从顶点指向光源）和物体法向量 $N$​ 求出：</p>
<script type="math/tex; mode=display">
R+L=(2N\cdot L)N\tag{9-6}</script><p>所以有：</p>
<script type="math/tex; mode=display">
R=(2N\cdot L)N - L\tag{9-7}</script><h3 id="Blinn-Phong-光照模型"><a href="#Blinn-Phong-光照模型" class="headerlink" title="Blinn-Phong 光照模型"></a>Blinn-Phong 光照模型</h3><p>Blinn-Phong 光照模型，又称为 Blinn-phong 反射模型（ Blinn–Phong reflection model ）或者 phong 修正模型（ modified Phong reflection model ），是由 Jim Blinn于 1977 年在文章 “Models of light reflection for computer synthesized pictures” 中对传统 phong 光照模型基础上进行修改提出的。和传统 phong 光照模型相比，Blinn-phong 光照模型混合了 Lambert 的漫射部分和标准的高光，渲染效果有时比 Phong  高光更柔和、更平滑，此外它在速度上相当快，因此成为许多 CG 软件中的默认光照渲染方法。此外它也集成在了大多数图形芯片中，用以产生实时快速的渲染。在 OpenGL 和 Direct3D 渲染管线中， Blinn-Phong 就是默认的渲染模型。</p>
<p>phong 光照模型中，必须计算 $V\cdot R$​  的值，其中 $R$​ 为反射光线方向单位向量，$V$ 为视线方向单位向量，但是在 Blinn-phong 光照模型中，用 $N\cdot H$ 的值取代了$V\cdot R$​  。 </p>
<p>Blinn-phong 光照模型公式为：</p>
<script type="math/tex; mode=display">
I_{spec} = k_s I_l(N\cdot H)^{n_s}\tag{9-8}</script><p>其中 N 是入射点的单位法向量， H 是“光入射方向 L 和视点方向 V 的中间向量”，通常也称之为半角向量。注意：半角向量被广泛用于各类光照模型，原因不但在于半角向量蕴含的信息价值，也在于计算半角向量是一件简单、耗时不多的工作。</p>
<script type="math/tex; mode=display">
H=\frac{L+V}{|L+V|}\tag{9-9}</script><p>通常情况下，使用 Blinn-phong 光照模型渲染的效果和 phong 模型渲染的效果没有太大的区别，有些艺术工作者认为 phong 光照模型比 blinn-phong 更加真实，实际上也是如此。 Blinn-phong 渲染效果要更加柔和一些， Blinn-phong 光照模型省去了计算反射光线方向向量的两个乘法运算，速度更快。由于 Blinn-phong和 phong 模型的唯一区别一个使用半角向量，一个使用反射光方向向量。</p>
<h2 id="1-5-感光元件"><a href="#1-5-感光元件" class="headerlink" title="1.5.感光元件"></a>1.5.感光元件</h2><p>(ref: <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hlbGxvWkVYL2FydGljbGUvZGV0YWlscy84MDkwMTc2Ng==">(45条消息) 【图像处理】数码相机工作原理完整解析_Twinkle-CSDN博客<i class="fa fa-external-link-alt"></i></span>)</p>
<p>相比传统的胶片相机来说，数码相机最大的改变就是将感光元件从胶片转变为了CCD/CMOS。传统胶片相机使用银盐作为感光材料，即胶卷作为感光元件，拍摄后还需经过冲洗才能得到最终成片。不但无法第一时间得知最终效果而且在保存上也不太方便。而数码相机的“胶卷”就是其成像感光元件，它与相机融为一体，是数码相机的心脏。感光元件是数码相机的核心，也是最关键的技术。数码相机的发展道路，可以说就是感光元件的发展道路。目前数码相机的核心成像部件有两种：一种是CCD，一种是CMOS。</p>
<p>它们每个感光元件的像素点分别对应图像传感器中的一个像点，由于感光元件只能感应光的强度，无法捕获色彩信息，因此彩色CCD/CMOS图像传感器必须在感光元件上方覆盖彩色滤光片。在这方面，不同的传感器厂商有不同的解决方案，最常用的做法是覆盖RGB红绿蓝三色滤光片，以1：2：1的构成由四个像点构成一个彩色像素（即红蓝滤光片分别覆盖一个像点，剩下的两个像点都覆盖绿色滤光片），这种解决方案就是大名鼎鼎的拜耳滤镜。</p>
<h2 id="1-6-色彩空间"><a href="#1-6-色彩空间" class="headerlink" title="1.6.色彩空间"></a>1.6.色彩空间</h2><p>(ref: <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Npbl9nZWVrL2FydGljbGUvZGV0YWlscy8yMjMyNTIyOQ==">(45条消息) 颜色迁移之一——基础知识（色彩空间及其转换）_Sin_Geek成长の迹-CSDN博客_颜色迁移<i class="fa fa-external-link-alt"></i></span>)</p>
<h3 id="色彩空间"><a href="#色彩空间" class="headerlink" title="色彩空间"></a>色彩空间</h3><p>色彩空间是进行颜色信息研究的理论基础，它将颜色从人们的主观感受量化为具体的表达，为用计算机来记录和表现颜色提供了有力的依据。</p>
<p>一幅图像可以用不同的色彩空间表示，其视觉效果是相同的。但色彩空间的选取对图像的色彩迁移算法是否有效有很大的影响，选择一个合适的色彩空间能够保证色彩迁移结果的准确性。用于彩色图像处理的色彩空间必须同时具有独立性和均匀性。独立性是指色彩空间的三个分量互不影响，对其中某个分量的处理不会导致其它分量相对于人眼感觉发生变化；均匀性是指对色彩空间的每一个分量来说，相同数量的变化能够产生大约相同视觉重要性的变化。</p>
<p>   色彩空间的表达形式是多样的，不同的色彩空间具有不同的特性，但因为不同的色彩空间是同构的，所以它们之间可以互相转换。</p>
<h3 id="RGB色彩空间"><a href="#RGB色彩空间" class="headerlink" title="RGB色彩空间"></a>RGB色彩空间</h3><p>色彩混合的基本定律表明：自然界任何一种色彩均可用红、绿、蓝三种原色光混合产生，这在几何上能够以R、G、B三个互相垂直的轴所构成的空间坐标系统来表示，称为RGB色彩空间。如图1所示，RGB色系坐标中三维空间的三个轴分别于红、绿、蓝三基色相对应，原点对应黑色，离原点最远的顶点对应白色，而立方体内其余各点对应不同的颜色。RGB色彩系统用R、G、B三原色通过不同比例的混合来表示任一种色彩，因而它不能直观地度量色调、饱和度和亮度。而且，各分量之间存在着一定的相关性，它们在大多数情况下都是成正比的，主要表现为自然场景中若某一通道大，则像素的其他通道值也较大。这意味着，如果要对图像的色彩进行处理，常常需要对像素的三个分量同时进行修改才不会影响图像的真实感，这将大大增加颜色调整过程的复杂性。因此，在RGB色彩空间下进行色彩迁移会比较复杂，得到的视觉效果也不自然。</p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
        <tag>npuSE</tag>
      </tags>
  </entry>
  <entry>
    <title>npuSE Chapter 2：模型评估与选择</title>
    <url>/2021/12/10/Chapter2%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<h1 id="Chapter-2：模型评估与选择"><a href="#Chapter-2：模型评估与选择" class="headerlink" title="Chapter 2：模型评估与选择"></a>Chapter 2：模型评估与选择</h1><h2 id="2-1-经验误差与过拟合"><a href="#2-1-经验误差与过拟合" class="headerlink" title="2.1 经验误差与过拟合"></a>2.1 经验误差与过拟合</h2><h3 id="2-1-1-基础概念"><a href="#2-1-1-基础概念" class="headerlink" title="2.1.1 基础概念"></a>2.1.1 基础概念</h3><ol>
<li>错误率：分类错误的样本数占样本总数的比例</li>
</ol>
<script type="math/tex; mode=display">
E=\frac{\alpha}{m}</script><p>其中，$m$为样本数，$\alpha$分类错误数</p>
<ol>
<li><p>精度：1-错误率</p>
</li>
<li><p>误差：学习器的实际预测输出与样本的真实输出之间的差异</p>
<p>​    ① 训练误差(经验误差)：学习器在训练集上的误差<br>​    ② 泛化误差：在新样本上的误差.</p>
</li>
<li><p>目标：设计得到泛化误差小的学习器</p>
</li>
</ol>
<p>由于我们事先不知道新样本，只能努力使经验误差最小</p>
<ol>
<li>过拟合：学习器把训练样本学得太好，可能将训练样本不太一般的特性学到，当作一般性质，从而导致泛化性能下降</li>
</ol>
<p>过拟合产生的原因：学习能力过于强大，无法彻底避免，只是缓解，减小其风险</p>
<ol>
<li>欠拟合：对训练样本的一般性质尚未学好</li>
</ol>
<p>欠拟合产生的原因：学习能力低下</p>
<p>过拟合与欠拟合举例：</p>
<p><img src="/2021/12/10/Chapter2%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/image-20211209210639254.png" alt="图1"></p>
<h3 id="2-1-2-模型选择"><a href="#2-1-2-模型选择" class="headerlink" title="2.1.2 模型选择"></a>2.1.2 模型选择</h3><p>问题：</p>
<ul>
<li>在现实任务中，有多种学习算法、不同的参数配置可供选择，如何选用</li>
<li>选择泛化误差最小的那个模型，但无法直接获得泛化误差</li>
<li>无法直接获得泛化误差</li>
<li>训练误差由于过拟合现象而不适合作为标准</li>
</ul>
<p>四个关键：</p>
<ul>
<li>评估方法，如何获得测试结果</li>
<li>性能度量，如何评估性能优劣</li>
<li>比较检验，如何判断实质差别</li>
<li>分析说明，如何解释泛化性能</li>
</ul>
<p>实验测试</p>
<p>通过实验测试对学习器的泛化误差进行评估</p>
<ul>
<li>使用测试集测试学习器对新样本的判别能力</li>
<li>以测试集上的测试误差作为泛化误差的近似</li>
</ul>
<p>测试集</p>
<ul>
<li>从样本真实分布中独立同分布采样而得</li>
<li>尽可能与训练集互斥，即不在训练集中出现或未使用过</li>
<li>只有一个包含$m$个样例的数据集$D=\{(x_1,y_1),\cdots,(x_m,y_m)\}$，既要训练，又要测试</li>
</ul>
<p>如何产生出训练集S和测试集T</p>
<ul>
<li>留出法 (hold-out)</li>
<li>交叉验证法 (cross validation)</li>
<li>自助法 (bootstrap)</li>
</ul>
<h2 id="2-2-评估方法"><a href="#2-2-评估方法" class="headerlink" title="2.2 评估方法"></a>2.2 评估方法</h2><h3 id="2-2-1-留出法"><a href="#2-2-1-留出法" class="headerlink" title="2.2.1 留出法"></a>2.2.1 留出法</h3><p>将数据集$D$划分为两个互斥的集合，一个作为训练集$S$，另一个作为测试集$T$</p>
<ul>
<li><p>训练集、测试集划分的分布</p>
<p>训练集、测试集划分要尽可能保持数据分布的一致性</p>
<p>​    避免因数据划分引入额外的偏差而对最终结果产生影响</p>
<p>​    如保留类别比例的采样方式，通常称为分层采样</p>
</li>
<li><p>在给定训练/测试集的样本比例后，仍存在多种划分方式对初始数据集D进行分割</p>
<p>​    如排序划分、随机划分</p>
</li>
<li><p>单次使用留出法得到的估计结果往往不够稳定</p>
<p>​    采用若干次随机划分、重复进行实验评估后取平均值作为留出法的评估结果</p>
</li>
<li><p>将数据集$D$​划分为两个互斥的集合，一个作为训练集$S$​，另一个作为测试集$T$​</p>
<p>  划分训练集、测试集的大小</p>
<p>  ​    训练集$S$大测试集$T$小，训练出的模型更接近于用$D$训练出的模型，但评估结果可能不够准确</p>
<p>  ​    训练集$S$小测试集$T$大，被评估的模型与用$D$训练出的模型有较大差别，降低了评估结果的保真性</p>
<p>  ​    没有完美的解决方案，常用$\frac{2}{3}\sim\frac{4}{5}$的样本用于训练，剩余用于测试</p>
</li>
</ul>
<p><img src="/2021/12/10/Chapter2%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/image-20211209211558217.png" alt="图2"></p>
<h3 id="2-2-2-交叉验证法-k折交叉验证"><a href="#2-2-2-交叉验证法-k折交叉验证" class="headerlink" title="2.2.2 交叉验证法(k折交叉验证)"></a>2.2.2 交叉验证法(k折交叉验证)</h3><p>将数据集$D$划分为$k$​个大小相似的互斥子集，每个子集尽可能保持数据分布的一致性。每次用$k-1$个子集的并集作为训练集，余下的子集作为测试集，可得$k$组训练/测试集，最终返回的是$k$个测试结果的均值。</p>
<p><img src="/2021/12/10/Chapter2%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/image-20211209211935928.png" alt="图3"></p>
<p>评估结果的稳定性和保真性在很大程度上取决于$k$的取值。</p>
<ul>
<li><p>常用$10$折交叉验证</p>
</li>
<li><p>$k$折交叉验证通常要随机使用不同的划分重复$p$次</p>
<p>​    最终的评估结果是这$p$次$k$折交叉验证结果的均值，常见$10$次$10$折交叉验证</p>
</li>
<li><p>$k=m$，称为留一法</p>
<p>使用的训练集与初始数据集相比只少了一个样本，使得绝大多数情况下实际评估的模型与期望评估的用$D$​训练出的模型很相似，评估结果往往被认为比较准确。</p>
<p>使用留一法缺陷：数据集比较大时，训练计算开销大。留一法的估计结果未必永远比其他评估方法准确，没有免费的午餐</p>
</li>
</ul>
<h3 id="2-2-3-自助法-包外估计"><a href="#2-2-3-自助法-包外估计" class="headerlink" title="2.2.3 自助法(包外估计)"></a>2.2.3 自助法(包外估计)</h3><p>留出法和交叉验证法，保留一部分样本用于测试，实际评估模型所使用训练集比$D$​小。</p>
<ul>
<li>会引入因训练样本规模不同而导致的估计偏差</li>
<li>留一法影响较小，但计算复杂度太高</li>
</ul>
<p>以自助采样法为基础</p>
<ul>
<li>每次随机从$D$中挑选一个样本，将其拷贝放入$D’$</li>
<li>再将该样本放回初始数据集$D$中，使得该样本在下次采样时仍有可能被采到</li>
</ul>
<p><img src="/2021/12/10/Chapter2%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/image-20211209212733547.png" alt="图4"></p>
<p>重复执行$m$次后，得到包含$m$个样本的数据集$D’$，这就是自助采样的结果</p>
<ul>
<li>$D$中有一部分样本会在$D’$中多次出现，而另一部分样本不出现</li>
<li>$m$次采样中始终不被采到的概率是$(1-\frac{1}{m})^m$，取极限$\lim_{m\to\infty}(1-\frac{1}{m})^m=\frac{1}{e}\approx0.368$</li>
</ul>
<p>$D’$用作训练集，$D-D’$用作测试集</p>
<ul>
<li>训练集与原样本集同规模</li>
<li>数据分布有所改变</li>
</ul>
<p>优缺点：</p>
<ul>
<li>在数据集较小、难有效划分训练、测试集时有用</li>
<li>能产生多个不同的训练集，对集成学习等方法有很大的好处</li>
<li>产生的数据集改变了初始分布，会引入估计偏差</li>
</ul>
<h3 id="2-2-4-调参与最终模型"><a href="#2-2-4-调参与最终模型" class="headerlink" title="2.2.4 调参与最终模型"></a>2.2.4 调参与最终模型</h3><p>调参</p>
<ul>
<li><p>在进行模型评估与选择时，除了要对学习算法进行选择，还需对算法参数进行设定，称为调参</p>
</li>
<li><p>参数</p>
<p>模型的参数，一般由学习确定</p>
<p>算法的参数，一般由人工设定，亦称“超参数”</p>
</li>
<li><p>参数调节对最终模型性能有关键性影响</p>
</li>
<li><p>设定不同参数先产生若干模型，然后基于某种评估方法选择最佳参数</p>
<p>通常很困难：参数多，实数取值范围</p>
<p>常用方法：设定取值范围，设定变化步长</p>
</li>
</ul>
<p>最终模型</p>
<ul>
<li>在模型评估选择过程中，只用了一部分数据训练模型。在模型选择完成后，学习算法和参数配置已定，此时用数据集$D$重新训练而得到的模型</li>
</ul>
<p>测试数据与验证数据</p>
<ul>
<li><p>测试、验证经常混用，但是也有区分</p>
</li>
<li><p>测试数据集</p>
<p>实际中用到的数据</p>
<p>测试是对真实结果说的</p>
</li>
<li><p>验证集</p>
<p>模型评估与选择中用于评估测试的数据集</p>
<p>验证是对你的期望说的</p>
</li>
<li><p>训练数据=训练集+验证集</p>
</li>
<li>数据集=训练数据+测试数据(集)</li>
</ul>
<h2 id="2-3-性能度量"><a href="#2-3-性能度量" class="headerlink" title="2.3 性能度量"></a>2.3 性能度量</h2><p>性能度量</p>
<ul>
<li><p>衡量模型泛化能力的评价标准</p>
</li>
<li><p>在预测任务中，给定样例集$D=\{(x_1,y_1),…, (x_m,y_m)\}$，其中$y_i$是真实标记。要评估学习器$f(x)$的性能，就要把学习器预测结果$f(x)$与真实标记$y$进行比较</p>
</li>
<li><p>使用不同的性能度量会导致不同的评判结果</p>
<p>评判模型好坏，不仅取决于算法和数据，还取决于任务需求</p>
</li>
</ul>
<p>均方误差</p>
<script type="math/tex; mode=display">
E(f;D)=\frac{1}{m}\sum_{i=1}^m[f(x_i)-y_i]^2</script><p>其中，$D$​为数据集，$y_i$​​示例真实标记，$f$​学习器，$f(x_i)$预测结果</p>
<p>一般形式：</p>
<script type="math/tex; mode=display">
E(f;D)=\int_{x\sim D}[f(x)-y]^2 p(x){\rm d}x</script><p>用于回归任务。</p>
<p>后面主要介绍分类任务常用的性能度量。</p>
<h3 id="2-3-1-错误率与精度"><a href="#2-3-1-错误率与精度" class="headerlink" title="2.3.1 错误率与精度"></a>2.3.1 错误率与精度</h3><p>错误率</p>
<ul>
<li>分类错误的样本数占样本总数的比例</li>
</ul>
<script type="math/tex; mode=display">
E(f;D)=\frac{1}{m}\sum_{i=1}^mI\left(f(x_i)\neq y_i\right)</script><p>​    一般形式：</p>
<script type="math/tex; mode=display">
E(f;D)=\int_{x\sim D}I\left(f(x_i)\neq y_i\right)p(x){\rm d}x</script><p>精度</p>
<ul>
<li>分类正确的样本数占样本总数的比例</li>
</ul>
<script type="math/tex; mode=display">
{\rm acc}(f;D)=\frac{1}{m}\sum_{i=1}^m\left(f(x_i)= y_i\right)=1-E(f;D)</script><p> 一般形式：</p>
<script type="math/tex; mode=display">
{\rm acc}(f;D)=\int_{x\sim D}I (f(x)=y)p(x){\rm d}x=1-E(f;D)</script><p>既适用于二分类任务，也适用于多分类任务</p>
<p>错误率和精度常用，但不能满足所有需求</p>
<ul>
<li><p>如问题是“挑出的西瓜中有多少比例是好瓜”，或者“所有好瓜中有多少比例被挑了出来”</p>
<p>错误率显然就不够用，需要使用其他的性能度量</p>
</li>
</ul>
<h3 id="2-3-2-查准率、查全率"><a href="#2-3-2-查准率、查全率" class="headerlink" title="2.3.2 查准率、查全率"></a>2.3.2 查准率、查全率</h3><p>混淆矩阵</p>
<p>对于二分类，将样例根据真实类别与学习器预测类别划分为真正例、假正例、真反例、假反例四种，令TP,FP,TN,FN表示对应的样例数，可构建</p>
<p><img src="/2021/12/10/Chapter2%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/image-20211209214600406.png" alt="图5"></p>
<p>查准率：</p>
<script type="math/tex; mode=display">
P=\frac{TP}{TP+FP}</script><p>查全率：</p>
<script type="math/tex; mode=display">
R=\frac{TP}{TP+FN}</script><p>查准率和查全率是一对矛盾的度量</p>
<ul>
<li><p>查准率高时，查全率往往偏低</p>
<p>如希望选出的瓜中好瓜比例尽可能高，则可只挑选最有把握的瓜，但这样就难免会漏掉不少好瓜，使得查全率较低</p>
</li>
<li><p>查全率高时，查准率往往偏低</p>
<p>如希望将好瓜尽可能多地选出来，则可通过增加选瓜的数量来实现，如果将所有西瓜都选上，那么所有的好瓜也必然都被选上了，但这样查准率就会较低</p>
</li>
<li><p>有没有办法找到两者相对都高的模型</p>
<p>P-R图、平衡点BEP</p>
</li>
</ul>
<p>P-R图、平衡点BEP</p>
<ul>
<li>根据学习器的预测结果按正例可能性大小对样例进行排序，并逐个把样本作为正例进行预测</li>
<li>计算出当前的查全率、查准率作图，简称P-R曲线</li>
<li>查准率=查全率时，就是平衡点(BEP)</li>
</ul>
<p><img src="/2021/12/10/Chapter2%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/image-20211209214842201.png" alt="图6"></p>
<ul>
<li><p>P-R图显示学习器在样本总体上的查全率、查准率</p>
</li>
<li><p>一学习器的P-R曲线被另一学习器的曲线完全包住</p>
<p>可断言后者的性能优于前者</p>
</li>
<li><p>两学习器的P-R曲线交叉</p>
<p>难以一般性地断言两者孰优孰劣</p>
<p>比较合理的判据是比较P-R曲线下面积的大小</p>
<p>​    不易估算，设计综合查准率、查全率的性能度量</p>
<p>​    如平衡点BEP</p>
<p>​    过于简单</p>
</li>
</ul>
<p><img src="/2021/12/10/Chapter2%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/image-20211209220255153.png" alt="图7"></p>
<p>F1度量</p>
<ul>
<li>BEP还是过于简化，常用的是F1度量</li>
<li>是基于查准率与查全率的调和平均</li>
</ul>
<script type="math/tex; mode=display">
F_1=\frac{2\times P\times R}{P+R}=\frac{2\times TP}{ {\rm 样例数据}+TP-TN}</script><p>更重视小值</p>
<ul>
<li>若对查准率、查全率重视程度不同，有不同偏好，定义F1的一般形式，加权调和平均</li>
</ul>
<script type="math/tex; mode=display">
F_\beta=\frac{(1—\beta^2)\times P\times R}{(\beta ^2\times P)+R}</script><p>​    $\beta &gt;1$时查全率有更大影响，$\beta &lt; 1$时查准率有更大影响</p>
<p>宏与微查准率、查全率、F1</p>
<ul>
<li><p>有时有多个二分类混淆矩阵，如多次训练测试、或多分类，得到多个混淆矩阵</p>
<p>如何估计算法的全局性能</p>
</li>
<li><p>两种方法</p>
<p>宏方法：先在各混淆矩阵上分别计算，再计算平均值</p>
<script type="math/tex; mode=display">
{\rm macro}-P=\frac{1}{n}P_i</script><script type="math/tex; mode=display">
{\rm macro} - R=\frac{1}{n}\sum_{i=1}^n R_i</script><script type="math/tex; mode=display">
{\rm macro}-F_1=\frac{2\times{\rm macro}-P\times {\rm macro}-R} { {\rm macro}-P+{\rm macro}-R}</script><p>微方法：将各混淆矩阵对应元素平均，再对均值计算</p>
</li>
</ul>
<script type="math/tex; mode=display">
{\rm micro}-P=\frac{\overline{TP}}{\overline{TP}+\overline{FP}}</script><script type="math/tex; mode=display">
{\rm micro}-R=\frac{\overline{TP}}{\overline{TP}+\overline{TN}}</script><script type="math/tex; mode=display">
{\rm micro}-F_1=\frac{2\times {\rm mircro-P\times {\rm micro}-R} } { {\rm micro}- P+{\rm micro}-R}</script><h3 id="2-3-3-ROC-受试者工作特征-、AUC"><a href="#2-3-3-ROC-受试者工作特征-、AUC" class="headerlink" title="2.3.3 ROC(受试者工作特征)、AUC"></a>2.3.3 ROC(受试者工作特征)、AUC</h3><p> 很多学习器产生实值或概率预测，然后将预测值与分类阈值比较分类。</p>
<ul>
<li><p>这个实值或概率预测结果的好坏，直接决定了学习器的泛化能力</p>
</li>
<li><p>可将测试样本进行排序</p>
<p>最可能是正例的排在最前面，最不可能是正例的排在最后面</p>
</li>
<li><p>分类就相当于以某个截断点将样本分为两部分</p>
</li>
<li><p>不同的应用任务，采用不同的截断点</p>
<p>重视查准率选靠前位置的截断点，重视查全率选靠后的截断点</p>
</li>
<li><p>需要综合考虑学习器在不同任务下的期望泛化性能的好坏</p>
</li>
</ul>
<p>ROC(受试者工作特征)曲线</p>
<ul>
<li>表现学习器在不同任务下的“期望泛化性能”</li>
<li>纵轴：真正例率TPR</li>
</ul>
<script type="math/tex; mode=display">
{\rm TPR}=\frac{\rm TP} { { \rm TP} + {\rm FN} }</script><ul>
<li>横轴：假正例率FPR</li>
</ul>
<script type="math/tex; mode=display">
{\rm TPR}=\frac{\rm FP}{ {\rm TN} + {\rm FP} }</script><ul>
<li>对角线：随机猜测模型</li>
<li>点$(0,1)$：理想模型</li>
</ul>
<p><img src="/2021/12/10/Chapter2%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/image-20211209225318228.png" alt="图8"></p>
<ul>
<li><p>现实中测试样例有限，近似绘制ROC图</p>
<p>给定$m^+$正例和$m^-$反例，根据学习器预测结果排序</p>
<p>然后把分类阈值设为最大，坐标$(0,0)$处标记</p>
<p>将分类阈值依次设为每个样例的预测值，计算标记</p>
<p>​    当前为真正例，标记点坐标为$(x,\frac{y+1}{m^+})$</p>
<p>​    当前为假正例，标记点坐标为$(\frac{x+1}{m^-},y)$</p>
<p>​        $(x,y)$为前一个标记点坐标</p>
<p>用线段连接相邻点即得</p>
</li>
</ul>
<p><img src="/2021/12/10/Chapter2%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/image-20211209225619838.png" alt="图9"></p>
<p>ROC、AUC</p>
<p>ROC(受试者工作特征)曲线</p>
<ul>
<li>对学习器比较</li>
</ul>
<p>若一学习器的ROC曲线被另一曲线完全包住，则后者性能优于前者</p>
<p>若两个ROC曲线交叉，则难以比较</p>
<p>​    较为合理的判据是比较ROC曲线下的面积</p>
<ul>
<li><p>AUC（Area Under the ROC Curve）</p>
<p>​    估算：ROC曲线由坐标点连接形成</p>
<script type="math/tex; mode=display">
{\rm AUG}=\frac{1}{2}\sum_{i=1}^{m-1}(x_{i+1}-x_i)(y_i+y_{i+1})</script><p>​    用排序损失表示</p>
<p>$m^ +$​​个正例，$m^ -$​个反例，$D^ +$​正例集合，$D$反例集合</p>
<script type="math/tex; mode=display">
l_{\rm rank}=\frac{1}{m^ + m^ -}\sum_{x^+\in D^+}\sum_{x^-\in D^-} \left\{I\left[f(x^+)<f(x^-)\right]+\frac{1}{2}I\left[f(x^+)=f(x^-)\right] \right\}</script><script type="math/tex; mode=display">
{\rm AUC}=1-l_{\rm rank}</script><p>代价敏感错误率与代价曲线</p>
<p>有时不同类型的错误会造成不同的损失，此时可为错误赋予“非均等代价”</p>
<p>二分类可根据任务领域知识设定代价矩阵</p>
<p>​    $\cos t_{ij}$表示将第$i$类样本预测为第$j$类样本的代价</p>
</li>
</ul>
<p><img src="/2021/12/10/Chapter2%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/image-20211209231004633.png" alt="图10"></p>
<p>​        代价敏感错误率(归一化的总体代价)</p>
<script type="math/tex; mode=display">
E(f;D;\cos t)=\frac{1}{m}\left(\sum_{x_i\in D^+}I[f(x_i)\neq y_i]\times\cos t_{01}+\sum_{x_i\in D^-}I[f(x_i)\neq y_i]\times \cos t_{10}\right)</script><p>​        代价曲线与期望总体代价</p>
<ul>
<li><p>非均等代价下代价曲线反映学习器期望总体代价</p>
</li>
<li><p>横轴：正例概率代价，取值为$[0,1]$</p>
</li>
</ul>
<script type="math/tex; mode=display">
P(+)\cos t=\frac{p\times \cos t_{01}}{p\times \cos t_{01}+(1-p)\times\cos t_{01}}</script><p>其中，$p$为样例为正例的概率</p>
<ul>
<li>纵轴：归一化代价，取值为$[0,1]$</li>
</ul>
<script type="math/tex; mode=display">
\cos t_{\rm norm}=\frac{FNR\times p\times \cos t_{01}+FPR\times (1-p)\times \cos t_{10}}{p\times \cos t_{01} + (1-p)\times \cos t_{10}}</script><p>​        其中$FPR$假正例率，$FNR=1-TPR$是假反例率</p>
<p>代价曲线与期望总体代价</p>
<ul>
<li><p>绘制</p>
<p>ROC曲线每一点(TPR,FPR)对应代价平面上的一条线段</p>
<p>​    计算假反利率FNR=1-TPR</p>
<p>在代价平面上绘制从(0,FPR)到(1,FNR)的线段</p>
<p>​    线段下的面积即表示了该条件下的期望总体代价</p>
<p>取所有线段的下界，围成的面积即为在所有条件下学习器的期望总体代价</p>
</li>
</ul>
<p><img src="/2021/12/10/Chapter2%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/image-20211209232215675.png" alt="图11"></p>
<h2 id="2-4-比较检验"><a href="#2-4-比较检验" class="headerlink" title="2.4 比较检验"></a>2.4 比较检验</h2><ul>
<li><p>取得某种性能度量评估结果后，能否直接比较学习器</p>
<p>​    比较的是泛化性能，获得的是测试性能</p>
<p>​        测试性能不等于泛化性能</p>
<p>​    测试性能随着测试集的变化而变化</p>
<p>​        大小、样例的不同</p>
<p>​    很多机器学习算法本身有一定的随机性</p>
<p>​        多次运行结果会不同</p>
</li>
</ul>
<ul>
<li><p>统计假设检验 (hypothesis test) 为学习器性能比较提供了重要依据</p>
<p>​    若在测试集上观察到学习器A比B好，A的泛化性能是否在统计意义上优于B，以及这个结论的把握有多大</p>
</li>
</ul>
<h3 id="2-4-1-单个学习器泛化性能的假设进行检验"><a href="#2-4-1-单个学习器泛化性能的假设进行检验" class="headerlink" title="2.4.1 单个学习器泛化性能的假设进行检验"></a>2.4.1 单个学习器泛化性能的假设进行检验</h3><ul>
<li>泛化错误率与测试错误率未必相同，但二者接近的可能性比较大，可根据测试错误率估推出</li>
<li>根据测试错误率$\hat{\varepsilon}$​​估计推出泛化错误率$\varepsilon$​​的分布</li>
</ul>
<script type="math/tex; mode=display">
P(\hat{\varepsilon};\varepsilon)=\begin{pmatrix}m\\ \hat{\varepsilon}\times m\end{pmatrix}\varepsilon^{\hat{\varepsilon}\times m}(1-\varepsilon)^{m-\hat{\varepsilon}\times m}</script><ul>
<li><p>给定测试错误率，可得$P(\hat\varepsilon;\varepsilon)$在$\varepsilon=\hat\varepsilon$时最大，这符合二项(binomial)分布</p>
</li>
<li><p>可使用“二项检验”</p>
</li>
</ul>
<p>在$\alpha$的显著度下，假设$1-\alpha$不能被拒绝，即能以$\varepsilon\leq \varepsilon_0$的的的置信度认为，学习器的泛化错误率不大于$\varepsilon_0$​；否则该假设可被拒绝，即在$\alpha$​的显著度下可认为学习器的泛化错误率大于$\varepsilon_0$</p>
<p><img src="/2021/12/10/Chapter2%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/image-20211210114141388.png" alt="图12"></p>
<h3 id="2-4-2-交叉验证-t-检验（基于成对-t-检验）"><a href="#2-4-2-交叉验证-t-检验（基于成对-t-检验）" class="headerlink" title="2.4.2 交叉验证$t$检验（基于成对$t$检验）"></a>2.4.2 交叉验证$t$检验（基于成对$t$检验）</h3><p>使用$k$折交叉验证</p>
<ul>
<li>设使用$k$折交叉验证法得到两学习器的测试错误率分别为$\varepsilon_i^A$，$\varepsilon_i^B$</li>
<li>基本思想是对每对结果求差，若两个学习器性能相同，则差值均值应为零</li>
<li>方法：根据差值来对“学习器A与B性能相同”这个假设做$t$检验，计算出差值      $\varepsilon_i^A-\varepsilon_i^B$的均值$\mu$和方差$\sigma^2$，在显著度下$\alpha$，若变量</li>
</ul>
<script type="math/tex; mode=display">
\tau_t=\frac{\sqrt{k}\mu}{\sigma}</script><p>小于临界值$t_{\alpha/2k-1}$，则假设不能被拒绝，即两学习器的性能没有显著差别；否则有显著差别，且平均错误率较小的性能较优</p>
<ul>
<li>不同轮次训练集有重叠，测试错误率不独立，会导致过高估计假设成立的概率</li>
</ul>
<p>使用$5\times 2$交叉验证</p>
<ul>
<li><p>为缓解上述问题，可采用$5\times 2$交叉验证</p>
</li>
<li><p>每次$2$折交叉验证前数据随机打乱，$5$次划分不重复</p>
</li>
<li><p>第$i$​次$2$​折交叉验证将产生两对测试错误率，分别求第$1$​折上的差$\Delta_i^1$和第$2$折上的差$\Delta_i^2$，计算两个结果的平均值$\mu=0.5(\Delta_1^1+\Delta_1^2)$            </p>
</li>
<li><p>对每次$2$折实验的结果都计算出其方差</p>
</li>
</ul>
<script type="math/tex; mode=display">
\sigma_i^2=\left(\Delta_i^1-\frac{\Delta_i^1+\Delta_i^2}{2}\right)^2+\left(\Delta_i^2-\frac{\Delta_i^1+\Delta_i^2}{2}\right)^2</script><ul>
<li>变量$\tau_t$服从自由度为$5$的$t$分布</li>
</ul>
<script type="math/tex; mode=display">
\tau_t=\frac{\mu}{\sqrt{0.2\sum_{i=1}^5}\sigma_i^2}</script><ul>
<li>给定显著度$\sigma$，可判别是否有显著差别</li>
</ul>
<h3 id="2-4-3-McNemar检验"><a href="#2-4-3-McNemar检验" class="headerlink" title="2.4.3 McNemar检验"></a>2.4.3 McNemar检验</h3><p>对于二分类问题，可基于留出法列联表</p>
<ul>
<li>获得两者都正确、都错误、一正确另一错误的样本数</li>
</ul>
<p>若两学习器性能相同，则$e_{01}=e_{10}$</p>
<p>变量 $|e_{01}-e_{10}|$ 服从正态分布，而$\tau$服从自由度为$1$的的$ χ²$​分布</p>
<script type="math/tex; mode=display">
\tau_{ χ^2}=\frac{(|e_{01}-e_{02}|-1)^2}{e_{01}+e_{02}}</script><p>给定显著度$\alpha$ ，可判别是否有显著差别</p>
<ul>
<li>有显著差别且平均错误率较小的学习器性能较优</li>
</ul>
<p><img src="/2021/12/10/Chapter2%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/image-20211210120952526.png" alt="图13"></p>
<p>两两比较</p>
<ul>
<li>每个数据集上分别列出两两比较的结果</li>
<li>可使用前述方法</li>
</ul>
<h3 id="2-4-4-Friedman检验-Nemenyi后续检验-基于排序"><a href="#2-4-4-Friedman检验-Nemenyi后续检验-基于排序" class="headerlink" title="2.4.4 Friedman检验+Nemenyi后续检验(基于排序)"></a>2.4.4 Friedman检验+Nemenyi后续检验(基于排序)</h3><p>Friedman检验</p>
<ul>
<li><p>$N$个数据集对$k$个算法进行比较</p>
</li>
<li><p>用留出法或交叉验证法得到每个算法在每个数据集上的测试结果</p>
</li>
<li><p>在每个数据集根据测试由好到坏排序，赋序值$1, 2…$</p>
<p>若算法的测试性能相同，则平分序值</p>
</li>
<li><p>求第$i$个算法的平均序值$r_i$，其服从正态分布</p>
<p>均值$(k+1)/2$，方差$(k^2-1)/12$</p>
</li>
<li><p>构造变量</p>
</li>
</ul>
<script type="math/tex; mode=display">
\tau_{χ^2}=\frac{12N}{k(k+1)}\left(\sum_{i=1}^kr_i^2-\frac{k(k+1)^2}{4}\right)</script><p>​            在$k$和$N$都较大时，服从自由度为$k-1$的$χ^2$分布</p>
<script type="math/tex; mode=display">
\tau_{F}=\frac{(N-1)\tau_{χ^2}}{N(k-1)-\tau_{χ^2}}</script><p>​            服从自由度为$k-1$和$(k-1)(N-1)$的$F$分布</p>
<ul>
<li><p>若所有算法的性能相同假设被拒绝，则说明算法的性能显著不同</p>
<p>​    若所有算法的性能相同假设被拒绝，则说明算法的性能显著不同</p>
</li>
</ul>
<p>Nemenyi检验</p>
<ul>
<li>选择置信度计算平均序值差别的临界值域</li>
</ul>
<script type="math/tex; mode=display">
{\rm CD}=q_\alpha\sqrt{\frac{k(k+1)}{6N}}</script><ul>
<li>若两个算法的平均序值差超出临界阈值CD，则以置信度拒绝“两个算法性能相同”假设，两算法有显著差异，否则接受</li>
</ul>
<p>Friedman检验图</p>
<ul>
<li><p>上述检验比较可以直观地用Friedman检验图显示</p>
</li>
<li><p>横轴为平均序值</p>
<p>​    每个算法圆点为其平均序值，线段为临界阈值</p>
</li>
<li><p>若两个算法有交叠，则说明没有显著差别</p>
</li>
<li><p>否则有显著差别，算法A显著优于算法C</p>
</li>
</ul>
<p>算法误差从何而来，误差包含哪些因素</p>
<ul>
<li><p>解释学习算法泛化性能的工具，偏差-方差</p>
</li>
<li><p>符号</p>
<p>​    $y_D$数据集中标记，$y$真实标记，$f(x;D)$学得的模型</p>
</li>
</ul>
<p>对于回归分析</p>
<ul>
<li>期望预测</li>
</ul>
<script type="math/tex; mode=display">
\overline{f(x)}=E_D[f(x;D)]</script><ul>
<li>不同训练集产生的方差</li>
</ul>
<script type="math/tex; mode=display">
{\rm var}(x)=E_D[f(x;D)-\overline{f(x)}^2]</script><ul>
<li><p>噪声</p>
<script type="math/tex; mode=display">
\varepsilon^2=E_D[(y_D-y)^2]</script></li>
<li><p>期望输出与真实标记的差别称为偏差</p>
</li>
</ul>
<script type="math/tex; mode=display">
{\rm bias}^2(x)=[\overline{f(x)}-y]^2</script><p>期望泛化误差</p>
<ul>
<li>假定噪声期望为零</li>
</ul>
<script type="math/tex; mode=display">
\begin{align}
E(f;D) &= E_D[((f(x; D)-y_D)^2]\\
&= E_D[f(x;D)-f(x)+\overline{f(x)}+y_D)^2]\\
&= {\rm bias}^2(x)+{\rm var}(x)+\varepsilon ^2
\end{align}</script><p>​        偏差：${\rm bias}^2(x)=\left[\overline{f(x)}-y\right]^2$​</p>
<p>​            期望预测与真实结果的差别，反映学习算法拟合能力</p>
<p>​        方差：${\rm var}(x)=E_D\left[f(x;D)-\overline{f(x)}^2\right]$</p>
<p>​            同样大小训练集变动导致的学习性能变化，即数据扰动造成的影响</p>
<p>​        噪声：$\varepsilon^2=E_D\left[(y_D-y)^2\right]$​</p>
<p>​            表达在当前任务任何学习算法所能达到的期望泛化误差下界，即学习问题的难度</p>
<ul>
<li>学习算法的泛化性能是由学习的能力、数据的充分性以及学习任务本身的难度共同决定</li>
</ul>
<p>偏差-方差窘境</p>
<ul>
<li><p>给定学习任务，为取得好的泛化性能，需使偏差较小，即能够充分拟合数据，并且使方差较小，即使得数据扰动产生的影响小</p>
</li>
<li><p>偏差-方差存在冲突，称为偏差-方差窘境</p>
<p>训练不足，学习器拟合能力不强，训练数据扰动不足以使学习器显著变化，偏差主导<br>训练程度加深，学习器拟合逐渐增强，训练数据扰动渐渐被学习器学到，方差逐渐主导</p>
<p>训练充足，学习器的拟合很强，训练数据发生轻微扰动导致学习器显著变化，过拟合，方差主导</p>
</li>
</ul>
<p><img src="/2021/12/10/Chapter2%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/image-20211210124008312.png" alt="图14"></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>npuSE</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>cs231a Course 1:相机模型</title>
    <url>/2021/12/07/L1/</url>
    <content><![CDATA[<h1 id="Course-1-相机模型"><a href="#Course-1-相机模型" class="headerlink" title="Course 1: 相机模型"></a>Course 1: 相机模型</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>照相机是计算机视觉中最重要的工具之一。它是我们可以记录我们周围的世界并使用其输出照片用于各种应用程序的机制。因此，我们在计算机视觉入门课程中必须问的一个问题是：我们如何建模一个相机？</p>
<h2 id="1-2-针孔相机"><a href="#1-2-针孔相机" class="headerlink" title="1.2 针孔相机"></a>1.2 针孔相机</h2><p><img src="https://s4.ax1x.com/2021/12/07/o6QXGt.png" alt="图1：一个简单的工作相机模型：针孔相机模型。"></p>
<p>让我们设计一个简单的摄像系统——一个可以在3D世界中记录物体或场景图像的系统。这种相机系统可以通过在3D物体和摄影胶片或传感器之间放置一个小孔圈的屏障来设计。如图1所示，3D对象上的每个点都会向外发出多条光线。如果没有适当的屏障，薄膜上的每一个点都会受到3D物体上每个点发出的光线的影响。由于障碍物，只有一条（或少数）这些光线穿过孔径并击中薄膜。因此，我们可以在三维物体和薄膜上的点之间建立一个一对一的映射。其结果是，通过这种映射，胶片被三维物体的“图像”曝光。这个简单的模型被称为针孔照相机模型。</p>
<p><img src="https://s4.ax1x.com/2021/12/07/o6QOPI.png" alt="图2：针孔照相机模型的正式构造。"></p>
<p>针孔照相机的一个更正式的结构如图2所示。在这种结构中，薄膜通常被称为图像或视网膜平面。这个孔径被称为针孔$O$或中心相机。图像平面与针孔$O$之间的距离为焦距$f$。有时，视网膜平面被放置在$O$和三维物体之间，距离$O$为$f$​​。在这种情况下，它被称为虚拟图像或虚拟视网膜平面。请注意，对象在图像平面中的投影与对象在虚拟图像平面中的图像的投影在一定比例内是相同的（相似性）转换。</p>
<p>现在，我们如何使用针孔照相机呢？设$P=[x\,\,\,\,y\,\,\,\,z]^{\rm T}$​是针孔相机可见的某些三维物体上的一个点。$P$​将被映射或投影到图像平面$\Pi’$​上，得到$P’=[x’\,\,\,y’]^{\rm T}$​。类似地，针孔本身也可以投射到图像平面上，给出一个新的点$C’’$。</p>
<p>在这里，我们可以定义一个以针孔$O$为中心的坐标系$[i\,\,\,j\,\,\,k]$，使轴$k$垂直于图像平面并指向它。这个坐标系通常被称为照相机参考系统或照相机坐标系。由$ C’’$和$O$定义的线称为照相机系统的光轴。</p>
<p>回想一下，该点$P’$是由三维点$P$在图像平面$\Pi’$​上的投影产生而得到的。因此，如果我们推导出三维点$P$和图像平面点$P’$之间的关系，我们就可以理解如何理解3D世界把自己印在针孔相机拍摄的图像上。请注意，三角形$P’C’O$类似于由$P$、$O$和$(0、0、z)$形成的三角形。因此，利用相似三角形定律我们发现：</p>
<script type="math/tex; mode=display">
P'=[x'\,\,\, y']^{\rm T}=[f\frac{x}{z}\,\,\,f\frac{y}{z}]^{\rm T}\tag{1}</script><p>请注意，我们在这个针孔模型中所做的一个很大的假设是，孔径是一个单点。然而，在大多数真实世界的场景中，我们不能假设孔径可以无限小。钍孔径大小的影响是什么？</p>
<p><img src="https://s4.ax1x.com/2021/12/07/o6Qvxf.png" alt="图3：孔径大小对图像的影响。随着孔径尺寸的减小，图像会变得更清晰，但颜色会更暗。"></p>
<p>随着孔径尺寸的增加，通过势垒的光线数量因此增加。随着更多的光线通过，薄膜上的每个点都会受到l的影响光线来自三维空间中的多点，模糊图像。虽然我们可能倾向于试图使孔径尽可能小，但请记住，较小的孔径尺寸会导致光线减少通过，导致更清晰但更暗的图像。因此，我们得出了针孔公式提出的基本问题：我们能开发出拍摄清晰明亮图像的相机吗?</p>
<h2 id="1-3-相机和镜头"><a href="#1-3-相机和镜头" class="headerlink" title="1.3 相机和镜头"></a>1.3 相机和镜头</h2><p><img src="https://s2.loli.net/2021/12/07/B8gDMFaGmH4YtIr.png" alt="图4：一个简单的镜头模型的设置。请注意，树上的顶点的光线是如何很好地汇聚在胶片上的。然而，一个距离镜头有不同距离的点会产生射线，而不是完美地融合在电影上。"></p>
<p>在现代相机中，通过使用可以聚焦和分散光的镜头，可以缓解上述清晰度和亮度之间的冲突。如果我们把针孔换成一种有两种形状的针孔如果放置和大小，然后它满足以下特性：所有由某些点$P$发射的光线都被透镜折射，使它们收敛到一个单点$P’$在图像平面上。因此，消除了由于一个小孔径而导致的大部分光线被阻挡的问题（图4）。但是，请注意，这个属性并不适用于所有的3D点，而是只适用于某些特定的点P。取与图像平面更近或更远的点Q，图像中相应的投影会模糊或失焦。因此，镜头有一个规格物体“处于焦点中”的特定距离。这一特性也与摄影和计算机图形学的概念有关，这是相机可以达到的有效范围拍摄清晰的照片。</p>
<p><img src="https://obohe.com/i/2021/12/07/ihnnqv.png" alt="图5：镜头将平行于光轴的光线聚焦到焦点中。此外，该装置还说明了近轴折射模型，帮助我们找到带镜头相机的图像平面点与三维世界之间的关系。"></p>
<p>相机镜头还有另一个有趣的特性：它们将所有平行于光轴移动的光线聚焦到一个被称为焦点的点（图5）。焦尖之间的距离$t$和透镜的中心通常被称为焦距$f$。此外，通过透镜中心的普通针垫筒没有偏离。因此，我们可以得到一个与与点$P$相关的针孔模型类似的构造三维空间及其对应的在图像平面上的点$P’$。</p>
<script type="math/tex; mode=display">
P'=
\begin{bmatrix}
x'\\
y'
\end{bmatrix}=
\begin{bmatrix}
z' & \frac{x}{z}\\
z' & \frac{y}{z}
\end{bmatrix}</script><p>这个模型的推导超出了类的范围。但是，请注意，在针孔模型$z’=f$中，而在这个基于镜头的模型中，$z’=f+z_0$。此外，由于这个衍生物上利用近轴或“薄透镜”假设，称为近轴折射模型。</p>
<p><img src="https://obohe.com/i/2021/12/07/ihdosf.png" alt="图6：演示针垫和桶变形如何影响图像。"></p>
<p>由于近轴折射模型近似于薄透镜假设，因此会发生一些像差。最常见的一种被称为径向失真，它导致图像放大作用随着与光轴的距离的增加而减小或增加。当放大阳离子增加和枪管扭曲时，我们将径向畸变划分为针垫畸变当放大率降低时。径向失真是由于透镜的不同部分有不同的焦距而造成的。</p>
<h2 id="1-4-进入数字图像空间"><a href="#1-4-进入数字图像空间" class="headerlink" title="1.4 进入数字图像空间"></a>1.4 进入数字图像空间</h2><p>在本节中，我们将讨论在建模从三维空间到我们所知道的数字图像的投影时必须考虑的参数的细节。所有得到的结果都将使用烟晕但它们也适用于近轴折射模型。</p>
<p>如前所述，三维空间中的一个点P可以被映射（或投影）到图像平面$\Pi’$中的一个二维点$P’$​中。这种$R^3→R^2$映射被称为射影变换。这个投影图像平面上的三维点并不直接对应于我们在实际数字图像中看到的，有几个原因。首先，数字图像中的点通常是用不同的参考中比图像平面上的系统要高。第二，数字图像被划分为离散的像素，而图像平面上的点是连续的。最后，物理传感器可以引入非线性传感器比如对映射的失真。为了解释这些差异，我们将引入一些额外的转换，允许我们将来自三维世界的任何点映射到像素坐标。</p>
<p>图像坐标的原点$C’$在k轴与图像平面相交的图像中心。另一方面，数字图像通常来自于i图像的左下角法师。因此，图像平面上的二维点和图像中的二维点被平移向量偏移$[c_x,c_y]^{\rm T}$。为了适应坐标系统的这种变化，映射现在变为：</p>
<script type="math/tex; mode=display">
P'=
\begin{bmatrix}
x'\\
y'
\end{bmatrix}
=
\begin{bmatrix}
f\frac{x}{z}+c\\
f\frac{y}{z}+c\\
\end{bmatrix}\tag{3}</script><p>下一个效果是，我们必须考虑到数字图像中的点用像素表示，而图像平面上的点用物理测量值表示（例如厘米）。为了适应这个单位的变化，我们必须引入两个新的参数$k$和$l$。这些参数，其单位大概是像“像素/厘米”，对应于图像平面的两个轴上单位的变化。请注意，$k$和$l$可能会有所不同，因为单元元素的长宽比不保证为$1$。如果$k=l$，我们通常说相机有方形像素。我们调整了我们之前的映射为：</p>
<script type="math/tex; mode=display">
P'=
\begin{bmatrix}
x'\\
y'
\end{bmatrix}=
\begin{bmatrix}
fk\frac{x}{z}+c_x\\
fl\frac{y}{z}+c_y
\end{bmatrix}=
\begin{bmatrix}
\alpha\frac{x}{z}+c_x\\
\beta\frac{y}{z}+c_y
\end{bmatrix}\tag{4}</script><p>有没有更好的方法从$P→P’$来表示这个投影？如果这个投影是一个线性变换，那么它可以表示为一个矩阵和输入向量的乘积(在这种情况下，它将是$P$。然而，从方程4中，我们可以看到这个问题$P→P’$不是线性的，因为操作划分了其中一个输入参数(即z)。尽管如此，将这个投影表示为矩阵向量乘积对于未来的推导将是有用的。因此，我们是否可以将我们的变换表示为矩阵向量积，尽管它具有非线性？</p>
<p>解决这个问题的一种方法是改变坐标系。例如，我们引入了一个新的坐标，从而使任何点$P’=(x’、y’)$变成$(x’、y’、1)$。类似地，任何点$P=(x、y、z)$变成$(x、y、z、1)$。这个增广空间被称为齐次坐标系。如前所示，为了将一些欧几里得向量$(v_1，…，v_n)$转换为齐次坐标，我们简单地在一个新的维数中附加一个$1$来得到$(v_1，…，v_n，1)$。请注意，向量及其齐次坐标之间的相等只在最终坐标等于$1$时才会发生。 因此，当从任意齐次坐标$(v_1、…，v_n，w)$转换回时，我们得到欧几里得坐标$(\frac{v_1}{w}，…，\frac{v_n}{w})$。利用齐次坐标，我们可以表示：</p>
<script type="math/tex; mode=display">
P_h'=\begin{bmatrix}
\alpha x+c_x z\\
\beta y+c_y z\\
z
\end{bmatrix}=
\begin{bmatrix}
\alpha & 0 & c_x & 0\\
0 & \beta & c_y & 0\\
0 & 0 & 1 & 0
\end{bmatrix}\cdot
\begin{bmatrix}
x\\
y\\
z\\
1
\end{bmatrix}=
\begin{bmatrix}
\alpha & 0 & c_x & 0\\
0 & \beta & c_y & 0\\
0 & 0 & 1 & 0
\end{bmatrix}P_h\tag{5}</script><p>从这一点起，假设我们将在齐次坐标下工作，除非另有说明。我们将去掉$h$指数，这样任何点$P$或$P’$都可以假定在齐次坐标中。从公式$5$中可以看出，我们可以用矩阵向量关系来表示三维空间中的一个点与其图像坐标之间的关系：</p>
<script type="math/tex; mode=display">
P'=\begin{bmatrix}
x'\\y'\\z
\end{bmatrix}=
\begin{bmatrix}
\alpha & 0 & c_x & 0\\
0 & \beta & c_y & 0\\
0 & 0 & 1 & 0
\end{bmatrix}\cdot
\begin{bmatrix}
x\\y\\z\\1
\end{bmatrix}=
\begin{bmatrix}
\alpha & 0 & c_x & 0\\
0 & \beta & c_y & 0\\
0 & 0 & 1 & 0
\end{bmatrix}\cdot P
=MP\tag{6}</script><p>我们可以把这个转换进一步分解为：</p>
<script type="math/tex; mode=display">
P'=MP=\begin{bmatrix}
\alpha & 0 & c_x \\
0 & \beta & c_y \\
0 & 0 & 1 
\end{bmatrix}\cdot
\begin{bmatrix}
I & 0
\end{bmatrix}\cdot P=
K\cdot\begin{bmatrix}
I & 0
\end{bmatrix}\cdot P\tag{7}</script><p>矩阵$K$通常被称为相机矩阵。这个矩阵包含了一些对表征照相机模型很有用的关键参数。我们的公式目前缺少两个参数：偏度和失真。我们经常说，当相机坐标系倾斜时，图像是倾斜的。在这种情况下，两个轴之间的夹角略大于或小于$90$​度。大多数相机都有零偏态，但由于传感器制造错误，可能会出现一定程度的偏态。证明新的相机矩阵超出了这类的范围，我们给你如下：</p>
<script type="math/tex; mode=display">
K=\begin{bmatrix}
x'\\
y'\\
z
\end{bmatrix}=
\begin{bmatrix}
\alpha & -\alpha\cot \theta & c_x\\
0 & \frac{\beta}{\sin\theta} & c_y
\end{bmatrix}\tag{8}</script><p>我们在这类中引入的大多数方法都忽略了失真效应。因此，我们最终的相机矩阵有$5$个自由度：$2$焦距，$2$偏移量，$1$偏度。</p>
<p>到目前为止，我们已经描述了三维相机参考系统中的一个点$P$到二维图像平面中的一个点$P’$之间的映射。但是如果关于3D世界的信息是不同的呢坐标系？然后，我们需要包括一个额外的转换，将点从世界参考系统到相机参考系统联系起来。这个转换被一个旋转器捕获离子矩阵$R$和平移向量$t$。因此，如果给定世界参考系统$P_w$中的一个点，我们可以计算其相机坐标如下：</p>
<script type="math/tex; mode=display">
P=\begin{bmatrix}
R & T\\
0 & 10
\end{bmatrix} P_w\tag{9}</script><p>将其代入方程（7）并简化给出：</p>
<script type="math/tex; mode=display">
P'=K\begin{bmatrix}
R&T
\end{bmatrix} P_w=MP_w\tag{10}</script><p>这就完成了从任意世界参考系统中的三维点$P$​​到图像平面的映射。我们可以看到投影矩阵$M$​由两种类型的参数组成：固有参数和外部参数$c$​参数。相机矩阵$K$​中包含的所有参数都为固有参数，它们随相机类型的变化而变化。外在参数包括旋转和平移我并不依赖于相机的结构。总的来说，我们发现$3×4$​投影矩阵$M$​有$11$个自由度：$5$个来自内在相机矩阵，$3$个来自外在旋转，$3$个来自外在外在转化。</p>
<h2 id="1-5-相机校准"><a href="#1-5-相机校准" class="headerlink" title="1.5 相机校准"></a>1.5 相机校准</h2><p>要精确地了解从真实的3D世界到数字图像的转换，就需要事先了解相机的许多内在参数。如果给了一个任意的相机，我们可能会，也可能不会可以访问这些参数。然而，我们确实可以看到照相机拍摄的图像。因此，我们能找到一种方法从图像中推断出它们吗？估计外在和内在的相机参数问题被称为相机校准。</p>
<p><img src="https://s2.loli.net/2021/12/07/8BTWuQl7FkImVcz.png" alt="图7：一个示例校准设备的设置。"></p>
<p>具体地说，我们通过求解公式10中的内在相机矩阵K和外在参数R、T来实现这一点。我们可以在校准设备的背景下来描述这个问题，如图7所示。设备通常由一个已知尺寸的简单图案（即棋盘）组成。此外，该设备定义了我们的世界参考系，包括原点$O_w$和轴$i_w$、$j_w$、$k_w$。从设备的已知模式来看，我们已经得到世界参考系$P_1,…,P_n$中的已知点。在我们从相机拍摄的图像中找到这些点会给出图像$p_1，…，p_n$中相应的点。</p>
<p>我们从$n$个对应项中建立了一个线性方程组，对于每个对应项的$P_i$、$p_i$和相机矩阵$M$，其行分别为$m_1$、$m_2$、$m_3$：</p>
<script type="math/tex; mode=display">
p_i=\begin{bmatrix}
u_i\\v_i
\end{bmatrix}=MP_i=\begin{bmatrix}
\frac{m_1P_i}{m_3P_i}\\[2ex]
\frac{m_2P_i}{m_3P_i}
\end{bmatrix}\tag{11}</script><p>正如我们从上面的方程中所看到的，每个对应关系都给出了我们两个方程，因此，也有两个求解$m$中所包含的未知参数的约束条件。从以前开始，我们知道相机矩阵有$11$个未知参数。这意味着我们至少需要$6$个对应关系来解决这个问题。然而，在现实世界中，我们经常使用更多的方法，作为我们的衡量标准设备通常是嘈杂的。为了明确地看到这一点，我们可以推导出一对将$u_i$和$v_i$与$P_i$相关联的方程。</p>
<script type="math/tex; mode=display">
\begin{matrix}
u_i(m_3P_i)-m_1P_i=0\\
v_i(m_3P_i)-m_2P_i=0
\end{matrix}</script><p>给定这些对应点中的$n$​个，等式的整个线性系统变成：</p>
<script type="math/tex; mode=display">
\begin{matrix}
u_1(m_3P_1)-m_1P_1=0\\
v_1(m_3P_1)-m_2P_1=0\\
\vdots\\
u_n(m_3P_n)-m_1P_n=0\\
u_n(m_3P_n)-m_2P_n=0
\end{matrix}</script><p>这可以格式化为矩阵向量乘积，如下所示：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
P_1^{\rm T} & 0^{\rm T} & -u_1P_1^{\rm T}\\[2ex]
0^{\rm T} & P_1^{\rm T} & -v_1P_1^{\rm T}\\[2ex]
\vdots&\vdots&\vdots\\[2ex]
P_n^{\rm T} & 0^{\rm T} & -u_nP_n^{\rm T}\\[2ex]
0^{\rm T} & P_n^{\rm T} & -v_nP_n^{\rm T}
\end{bmatrix}\cdot
\begin{bmatrix}
m_1^{\rm T}\\[2ex]
m_2^{\rm T}\\[2ex]
m_3^{\rm T}
\end{bmatrix}=P_m=0\tag{12}</script><p>当$2n&gt;11$时，我们的齐次线性系统被超确定。对于这样的系统，$m=0$总是一个简单的解决方案。此外，即使有其他一些$m$是一个非零的解决方案，那么$∀k∈R$，$km$也是一个解决方案。因此，为了约束我们的解决方案，我们完成了以下最小化操作：</p>
<script type="math/tex; mode=display">
\begin{matrix}
\min_{m} \,\,\, ||P_m||^2\\[2ex]
{\rm subject\,\,\, to}\,\,\,  ||m||^2 = 1
\end{matrix}\tag{13}</script><p>为了解决这个最小化问题，我们只需简单地使用奇异值分解。如果我们让$P=UDV^{\rm T}$，那么上述最小化的解是设置$m$等于$V$的最后一列。此解决方案的推导超出了本类的范围，详见哈特利和齐瑟曼公司第592-593节的第5.3节。</p>
<p>在将向量$m$重新格式化为矩阵$M$后，我们现在想要显式地求解外部参数和内在参数。我们知道我们的SVD求解的$M$是公认的，这意味着相机矩阵的真值是$M$​的一些标量倍数：</p>
<script type="math/tex; mode=display">
\rho M=\begin{bmatrix}
\alpha r_1^{\rm T}-\alpha \cot \theta r_2^{\rm T}+ c_x r_3^{\rm T}
& \alpha t_x-\alpha\cot\theta t_y+c_xt_z\\[2ex]
\frac{\beta}{\sin \theta}r_2^{\rm T}+c_yr_3^{\rm T} &
\frac{\beta}{\sin \theta}t_y+c_yt_z\\[2ex]
r_3^{\rm T} &
t_z
\end{bmatrix}\tag{14}</script><p>在这里，$r^{\rm T}_1$、$r^{\rm T}_2$和$r^{\rm T}_3$是$r$​的三行。除以缩放参数给出：</p>
<script type="math/tex; mode=display">
M=\frac{1}{\rho}\begin{bmatrix}
\alpha r_1^{\rm T}-\alpha \cot\theta r_2^{\rm T}+c_xr_3^{\rm T} &
\alpha t_x-\alpha \cot\theta t_y+c_xt_z \\[2ex]
\frac{\beta}{\sin \theta}r_2^{\rm T}+c_yr_3^{\rm T} &
\frac{\beta}{\sin \theta}t_y+c_y t_z\\[2ex]
r_3^{\rm T}&
t_z
\end{bmatrix}=
\begin{bmatrix}
A & b
\end{bmatrix}=
\begin{bmatrix}
a_1^{\rm T}\\
a_2^{\rm T}\\
a_3^{\rm T}
\end{bmatrix}\cdot
\begin{bmatrix}
b_1\\b_2\\b_3
\end{bmatrix}</script><p>解决内在因素给予：</p>
<script type="math/tex; mode=display">
\begin{matrix}
\rho=\pm\frac{1}{||a_3||}\\[2ex]
c_x=\rho^2(a_1\cdot a_3)\\[2ex]
c_y=\rho^2(a_2\cdot a_3)\\[2ex]
\Large \theta=\cos^{-1}(-\frac{(a_1\times a_3)\cdot(a_2\times a_3)}{||a_1\times a_3||\cdot||a_2\times a_3||})\\[2ex]
\alpha =\rho^2||a_1\times a_3||\sin \theta\\[2ex]
\beta =\rho^2||a_2\times a_3||\sin\theta

\end{matrix}\tag{15}</script><p>外部因素是：</p>
<script type="math/tex; mode=display">
\begin{matrix}
r_1=\frac{a_2\times a_3}{||a_2\times a_3||}\\
r_2=r_3\times r_1\\
r_3=\rho a_3\\
T=\rho K^{-1}b
\end{matrix}\tag{16}</script><p>我们把派生作为课堂练习，或者你可以参考福赛斯和庞塞教科书的第5.3.1节。</p>
<p>在校准程序完成后，我们将对退化的情况发出警告。并不是所有的$n$个对应集都能工作。例如，如果点$P_i$位于同一个平面上，那么系统将无法被求解。这些不可解的点构型被称为简并构型。更一般地说，简并构型的点位于两个二次曲面的交点曲线上。虽然这超出了课程的范围，但你可以在福赛斯和庞塞教科书的第1.3节中找到更多的信息。</p>
<h2 id="1-6-相机校准中的失真处理"><a href="#1-6-相机校准中的失真处理" class="headerlink" title="1.6 相机校准中的失真处理"></a>1.6 相机校准中的失真处理</h2><p>到目前为止，我们一直在使用理想的没有任何失真的镜头。然而，正如前面所看到的，真实的透镜可以偏离直线投影，这需要更先进的方法。本节仅简要介绍了处理畸变。</p>
<p>通常，由于透镜的物理对称性，畸变是径向对称的。我们用一个各向同性的变换来模拟径向畸变：</p>
<script type="math/tex; mode=display">
QP_i=\begin{bmatrix}
\frac{1}{\lambda} & 0 & 0\\
0 & \frac{1}{\lambda} & 0\\
0 & 0 & 1
\end{bmatrix} M P_i=\begin{bmatrix}
u_i\\
v_i
\end{bmatrix}=p_i\tag{17}</script><p>如果我们像以前一样把它重写成一个方程组，我们得到：</p>
<script type="math/tex; mode=display">
\begin{matrix}
u_iq_3P_i=q_1P_i\\[2ex]
v_iq_3P_i=q_2P_i
\end{matrix}</script><p>然而，该系统不再是线性的，我们需要使用非线性优化技术，这在福赛斯和庞塞的第22.2节中已经涵盖。如果我们做出一定的假设，我们可以简化校准问题的非线性优化。在径向失真中，我们注意到两个坐标$u_i$和$v_i$之间的比值不受影响。我们可以计算这个比率为：</p>
<script type="math/tex; mode=display">
\frac{u_i}{v_i}=\frac{\frac{m_1P_i}{m_3P_i}}{\frac{m_2P_i}{m_3P_i}}=\frac{m_1P_i}{m_2P_i}\tag{18}</script><p>假设有$n$个对应项可用，我们可以建立线性方程组：</p>
<script type="math/tex; mode=display">
\begin{matrix}
v_1(m_1P_1)-u_1(m_2P_1)=0\\
\vdots\\
v_n(m_1P_n)-u_n(m_2P_n)=0
\end{matrix}</script><p>与之前类似，这给出了一个矩阵向量积，我们可以通过SVD来求解：</p>
<script type="math/tex; mode=display">
L_n=\begin{bmatrix}
v_1P_1^{\rm T} & -u_1P_1^{\rm T}\\
\vdots & \vdots\\
v_nP_n^{\rm T} & -u_nP_n^{\rm T}
\end{bmatrix}\cdot
\begin{bmatrix}
m_1^{\rm T}\\
m_2^{\rm T}
\end{bmatrix}\tag{19}</script><p>一旦估计了$m_1$和$m_2$，$m_3$就可以表示为$m_1$、$m_2$和$λ$的非线性函数。这需要解决一个非线性优化问题，该非线性优化问题的复杂性比原来的问题要简单得多。</p>
<h2 id="1-7-附录A：刚性变形"><a href="#1-7-附录A：刚性变形" class="headerlink" title="1.7 附录A：刚性变形"></a>1.7 附录A：刚性变形</h2><p>基本的刚性转换是旋转、平移和缩放。本附录将涵盖它们的3D案例，因为它们是这类文章中的常见类型。</p>
<p>在三维空间中旋转一个点可以通过分别绕着三个坐标轴旋转来表示。当绕着坐标轴旋转时，通常的惯例是沿逆时针方向旋转。一个直观的旋转思考方法是我们围绕每个自由度旋转了多少次，这通常被称为欧拉角。然而，这种方法可能会导致所谓的奇点，或万向节锁，其中某些配置会导致旋转自由度的损失。</p>
<p>防止这种情况发生的一种方法是使用旋转矩阵，这是一种更一般的旋转表示形式。旋转矩阵是方阵，具有行列式为1的正交矩阵。给定一个旋转矩阵$R$和一个向量$v$，我们可以计算得到的向量$v’$为：</p>
<script type="math/tex; mode=display">
v'=Rv</script><p>由于旋转矩阵是矩阵的一个非常普遍的表示，我们可以围绕每个轴表示一个旋转$α$，$β$，$γ$如下：</p>
<script type="math/tex; mode=display">
R_x(\alpha)=\begin{bmatrix}
1 & 0 & 0\\
0 & \cos \alpha & - \sin\alpha\\
0 & \sin\alpha & \cos
\end{bmatrix}</script><script type="math/tex; mode=display">
R_y(\beta)=\begin{bmatrix}
\cos\beta & 0 & \sin\beta\\
0 & 1 &0\\
-\sin\beta & 0 & \cos \beta
\end{bmatrix}</script><script type="math/tex; mode=display">
R_z(\gamma)=\begin{bmatrix}
\cos\gamma & -\sin \gamma & 0\\
\sin \gamma & \cos \gamma & 0\\
0 & 0 & 1
\end{bmatrix}</script><p>根据矩阵乘法的惯例，首先绕$z$轴旋转，然后绕$y$轴旋转，然后$x$轴由矩阵乘积$R_xR_yR_z$给出。</p>
<p>平移或位移被用来描述在一定方向上的运动。在三维空间中，我们定义了一个有$3$个值的平移向量$t$：$3$个轴上的位移，通常表示为$t_x$、$t_y$、$t_z$。因此，给定某个点$P$通过$t$转换为另一个点$P’$，我们可以将其写成：</p>
<script type="math/tex; mode=display">
P'=P+t=\begin{bmatrix}
P_x\\
P_y\\
P_z
\end{bmatrix}+\begin{bmatrix}
t_x\\t_y\\t_z
\end{bmatrix}</script><p>在矩阵形式中，平动可以用齐次坐标来写。如果我们构造一个平移矩阵为：</p>
<script type="math/tex; mode=display">
T=\begin{bmatrix}
1 & 0 & 0 & t_x\\
0 & 1 & 0 & t_y\\
0 & 0 & 1 & t_z\\
0 & 0 & 0 & 1
\end{bmatrix}</script><p>然后我们看到$P’=TP$相当于$P’=P+t$。</p>
<p>如果我们想将平移和旋转矩阵乘法相结合，我们可以再次使用齐次坐标。如果我们想用$R$旋转一个向量$v$，然后用$t$平移它，我们可以把得到的向量$v’$写成：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
v'\\
1
\end{bmatrix}=
\begin{bmatrix}
R & t\\
0 & 1
\end{bmatrix}\cdot\begin{bmatrix}
v\\1
\end{bmatrix}</script><p>最后，如果我们想在向量方向上按一定量的$S_x$、$S_y$、$S_z$，我们可以构造一个尺度矩阵</p>
<script type="math/tex; mode=display">
S=\begin{bmatrix}
S_x & 0 & 0\\
0 & S_y & 0\\
0 & 0 & S_z
\end{bmatrix}</script><p>因此，如果我们想缩放一个向量，然后旋转，然后平移，我们最终的变换矩阵将是：</p>
<script type="math/tex; mode=display">
T=\begin{bmatrix}
RS & t\\
0 & 1
\end{bmatrix}</script><p>请注意，所有这些类型的变换都将是仿射变换的例子。回想一下，当$T$的最后一行不是$[0 \,\,\,0 \,\,\,0\,\,\, 1]$时，会发生射影变换。</p>
<h2 id="1-8-附录B：不同的照相机型号"><a href="#1-8-附录B：不同的照相机型号" class="headerlink" title="1.8 附录B：不同的照相机型号"></a>1.8 附录B：不同的照相机型号</h2><p>我们现在将描述一个简单的模型，称为弱透视模型。在弱透视模型中，首先利用正交投影将点投影到参考平面上，然后进行投影用射影变换变换到图像平面。</p>
<p>如图8所示，给定离相机中心$z_o$距离的参考平面$\Pi$，首先使用正交投影将点$P$、$Q$、$R$投影到平面$\Pi$上，生成点$P\_$, $Q\_$ , $R\_$。这是一个合理的近似，当深度与平面的偏差是很小时，与相机的距离。</p>
<p><img src="https://obohe.com/i/2021/12/07/ihdyrl.png" alt="图8：弱透视模型：在参考平面上的正交投影"></p>
<p><img src="https://obohe.com/i/2021/12/07/ihmts6.png" alt="图9：弱透视模型：投影到图像平面上"></p>
<p>​    </p>
<p>图9说明了点$P\_$、$Q\_$、$R\_$如何使用规则的投影变换投影到图像平面上，从而产生点$p’$、$q’$、$r’$。但是，请注意，由于我们已将每个点的深度近似为$z_o$，因此投影已被简化为一个简单的、恒定的放大倍数。放大倍数等于焦距$f’$除以$z_o$，导致</p>
<script type="math/tex; mode=display">
x'=\frac{f'}{z_0}x\,\,\,\,\,\,\,\,\,\,\,\,\,y'=\frac{f'}{z_0}y</script><p>该模型还简化了投影矩阵：</p>
<script type="math/tex; mode=display">
M=\begin{bmatrix}
A & b\\
0 & 1
\end{bmatrix}</script><p>如我们所见，弱透视模型的$M$最后一行为$[0 \,\,\,0 \,\,\,0\,\,\, 1]$，而普通相机模型为$[v\,\,\,1]$。我们不证明这个结果并把它作为一个练习留给你吧。当将三维点映射到图像平面时，可以清楚地证明了这种简化性。</p>
<script type="math/tex; mode=display">
P'=MP=\begin{bmatrix}
m_1\\m_2\\m_3
\end{bmatrix}P=\begin{bmatrix}
m_1P\\
m_2P\\
1
\end{bmatrix}\tag{20}</script><p>因此，我们可以看到，图像平面点最终成为原始三维点的放大倍数，而与深度无关。射影变换的非线性消失了，使得弱透视变换仅仅是一个放大镜。</p>
<p><img src="https://obohe.com/i/2021/12/07/ihn1hf.png" alt="图10：正字法投影模型"></p>
<p>​    </p>
<p>进一步简化后，得到了正字法（或仿射）投影模型。在这种情况下，光中心位于无穷远处。投影射线现在垂直于视网膜平面。因此，这个模型完全忽略了深度。因此，</p>
<script type="math/tex; mode=display">
\begin{matrix}
x'=x\\
y'=y
\end{matrix}</script><p>正形投影模型经常用于建筑和工业设计。</p>
<p>总的来说，弱视角模型的数学结果要简单得多，但代价是有些不精确。然而，当物体较小且远离相机时，它通常会产生非常准确的结果。</p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
        <tag>cs231a</tag>
      </tags>
  </entry>
  <entry>
    <title>cs231a Course 3：对极几何</title>
    <url>/2021/12/07/L3/</url>
    <content><![CDATA[<h1 id="course-3：对极几何"><a href="#course-3：对极几何" class="headerlink" title="course 3：对极几何"></a>course 3：对极几何</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>之前，我们已经看到了如何使用典型的相机校准程序或单视图测量方法，使用一个或多个视图来计算相机的固有和外在参数。这个过程最终是从一幅图像中推导出关于三维世界的属性。然而，一般来说，不可能仅仅从一张图像中恢复3D世界的整个结构。这是由于3D到二维映射的内在模糊性：一些信息只是丢失了。</p>
<p><img src="https://c1.im5i.com/2021/12/07/cLTdt.png" alt="图1：像现在这样的一个男人举起比萨斜塔的照片可能会导致模糊的场景。对同一个场景的多个视图可以帮助我们解决这些潜在的歧义。"></p>
<p>例如，在图1中，我们最初可能会被愚弄，认为这个人是在举着比萨的斜塔。只有通过仔细的检查，我们才能发现情况并非如此，而仅仅是一种基于在图像平面上不同深度的投影的错觉。然而，如果我们能够从一个完全不同的角度来看这个场景，这个错觉就会立即消失，我们就会立即找出正确的场景布局。</p>
<p>这些课堂讲稿的重点是展示当有多个相机时，掌握几何知识是非常大的帮助。具体来说，我们将首先关注定义两个观点所涉及的几何，然后介绍这个几何如何帮助进一步理解我们周围的世界。</p>
<h2 id="3-2-对极几何"><a href="#3-2-对极几何" class="headerlink" title="3.2  对极几何"></a>3.2  对极几何</h2><p><img src="https://c1.im5i.com/2021/12/07/cL5oS.png" alt="图2：上极性几何结构的一般设置。灰色区域是上极平面。橙色的线是基线，而两条蓝色的线是上极性线。"></p>
<p>通常在多视图几何图形中，多个相机、一个3D点和该点在每个相机图像平面上的投影之间存在着有趣的关系。与照相机、三维图像中的点和相应的观测结果相关联的几何形状被称为立体声对的上极性几何形状。</p>
<p>如图2所示，标准的外极性几何设置包括两个摄像机观察相同的三维点P，它们在每个图像平面上的投影分别位于$p$和$p’$处。摄像机中心位于$O_1$和$O_2$​，它们之间的线称为基线。我们称由两个相机中心定义的平面，P为上极平面。基线与两个图像相交的位置。</p>
<p><img src="https://c1.im5i.com/2021/12/07/cLHML.png" alt="图3：在图像对上绘制的上极性线及其对应点的一个例子。"></p>
<p>平面被称为外极点$e$和$e’$。最后，由上极平面与两个图像平面的交点定义的线称为上极线。外极线具有在图像平面的外极上与基线相交的特性。</p>
<p><img src="/2021/12/07/L3/办公文件\大三上\CV\笔记\L3.assets\image-20211202232841394-16384589235163.png" alt="图4：当两个图像平面平行时，上极e和e0位于无穷远处。请注意，上极线平行于每个图像平面的u轴。"></p>
<p>图4显示了一个有趣的上极几何情况，当图像平面彼此平行时。当图像平面相互平行时，外极$e$和$e’$位于无穷大，因此上极$e$和$e’$与图像平面平行。这种情况的另一个重要副产品是上极线平行于每个图像平面的一个轴。这种情况特别有用，并将在后面的图像校正一节中进行更详细的介绍。</p>
<p>然而，在现实世界中，我们并没有给出3D位置P的确切位置，但我们可以确定它在其中一个图像平面P中的投影。我们还应该能够知道相机的位置、方向和相机矩阵。我们能用这些知识做些什么呢？通过对相机位置$O_1$、$O_2$和图像点$p$的了解，我们可以定义上极平面。有了这个上极平面，我们就可以确定上极线1。根据定义，P对第二幅图像$p’$的投影必须位于第二幅图像的上极线上。因此，对外极几何的基本理解允许我们在不了解场景的三维结构的情况下创建图像对之间的强约束。</p>
<p><img src="https://c1.im5i.com/2021/12/07/cLthD.png" alt="图5：确定必要矩阵和基本矩阵的设置，这有助于跨视图绘制点和上极性线。"></p>
<p>我们现在将尝试开发无缝的方法来绘制跨视图的点和外极性线。如果我们采用原始的外极性几何框架中给出的设置（图5），那么我们将进一步定义$M$​和$M_0$​​为将三维点映射到它们各自的二维图像平面位置的相机投影矩阵。让我们假设世界参考系统与第一个相机相关联，第二个相机的偏移首先通过旋转R，然后平移T。这指定了相机投影矩阵为：</p>
<script type="math/tex; mode=display">
M=K[I\,\,\,0]\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,M'=K'[R^{\rm T}\,\,\,-R^{\rm T}T]\tag{1}</script><h2 id="3-本质矩阵"><a href="#3-本质矩阵" class="headerlink" title="3 本质矩阵"></a>3 本质矩阵</h2><p>在最简单的情况下，让我们假设我们有典型的相机，其中$K=K’=I$。这将公式1简化为</p>
<script type="math/tex; mode=display">
M=[I\,\,\,0]\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,M'=[R^{\rm T}\,\,\,-R^{\rm T}T]\tag{2}</script><p>此外，这意味着$p’$​在第一个相机的参考系统是$Rp’+T$因为向量$Rp’+T$和$T$躺在上极平面，那么如果我们的交叉积$T×(Rp’+T)=T×(Rp’)$，我们将得到一个向量上极平面的正常。这也意味着位于上极平面的$p$与$T×(Rp’)$是正常，这给了我们它们的点积为零的约束：</p>
<script type="math/tex; mode=display">
p^{\rm T}\cdot[T\times(Rp')]=0\tag{3}</script><p>从线性代数中，我们可以引入交叉积的一个不同的、紧的表达式：我们可以将任意两个向量a和b之间的交叉积表示为矩阵-向量乘法：</p>
<script type="math/tex; mode=display">
a\times b=\begin{bmatrix}
0 & -a_x & a_y\\
a_z & 0 & -a_x\\
-a_y & a_x & 0
\end{bmatrix}\cdot\begin{bmatrix}
b_x\\b_y\\b_z
\end{bmatrix}=[a_{\times}]b\tag{4}</script><p>将此表达式与方程3相结合，我们可以将交叉积项转换为矩阵乘法，并给出</p>
<script type="math/tex; mode=display">
\begin{matrix}
p^{\rm T}\cdot[T_\times](R_p')=0\\
p^{\rm T}[T_{\times}]Rp'=0
\end{matrix}\tag{5}</script><p>矩阵$E=[T_×]R$被称为基本矩阵，为外极约束创建了一个紧凑的表达式：</p>
<script type="math/tex; mode=display">
p^{\rm T}Rp'=0\tag{6}</script><p>本质矩阵是一个$3×3$​，其秩为$2$，包含$5$个自由度的奇异矩阵。</p>
<p>本质矩阵对于计算与$p$​和$p’$相关的上极线很有用。例如，$l’=E^Tp$​​给出了相机$2$的图像平面上的上极线。同样，$l=Ep’$给出了相机$1$的图像平面上的上极线。基本矩阵的其他有趣的性质是，它带外极点的点积等于零：$E^Te=Ee’=0$。因为对于相机$1$图像中的任何点$x$（$e$以外），相机$2$图像中对应的上极线$l’=E^Tx$包含外极$e’$。因此，$e’$满足所有x的$e’^T(E^Tx)=(e’^TE^T)x=0$，因此$Ee’=0$。同样，$E^Te=0$​​.</p>
<h2 id="4-基本矩阵"><a href="#4-基本矩阵" class="headerlink" title="4 基本矩阵"></a>4 基本矩阵</h2><p>虽然当我们有规范摄像机时，我们推导出了$p$和$p’$之间的关系，但当摄像机不再是规范摄像机时，我们应该能够找到一个更普遍的表达式。回想一下我们投影矩阵</p>
<script type="math/tex; mode=display">
M=[I\,\,\,0]\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,M'=K'[R^{\rm T}\,\,\,-R^{\rm T}T]\tag{7}</script><p>首先，我们必须将$p_c=K^{−1}p$​​和$p’_c=K’^{−1}p’$​​定义为典型相机，即$P$对相应相机图像的投影。回想一下，在典型的情况：</p>
<script type="math/tex; mode=display">
p_c^{\rm T}[T_\times]Rp_c'=0\tag{8}</script><p>通过替换$p_c$和$p’_c$​​的值，我们得到了</p>
<script type="math/tex; mode=display">
p^{\rm T}K^{-\rm T}[T_\times]RK'^{-1}p'=0\tag{9}</script><p>矩阵$F=K’^{−T}[T_×]RK^{−1}$​​​被称为基本矩阵，其作用类似于前一节的基本矩阵，但也对相机矩阵$K$​​、$K’$​和摄像机之间的相对平移$T$​和旋转$R$​的信息进行编码。因此，即使相机矩阵$K$、$K’$和变换$R$、$T$未知，它也对计算与$p$和$p’$相关的上极线也很有用。与基本矩阵相似，我们可以仅从基本矩阵和相应的点计算外极线$l’=F^Tp$和$l=Fp’$​​。本质矩阵和基本矩阵之间的一个主要区别是，基本矩阵包含$7$个自由度，而本质矩阵包含$5$个自由度。</p>
<p>但是基本矩阵是怎么用的呢？就像基本矩阵一样，如果我们知道基本矩阵，那么简单地知道一个图像中的一个点就会给我们在另一个图像中对应点的一个简单的约束（上极线）。因此，在不知道$P$在三维空间中的实际位置，或相机的任何外在或内在特征的情况下，我们可以建立任何$p$和$p’$之间的关系。</p>
<h2 id="4-1-八点算法"><a href="#4-1-八点算法" class="headerlink" title="4.1 八点算法"></a>4.1 八点算法</h2><p>尽管如此，假设我们可以有基本矩阵，这是由相机参数的矩阵乘积定义的，似乎相当大。然而，在给定同一场景的两幅图像的情况下，可以通过不知道相机的外部或内在参数来估计基本矩阵。我们所讨论的方法称为八点算法；</p>
<p><img src="https://c1.im5i.com/2021/12/07/cLWXq.png" alt="图6：在各自的图像上以相同的颜色绘制相应的点。"></p>
<p>该算法由朗格特-希金斯于1981年提出，并于1995年由哈特利进行扩展。如标题所示，八点算法假设两张图像之间至少有$8$对对应的点可用。</p>
<p>每个对应的$pi=(u^i，v^i，1)$和$p’i=(u’_i，v’_i，1)$都给出了外极约束$p^T_iFp’_i=0$​。我们可以重新表述该约束条件如下：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
u_iu_i' & v_i'u_i & u_i & u_i'v_i & v_iv_i' & v_i & u_i'& v_i' & 1
\end{bmatrix}\cdot\begin{bmatrix}
F_{11}\\F_{12}\\F_{13}\\F_{21}\\F_{22}\\F_{23}\\F_{31}\\F_{32}\\F_{33}
\end{bmatrix}=0\tag{10}</script><p>由于这个约束是一个标量方程，所以它只约束一个自由度。由于我们只能知道基本矩阵，我们需要其中的$8$个约束来确定基本矩阵：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
u_1u_1' & v_1'u_1 & u_1' & u_1'v_1 & v_1v_1' & v_1 & u_1' & v_1' & 1\\
u_2u_2' & v_2'u_2 & u_2' & u_2'v_2 & v_2v_2' & v_2 & u_2' & v_2' & 1\\
u_3u_3' & v_3'u_3 & u_3' & u_3'v_2 & v_3v_3' & v_3 & u_3' & v_3' & 1\\
u_4u_4' & v_4'u_4 & u_4' & u_4'v_4 & v_4v_4' & v_4 & u_4' & v_4' & 1\\
u_5u_5' & v_5'u_5 & u_5' & u_5'v_5 & v_5v_5' & v_5 & u_5' & v_5' & 1\\
u_6u_6' & v_6'u_6 & u_6' & u_6'v_6 & v_6v_6' & v_6 & u_6' & v_6' & 1\\
u_7u_7' & v_7'u_7 & u_7' & u_7'v_7 & v_7v_7' & v_7 & u_7' & v_7' & 1\\
u_8u_8' & v_8'u_8 & u_8' & u_8'v_8 & v_8v_8' & v_8 & u_8' & v_8' & 1\\
\end{bmatrix}\cdot\begin{bmatrix}4F_{11}\\F_{12}\\F_{13}\\F_{21}\\F_{22}\\F_{23}\\F_{31}\\F_{32}\\F_{33}5\end{bmatrix}=0\tag{11}</script><p>可以化简为</p>
<script type="math/tex; mode=display">
W\rm f = 0 \tag{12}</script><p>其中$W$​是由$N≥8$对应推导出的$N×9$矩阵，$f$是我们想要的基本矩阵的值。</p>
<p>在实践中，通常最好使用$8$个以上的对应项，并创建一个更大的$W$矩阵，因为它减少了噪声测量的影响。该齐次方程组的解可以通过奇异值分解(SVD)得到最小二乘意义上，因为W是有缺陷的。SVD将给出基本矩阵$\hat F$的估计值，它可能满秩。然而，我们知道真正的基本矩阵的秩为$2$。因此，我们应该寻找一个可以作为$\hat F$​的最佳秩-2近似的解决方案。为此，我们解决了以下优化问题：</p>
<script type="math/tex; mode=display">
\begin{matrix}
{\rm minimize}_{F}\,\,\,||F-\hat{F}||_{F}\\
{\rm subject\,\,\, to}\,\,\, {\rm det}\,\,F=0
\end{matrix}\tag{13}</script><p>这个问题再次用SVD解决，其中$\hat F=UΣV^T$​​，然后找到最佳的秩$-2$近似</p>
<script type="math/tex; mode=display">
F=U\begin{bmatrix}
\sum_1 & 0 & 0\\
0 & \sum_2 & 0\\
0 & 0 & 0
\end{bmatrix}V^{\rm T}=0\tag{14}</script><h2 id="4-2-八点算法的归一化"><a href="#4-2-八点算法的归一化" class="headerlink" title="4.2 八点算法的归一化"></a>4.2 八点算法的归一化</h2><p>在实际应用中，八点算法的标准最小二乘方法并不精确。通常，一个点$p_i$​与其相应的上极线$l_i=Fp’$​之间的距离会非常大，通常在$10+$像素的尺度上。为了减少这个错误，我们可以考虑一个改进版本的八点算法，称为归一化八点算法。</p>
<p>标准八点算法的主要问题源于$W$对SVD是病态的。为了使SVD能够正常工作，$W$应该有一个奇异值等于（或接近）零，而其他奇异值为非零。然而，由于现代相机的像素范围(即$p_i=(1832,1023,1)$)，对应的$pi=(u_i，v_i，1)$在第一和第二坐标中往往具有极大的值。如果用于构造$W$的图像点在图像中一个相对较小的区域，那么$p_i$和$p’_i$​的每个向量通常会非常相似。因此，所构造的$W$矩阵将有一个非常大的奇异值，而其余的则相对较小。</p>
<p>为了解决这一问题，我们将在构造$w$之前对图像中的点进行归一化。这意味着我们通过对图像坐标进行平移和缩放来进行先决条件$W$，从而满足两个要求。首先，新坐标系的原点应位于图像点的质心（平移）。其次，变换后的图像点从原点处的均方距离应为$2$像素（缩放）。我们可以用一个变换矩阵$T$，$T_0$来紧凑地表示这个过程，该矩阵通过质心和缩放因子$(\frac{2N}{\sum_{i=1}^N||x_i-\bar{x}||^2})^{1/2}$​来转换。</p>
<p>然后，我们对坐标进行归一化：</p>
<script type="math/tex; mode=display">
q_i=Tp_i\,\,\,\,\,\,\,\,\,\,\,\,q_i'=T'p_i'\tag{15}</script><p>利用新的归一化坐标，我们可以使用正则最小二乘八点算法来计算新的$F_q$​​。而矩阵$F_q$​​是归一化坐标的基本矩阵。为了使它在正则坐标空间上可用，我们需要将它去规范化，并给出</p>
<script type="math/tex; mode=display">
F=T'^{\rm T}F_qT\tag{16}</script><p>最终，这个新的基本矩阵F在实际应用中得到了很好的效果。</p>
<h2 id="5-图像整改"><a href="#5-图像整改" class="headerlink" title="5 图像整改"></a><strong>5 图像整改</strong></h2><p>回想一下，当两个图像相互平行时，上极几何的一个有趣的情况发生了。让我们首先计算平行图像平面情况下的基本矩阵$E$。我们可以假设这两个相机有个相同的$K$，并且在相机之间没有相对旋转($R=I$)。在这种情况下，让我们假设只有一个沿$x$轴的平移，给出$T=(T_x,0,0)$​。这就给出了</p>
<script type="math/tex; mode=display">
l=Ep'=\begin{bmatrix}
0 & 0 & 0\\0 & 0 & -T_x\\ 0 & T_x & 0
\end{bmatrix}\cdot\begin{bmatrix}
u'\\v'\\1
\end{bmatrix}=\begin{bmatrix}
0\\-T_x\\ T_xv'
\end{bmatrix}\tag{18}</script><p>我们可以看到$l$​的方向是水平的，$l’$​的方向也是水平的，它是用类似的计算方法计算的。</p>
<p>​        <img src="/2021/12/07/L3/办公文件\大三上\CV\笔记\L3.assets\image-20211204164507526-163860750878413.png" alt="图7：图像校正的过程包括计算两个同构态，我们可以应用于一对图像，使它们并行。"></p>
<p>如果我们使用外极约束$p^TEp’=0$​，那么我们得到了$v=v’$的事实，证明了$p$和$p’$共享相同的$v$坐标。因此，在对应的点之间存在着一种非常直接的关系。因此，当识别图像中对应点之间的关系时，校正或使任意两个给定图像并行的过程变得有用。</p>
<p>​        <img src="/2021/12/07/L3/办公文件\大三上\CV\笔记\L3.assets\image-20211204164617398-163860757903614.png" alt="图8：校正问题的设置：我们计算了两个同构态，我们可以应用于图像平面，使得到的平面平行。"></p>
<p>重新生成一对图像不需要知道两个相机矩阵$K$​、$K’$​或它们之间的相对变换$R$​、$T$。相反，我们可以使用由归一化八点算法估计的基本矩阵。在得到基本矩阵后，我们可以计算每个对应的$p_i$和$p’_i$的外极线$l_i$和$l’_i$​​。</p>
<p>从一组上极线中，我们可以估计每幅图像的上极e和e’。这是因为我们知道外极位于所有外极线的交点处。在现实世界中，由于噪声测量，所有的上极线不会在一个点上相交。因此，可以通过最小化拟合一个点的最小二乘误差来计算上极点。回想一下，每条上极线都可以表示为一个向量$l$​​，这样直线上的所有点（用均次坐标表示）都在集合{${x|l^Tx=0}$​​}中。如果我们将每条上极线定义为$l_i=[l_{i,1}\ \ l_{i,2} \ \ l_{i,3}]^T$​​，那么我们可以建立一个线性方程组，并使用SVD求解找到外极$e$​​：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
l_1^{\rm T}\\ \vdots\\
l_n^{\rm T}
\end{bmatrix}e = 0\tag{19}</script><p>在找到外极$e$​和$e’$​时，我们很可能会注意到它们不是沿横轴在无穷大的点。如果它们是，那么，根据定义，这些图像将已经是平行的。因此，我们获得了一些如何使图像平行的见解：我们能找到一个沿横轴映射到无穷大的同源线吗？具体来说，这意味着我们想要找到一对同形图$H_1$​，$H_2$​，我们可以应用于图像，将上极映射到无穷大。让我们从找到一个同调图$H_2$开始，即$11$将第二个外极子$e’$映射到横轴上无穷远处的一个点$(f,0,0)$。由于这种同质性有很多可能的选择，我们应该尝试选择一些合理的东西。在实践中导致良好结果的一个条件是坚持认为同源性就像一个变换，在图像中心附近的点上应用平移和旋转。</p>
<p>实现这种变换的第一步是变换第二幅图像，使其中心在齐次坐标下处于$(0,0,1)$​处。我们可以通过应用平移矩阵来实现这一点</p>
<script type="math/tex; mode=display">
T=\begin{bmatrix}
1 & 0 &  -\frac{\rm width}{2}\\
0 & 1 & -\frac{\rm height}{2}\\
0 & 0 & 1
\end{bmatrix}\tag{20}</script><p>在应用平移后，我们通过旋转将其放置在某个点$(f,0,1)$的横轴上。如果平移的外极子$Te’$位于均次坐标$(e’_1, e’_2, 1)$​，则所应用的旋转为</p>
<script type="math/tex; mode=display">
R=\begin{bmatrix}
\alpha \frac{e_1'}{\sqrt{e_1'^2+e_2'^2}} & \alpha \frac{e_2'}{\sqrt{e_1'^2+e_2'^2}} & 0\\
-\alpha \frac{e_2'}{\sqrt{e_1'^2+e_2'^2}} & \alpha \frac{e_1'}{\sqrt{e_1'^2+e_2'^2}} & 0\\
0 & 0 & 1
\end{bmatrix}\tag{21}</script><p>其中，$α=1$，如果是$e’_1≥0$​和$α=−1$，否则。应用此旋转后，请注意，给定$(f,0,1)$处的任意点，将其带到横轴$(f,0,0)$上的无穷远处，只需要应用变换</p>
<script type="math/tex; mode=display">
G=\begin{bmatrix}
1 & 0 & 0\\
0 & 1& 0\\
-\frac{1}{f} & 0 & 1
\end{bmatrix}\tag{22}</script><p>在应用这个变换后，我们最终在无穷大处有一个外极，所以我们可以转换回正则图像空间。因此，我们应用在第二幅图像上来校正它的同源性$H_2$是</p>
<script type="math/tex; mode=display">
H_2=T^{-1}GRT\tag{23}</script><p>现在找到了一个有效的$H_2$​，我们需要为第一张图像找到一个匹配的同调H1。我们通过找到一个变换H1来最小化图像对应点之间的平方距离的平方和</p>
<script type="math/tex; mode=display">
\arg\min_{H_1} \sum_{i}||H_1p_i-H_2p_i'||^{2}\tag{24}</script><p>虽然推导$2$超出了这个类的范围，但我们可以证明匹配的$H_1$的形式是：</p>
<script type="math/tex; mode=display">
H_1=H_A H_2M\tag{25}</script><p>其中，$F=[e]_×M$​​和</p>
<script type="math/tex; mode=display">
H_A=\begin{bmatrix}
a_1 & a_2 &a_3\\
0 & 1 & 0\\
0 & 0 & 1
\end{bmatrix}</script><p>用$(a1、a2、a3)$组成计算特定向量a的元素。</p>
<p>首先，我们需要知道$M$​​是什么。任何$3×3$​斜对称矩阵$a$​的一个有趣的性质是一个$=A3$。因为任何交叉积矩阵$[e]_×$​​​都是偏对称的，而且我们只能知道基本矩阵$F$</p>
<script type="math/tex; mode=display">
F=[e]_\times M =[e]_\times[e]_\times[e]_\times M=[e]_\times[e]_\times F\tag{27}</script><p>通过对正确的术语进行分组，我们可以找到它</p>
<script type="math/tex; mode=display">
M=[e]_\times F\tag{28}</script><p>请注意，如果$M$的列由$e$的任意标量倍数添加，那么$F=[e]_×M$​仍然可以按缩放。因此，定义$M$的更一般的情况是</p>
<script type="math/tex; mode=display">
M=[e]_\times F+e v^{\rm T}\tag{29}</script><p>对于一些向量$v$。在实践中，通过设置$v^{\rm T}=[1\ \  1\ \  1]$​来定义M的效果非常好。</p>
<p>为了最终求解$H_1$​，我们需要计算$H_A$​的$a$值。回想一下，我们想找到一个$H_1，H_2$来最小化公式$24$中提出的问题。因为我们已经知道$H_2$和$M$的值，那么我们可以用$\hat {p_i}=H_2Mp_i和\hat p’_i=H_2p’_i$​来代替，然后最小化问题就变成了</p>
<script type="math/tex; mode=display">
\arg\min_{H_A}\sum_i||H_A\hat{p_i}-\hat{p_i'}||^2\tag{30}</script><p>特别地，如果我们让$\hat p_i=(\hat x_i，\hat y_i，1)$​和$\hat p_i=(\hat x_i，\hat y_i，1)$​​，那么最小化问题可以替换为：</p>
<script type="math/tex; mode=display">
\arg\min_a\sum_{i}(a_1\hat{x_i}+a_2\hat{y_i}+a_3-\hat{x_i'})^2+(\hat{y_i}-\hat{y_i'})^2\tag{31}</script><p>由于$\hat y_i−\hat y’_i$​​是一个常数值，因此最小化问题进一步简化为</p>
<script type="math/tex; mode=display">
\arg\min_a\sum_i(a_i\hat{x_i}+a_2\hat{y_i}+a_3-\hat{x_i'})^2\tag{32}</script><p>最终，这将分解为解决一个最小二乘问题$Wa = b$​</p>
<script type="math/tex; mode=display">
W=\begin{bmatrix}
\hat{x_1} & \hat{y_1} & 1\\
& \vdots\\
\hat{x_n} & \hat{y_n} & 1
\end{bmatrix}\,\,\,\,\,\,\,\,b=\begin{bmatrix}
\hat{x_1'}\\\vdots\\\hat{x_n'}
\end{bmatrix}\tag{33}</script><p>在计算$a$后，我们可以计算$H_A$，最后是$H_1$。因此，我们生成了同态$H_1、H_2$​​来校正给定一些对应关系的任何图像对。</p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
        <tag>cs231a</tag>
      </tags>
  </entry>
  <entry>
    <title>cs231a Course 4：立体声系统和运动结构恢复</title>
    <url>/2021/12/07/L4/</url>
    <content><![CDATA[<h1 id="Course-4：立体声系统和运动结构恢复"><a href="#Course-4：立体声系统和运动结构恢复" class="headerlink" title="Course 4：立体声系统和运动结构恢复"></a>Course 4：立体声系统和运动结构恢复</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1  介绍"></a>1  介绍</h2><p>在前面的注释中，我们讨论了如何添加一个场景的额外视点可以极大地增强我们对所述场景的知识。我们专注于外极性几何设置，以便将一个图像平面上的点与另一个图像平面上的点联系起来，而不提取任何关于三维场景的信息。在这些课堂讲稿中，我们将讨论如何从多个二维图像中恢复有关三维场景的信息。</p>
<h2 id="2-三角剖分"><a href="#2-三角剖分" class="headerlink" title="2 三角剖分"></a>2 三角剖分</h2><p>多视图几何中最基本的问题之一是三角测量问题，即给定三维点投影到两个或多个图像的三维点位置的过程。</p>
<p><img src="/2021/12/07/L4/1.PNG" alt="图1：当给定两个视图时的三角测量问题的设置。"></p>
<p>在两个视图的三角测量问题中，我们分别有两个已知相机固有参数$K$​和$K_0$​的相机。我们也知道这些相机彼此之间的相对方向和偏移量$R$、$T$。假设我们在三维中有一个点$P$，这可以分别在$p$和$p’$的两个相机的图像中找到。虽然$P$的位置目前尚不清楚，但我们可以测量$p$和$p’$在图像中的确切位置。由于$K$、$K’$、$R$、$T$是已知的，我们可以计算两个视线$l$和$l’$，它们由相机中心$O_1$、$O_2$和图像位置$p$、$p’$定义。因此，$P$可以计算为$l$和$l’$的交点。</p>
<p><img src="/2021/12/07/L4/2.PNG" alt="图2：真实场景中的三角测量问题通常涉及到最小化重投影误差。"></p>
<p>虽然这个过程看起来既简单又数学合理，但在实践中并不是很好。在现实世界中，由于观测值$p$和$p’$有噪声，相机校准参数不精确，寻找$l$和$l’$的交点可能存在问题。在大多数情况下，它根本不存在，因为这两条线可能永远不会相交。        </p>
<h2 id="2-1-一种线性三角测量方法"><a href="#2-1-一种线性三角测量方法" class="headerlink" title="2.1 一种线性三角测量方法"></a>2.1 一种线性三角测量方法</h2><p>在本节中，我们将描述一个简单的线性三角测量方法，以解决射线之间缺乏交点。我们在图像中给出了两点相互对应的$p=MP=(x,y,1)$和$p’=M’P=(x’,y’,1)$。根据交叉积的定义，$p×(MP)=0$​。我们可以显式地使用交叉积生成的等式来形成三个约束：</p>
<script type="math/tex; mode=display">
\begin{matrix}
x(M_3P)-(M_1P)=0\\
y(M_3P)-(M_3P)=0\\
x(M_2P)-y(M_1P)=0
\end{matrix}\\tag{2.1}</script><p>其中$M_i$​是矩阵$M$​的第$i$​行。对于$p’$和$M’$也可以表示类似的约束。利用这两幅图像的约束条件，我们可以建立一个$AP=0$形式的线性方程，其中</p>
<script type="math/tex; mode=display">
A=\left[\begin{matrix}xM_3-M_1\\
yM_3-M_2\\
x'M_3-M_1'\\
y'M_3'-M_2'
\end{matrix}
\right ]
\tag{2.2}</script><p>该方程可以用SVD来求解，从而得到点$p$的最佳线性估计。该方法的另一个有趣的方面是，它实际上也可以处理来自多个视图的三角化。为此，简单地将添加的行附加到新视图添加的约束。</p>
<p>然而，该方法不适合用于射影重建，因为它不是射影不变的。例如，假设我们将相机矩阵M，M’替换为受射影变换$MH^{−1}$​，$M’H^{−1}$​影响的矩阵。线性方程A的矩阵变成$AH^{−1}$​。因此，之前对$AP=0$的估计的解决方案P将对应于转换问题$(AH^{−1})(HP)=0$的解决方案HP。回想一下，SVD解决了$||P||=1$​的约束，它在射影变换H下不是不变的。因此，该方法虽然简单，但往往不是三角剖分问题的最优解。</p>
<h2 id="2-2-对三角剖分的一种非线性方法"><a href="#2-2-对三角剖分的一种非线性方法" class="headerlink" title="2.2 对三角剖分的一种非线性方法"></a>2.2 对三角剖分的一种非线性方法</h2><p>相反，现实世界场景中的三角剖分问题通常被数学上描述为解决一个最小化问题：</p>
<script type="math/tex; mode=display">
\underset{\hat P} {min}\vert\vert M\hat P - p \vert \vert + \vert \vert M' \hat P-p' \vert \vert \tag{2.3}</script><p>在上述方程中，我们通过寻找两幅图像中Pˆ的重投影误差的最佳最小二乘估计值，来寻找一个最接近P的三维$\hat P$​。图像中三维点的重投影误差是图像中该点的投影与图像平面中对应的观测点之间的距离。在图2中我们的示例中，由于M是从三维空间到图像1的投影变换，所以图像1中$\hat P$​的投影点为$M\hat P$​。图1中$\hat P$​的匹配观测值为p。因此，图像1的重投影误差为距离$||M\hat P−p||$​。在公式2.3中发现的总体重投影误差是所有图像的重投影误差之和。对于有两幅以上图像的情况，我们只需在目标函数中添加更多的距离项：</p>
<script type="math/tex; mode=display">
\underset {\hat P}{\min} \sum _i ||M \hat P_i-p_i || ^2 \tag{2.4}</script><p>在实践中，存在着各种非常复杂的优化技术，它们可以很好地近似于问题。然而，对于该类的范围，我们将只关注其中一种技术，即非线性最小二乘的高斯-牛顿算法。一般的非线性最小二乘问题是找到一个最小化的$x∈R^n$​</p>
<script type="math/tex; mode=display">
\vert\vert r(x)\vert\vert^2 = \sum_{i=1}^mr_i(x)^2 \tag{2.5}</script><p>其中$r$是任何残差函数$r$：$R^n→R^m$​，这样对于某个函数f的$r(x)=f(x)-y$，输入$x$和观察$y$。当函数$f$为线性问题时，非线性最小二乘问题简化为正则的线性最小二乘问题。然而，回想一下，一般来说，我们的相机矩阵并不是仿射的。由于对图像平面的投影通常涉及到均匀坐标的除法，因此对图像的投影通常是非线性的。</p>
<p>请注意，如果我们将$e_i$​设置为一个$2×1$向量$e_i=M\hat P_i−p_i$​，那么我们可以重新表述我们的优化问题为：</p>
<script type="math/tex; mode=display">
\underset {\hat P}{\min} \sum _i e^i(\hat P)^2 \tag{2.6}</script><p>它可以完美地表示为一个非线性最小二乘问题。</p>
<p>在这些注释中，我们将介绍如何使用流行的高斯-牛顿算法来找到这个非线性最小二乘问题的近似解。首先，让我们假设我们对三维点$\hat P$​有一个有点合理的估计，我们可以用前面的线性方法来计算它。高斯-牛顿算法的关键见解是更新我们的估计，将其修正为一个更好的估计，从而最小化重投影误差。在每一步，我们想更新一些估计$\hat Pδ_P：\hat P=\hat P+δ_P$​。</p>
<p>但是我们如何选择更新参数$δ_P$​呢？高斯-牛顿算法的关键见解是线性化在当前估计$\hat P$​附近的残差函数。在我们的问题中，这意味着一个点P的残差e可以看作是：</p>
<script type="math/tex; mode=display">
e(\hat P+\delta_p) \approx e(\hat P)+\frac{\partial e}{\partial P}\delta_p \tag{2.7}</script><p>随后，将最小化问题转化为</p>
<script type="math/tex; mode=display">
\underset{\delta _P}{min} \vert \vert \frac {\partial e}{\partial P} \delta_P- (-e(\hat P)) \vert \vert^2 \tag{2.8}</script><p>当我们这样表示残差时，我们可以看到它采用了标准线性最小二乘问题的格式。对于$N$幅图像的三角剖分问题，线性最小二乘解为</p>
<script type="math/tex; mode=display">
\delta _P = -(J^TJ)^{-1}J^Te \tag{2.9}</script><p>其中</p>
<script type="math/tex; mode=display">
e = \left[
\begin {matrix}
e_1\\ 
\vdots
\\e_N
\end{matrix}
\right]=
\left[
\begin{matrix}
p_1-M_1\hat P
\\ \vdots
\\p_n-M_n\hat P
\end{matrix}
\right]\tag{2.10}</script><script type="math/tex; mode=display">
J=\left[
\begin {matrix}
\frac {\partial e_1} {\partial \hat P_1}& \frac {\partial e_1} {\partial \hat P_2}& \frac {\partial e_1} {\partial \hat P_3}\\
\vdots &\vdots& \vdots \\
\frac {\partial e_N} {\partial \hat P_1}& \frac {\partial e_N} {\partial \hat P_2}& \frac {\partial e_N} {\partial \hat P_3}
\end{matrix}
\right] \tag{2.11}</script><p>​        回想一下，一个特定图像$e_i$的残差向量是一个2×1向量，因为在图像平面上有二维空间。因此，在最简单的三角测量的两个相机情况($N=2$)中，这导致残差向量$e$是一个$2N×1=4×1$向量，雅可比矩阵$J$是一个$2N×3=4×3$矩阵。请注意该方法如何无缝地处理多个视图，因为通过将相应的行添加到e向量和J矩阵来解释额外的图像。在计算了更新$δ_P$之后，我们可以简单地对固定数量的步骤重复这个过程，或者直到它在数值上收敛。高斯-牛顿算法的一个重要性质是，我们假设残差函数接近我们的估计是线性的，这不能保证收敛。因此，在实践中，对估计数的更新次数设置一个上限总是有用的。</p>
<h2 id="3-从运动开始的仿射结构"><a href="#3-从运动开始的仿射结构" class="headerlink" title="3 从运动开始的仿射结构"></a>3 从运动开始的仿射结构</h2><p>在前一节的结尾，我们暗示了如何超越一个场景的两个视图来获得关于3D场景的信息。我们现在将探索将两个相机的几何形状扩展到多个相机。通过结合来自多个视角的点的观察，我们将能够同时确定场景的三维结构和摄像机的参数，即所谓的<strong>运动结构</strong>。</p>
<p><img src="/2021/12/07/L4/3.PNG" alt="图3：基于运动问题的总体结构的设置。"></p>
<p>在这里，我们正式地介绍了从运动问题出发的结构。假设我们有$m$个相机与相机转换$M_i$编码相机的内在和外在参数。设$X_j$为场景中的$n$个3D点之一。每个3D点可以在多个位于$x_{ij}$位置的摄像机中可见，即使用投影变换$M_i$对摄像机$i$图像的投影。运动结构的目的是从所有观测值$x_{ij}$中恢复场景的结构（$n$三维点$X_j$）和摄像机的运动（$m$投影矩阵$M_i$​）。</p>
<h3 id="3-1由运动问题引起的仿射结构"><a href="#3-1由运动问题引起的仿射结构" class="headerlink" title="3.1由运动问题引起的仿射结构"></a>3.1由运动问题引起的仿射结构</h3><p>在解决运动问题的一般结构之前，我们将首先从一个更简单的问题开始，即假设相机是仿射或弱视角。最终，由于缺乏透视图的缩放操作，这使得数学推导更容易解决这个问题。</p>
<p>之前，我们推导了上述透视和弱透视情况的方程。请记住，在全透视模型中，相机矩阵被定义为</p>
<script type="math/tex; mode=display">
M = \left[
\begin{matrix}
A & b
\\ v & 1
\end{matrix}
\right]\tag{3.1}</script><p>其中$v$是一些非零的$1×3$向量。另一方面，对于弱透视模型，$v=0$。我们发现这个性质使$MX$的齐次坐标等于$1$：</p>
<script type="math/tex; mode=display">
x=MX=\left[
\begin{matrix}
& m_1\\
& m_2\\
0&0&0&1
\end{matrix}
\right]
\left[
\begin{matrix}
X_1\\
X_2\\
X_3\\
1
\end{matrix}
\right]=
\left[
\begin{matrix}
m_1X\\
m_2x\\
1
\end{matrix}
\right]
\tag{3.2}</script><p>因此，当我们从齐次坐标移动到欧几里得坐标时，投影变换的非线性消失了，而弱透视变换仅仅作为一个放大镜。我们可以更紧凑地将投影表示为：              </p>
<script type="math/tex; mode=display">
\left[
\begin{matrix}
m_1X\\
m_2X
\end{matrix}
\right]=
\left[
\begin{matrix}
A &b
\end{matrix}
\right]X
=
AX+    b
\tag{3.3}</script><p>并以仿射$M_{affine}=[A\ \ b]$​.的格式表示任何相机矩阵因此，我们现在使用仿射相机模型来表示三维中的$X_j$​点和每个仿射相机中相应的观察结果(例如，相机$i$​中的$x_{ij}$​)。</p>
<p>从运动问题回到结构，我们需要从$m ,n$​观测中估计m个矩阵$M_i$​和n个世界坐标向量$X_j$​，总共有$8m+3n$个未知数。每个观测结果对每个相机产生$2$个约束，所以在$8m+3n$未知数中有$2mn$方程。我们可以用这个方程来知道我们需要拥有的每张图像中相应观测数的下界。例如，如果我们有$m=2$个相机，那么我们需要在3D中至少有$n$个$=16$点。然而，一旦我们在每张图像中都标记了足够的对应点，我们如何解决这个问题呢？</p>
<h3 id="3-2托马西和卡纳德分解方法"><a href="#3-2托马西和卡纳德分解方法" class="headerlink" title="3.2托马西和卡纳德分解方法"></a>3.2托马西和卡纳德分解方法</h3><p>在这部分中，我们概述了托马西和卡纳德求解仿射结构的分解方法。该方法主要包括数据定心步骤和实际分解步骤。</p>
<p><img src="/2021/12/07/L4/4.PNG" alt="图4：当应用定心步骤时，我们对所有的图像点进行平移，使其质心（记为左下红十字）位于图像平面的原点。同样地，我们将世界坐标系置为原点位于三维点的质心处（记为右上角的红十字）。"></p>
<p>让我们从数据定中心的步骤开始。在这一步中，主要的思想是将数据集中在原点。为此，对于每个图像$i$​，我们通过减去其质心$\hat x_{ij}$​来重新定义每个图像点$x_{ij}$​的新坐标$\bar {x_{ij}}$​​：</p>
<script type="math/tex; mode=display">
\hat x_{ij}= x_{ij}-\bar x_i=x_{ij}-\frac {1}{n}\sum_{j=1}^nx_{ij}\tag{3.4}</script><p>回想一下，来自运动问题的仿射结构允许我们定义图像点$x_{ij}$​、相机矩阵变量$A_i$​和$b_i$​，以及三维点$X_j$​之间的关系为：</p>
<script type="math/tex; mode=display">
x_{ij}=A_jX_j+b_i\tag{3.5}</script><p>在这个定心步骤之后，我们可以结合公式$3.4$中的中心图像点$\hat x_{ij}$​的定义和公式$3.5$中的仿射表达式：</p>
<script type="math/tex; mode=display">
\begin{align}
\hat x_{ij}&=\hat x_{ij}-\frac{1}{n}\sum_{k=1}^nx_{ik}\\
& =
A_iX_j-\frac {1}{n}\sum_{k=1}^nA_iX_k
\\
& =A_i(X_j-\frac {1}{n}\sum_{k=1}^nX_k)
\\
& =A_i(X_j-\bar X)\\
&=A_i\hat X_j 

\end{align}\tag{3.6}</script><p>从方程3.6中可以看出，如果我们将世界参考系统的起源转换为质心$\bar X$​​，那么图像点$x_{ij}$​​的中心坐标和3D点$\hat X_{ij}$​​的中心坐标仅通过一个$2×3$矩阵$A_i$​​进行关联。最终，分解方法的定心步骤允许我们创建一个紧凑的矩阵积表示，将三维结构与多个图像中的观测点联系起来。</p>
<p>但是，请注意，在矩阵乘积$\hat x_{ij}=A_i\hat X_j$​中，我们只能访问方程左侧的值。因此，我们必须以某种方式考虑出运动矩阵$A_i$​和结构$X_j$​。利用所有摄像机的所有观测结果，我们可以建立一个测量矩阵$D$，由$m$个摄像机中的$n$个观测结果组成(记住，每个$\hat x_{ij}$​入口都是一个$2×1$向量)：</p>
<script type="math/tex; mode=display">
D=\left[
\begin{matrix}
\hat x_11 & \hat x_12 &\cdots &\hat x_1n\\
\hat x_21 & \hat x_22 &\cdots &\hat x_2n\\
\vdots&\vdots&\ddots&\vdots \\
\hat x_m1 & \hat x_m2 &\cdots & \hat x_mn\\
\end{matrix}
\right]\tag{3.7}</script><p>现在回想一下，由于我们的仿射假设，D可以表示为$2m×3$​运动矩阵$M$(包括相机矩阵$A_1，…A_m$)和$3×n$结构矩阵$S$(包括3D点$X_1，…X_n$​​)的乘积。我们将使用的一个重要事实是秩$D$为$3$，因为$D$是两个最大维数为3的矩阵的乘积。</p>
<p>为了将$D$分解为$M$和$S$，我们将使用奇异值分解，$D=UΣV^T$​。因为我们知道秩为$D=3$，所以在$Σ$中只有$3$个非零奇异值$σ_1$，$σ_2$和$σ_3$。因此，我们可以进一步简化的表达式，得到以下分解方法：</p>
<script type="math/tex; mode=display">
\begin{align}
D&=U\sum V^T\\
    &=\left[
    \begin{matrix}u_1&\cdots&u_n
    \end {matrix}\right]
    \left[
    \begin{matrix}
    \sigma_1&0&0&0&\cdots&0\\
    0&\sigma_2&0&0&\cdots&0\\
    0&0&\sigma_3&0&\cdots&0\\
    0&0&0&0&\cdots&0\\
    \ & \ & \ & \ &\ddots &\ \\
    0&0&0&0&\cdots&0\\
    \end{matrix}
    \right]
    \left[
    \begin{matrix}v_1^T\\ \vdots \\ v_n^T
    \end {matrix}\right]\\
    & =\left[
    \begin{matrix}u_1&u_2&u_3
    \end {matrix}\right]
    \left[
    \begin{matrix}\sigma_1&0&0\\
    0&\sigma_2&0\\
    0&0&\sigma_3&\\
    \end {matrix}\right]
        \left[
    \begin{matrix}v_1^T\\ v_2^T\\ v_n^T
    \end {matrix}\right]\\
    &=U_3Σ_3V_3^T 
\end{align}    \tag{3.8}</script><p>在此分解中，$Σ_3$​定义为非零奇异值形成的对角矩阵，而$U_3$和$V_3T$分别取对应的$U$列和$V^T$​行得到。不幸的是，在实践中，由于测量噪声和仿射相机近似，秩$D&gt;3$。然而，请记住，当秩$D&gt;3$时，$U_3W_3V_3^T$​仍然是弗罗比尼乌斯范数意义上的最好的秩3近似。</p>
<p>经过仔细检查，我们发现矩阵积$Σ_3V_3^T$​​形成一个$3×n$​的矩阵，大小完全相同的结构矩阵$S$​类似，同样$U_3$​是一个$2m×3$矩阵，相同大小的运动矩阵M。虽然这种关联的组件SVD分解M和S导致一个物理和几何解的仿射结构从运动问题，这个选择不是一个唯一的解决方案。例如，我们也可以将运动矩阵设置为$M=U_3Σ_3$，将结构矩阵设置为$S=V_3^T$，因为在这两种情况下，观测矩阵$D$都是相同的。那么我们要选择什么因子分解呢？托马西和卡纳德得出结论，该因素分解的稳健选择是$M=U_3\sqrt{Σ_3}$和$S=\sqrt{Σ_3}V_3^T$​​。</p>
<h3 id="3-3-重建中的模糊性"><a href="#3-3-重建中的模糊性" class="headerlink" title="3.3 重建中的模糊性"></a>3.3 重建中的模糊性</h3><p>不过，我们发现在任何分解$D=MS$的选择中有固有的歧义，因为任何任意的、可逆的$3×3$矩阵$A$都可以插入到分解中：</p>
<script type="math/tex; mode=display">
D = MAA^{−1}S = (MA)(A^{−1}S) \tag{3.9}</script><p>这意味着从运动$M$获得的相机矩阵和从结构$S$获得的三维点可以乘以$10$个公共矩阵$a$。因此，我们的解决方案尚未确定，需要额外的约束来解决这种仿射歧义。当重构具有仿射模糊性时，这意味着保持了并行性，但度量尺度是未知的。</p>
<p>重建的另一类重要的歧义是相似度歧义，当重建被修正到相似度变换（旋转、平移和缩放）时，就会发生相似度歧义。一个只有相似性歧义的重构被称为度量重构。即使相机经过本质校准，这种模糊性也存在。好消息是，对于校准的相机，相似模糊是唯一的模糊。</p>
<p>事实上没有办法从图像中恢复一个场景的绝对尺度。除非我们做出进一步的假设（例如，我们知道图中房子的高度）或包含更多的数据，否则一个物体的尺度、绝对位置和规范方向总是未知的。这是因为某些属性可以补偿其他属性。例如，为了获得相同的图像，我们可以简单地向后移动对象，并相应地缩放它。在相机校准过程中出现了一个消除相似性模糊性的例子，我们假设我们知道校准点相对于现实世界参考系统的位置。这使我们能够知道棋盘上的正方形的大小，以学习三维结构的度量尺度。</p>
<h2 id="4-从运动开始的透视结构"><a href="#4-从运动开始的透视结构" class="headerlink" title="4 从运动开始的透视结构"></a>4 从运动开始的透视结构</h2><p>在研究了运动问题的简化仿射结构后，再考虑射影相机$M_i$​的一般情况。在一般情况下使用投影摄像机，每个相机矩阵$M_i$​包含$11$个自由度，因为它是被定义为：</p>
<script type="math/tex; mode=display">
M_i=\left[
\begin{matrix}
a_11 &a_12 &a_13 b_1\\
a_21 &a_22 &a_23 b_1\\
a_31 &a_32 &a_33 1
\end{matrix}
\right]
\tag{4.1}</script><p>此外，类似于仿射情况下的解可以找到一个仿射变换，解决结构和运动可以确定一个射影变换在一般情况下：我们总是可以任意应用一个4×4射影变换H运动矩阵，只要我们也变换结构矩阵的逆变换$H^{−1}$​。在图像平面上得到的观测结果仍然相同。</p>
<p>与仿射情况类似，我们可以从运动问题建立一般结构，从$m,n$观测$x_{ij}$估计$m$运动矩阵$M_i$和$n$三维点$X_j$​。因为相机和点只能在$4×4$投影变换（$15$个参数）上恢复，我们在$2mm$方程中有$11m+3n−15$未知数。根据这些事实，我们可以确定解决未知问题所需的观点和观察结果的数量</p>
<h3 id="4-1-代数方法"><a href="#4-1-代数方法" class="headerlink" title="4.1 代数方法"></a>4.1 代数方法</h3><p><img src="/2021/12/07/L4/5.PNG" alt="图5：在代数方法中，我们考虑顺序的，相机对来确定相机矩阵$M_1$和$M_2$，直到一个透视变换。"></p>
<p>图5：在代数方法中，我们考虑顺序的，相机对来确定相机矩阵$M_1$​和$M_2$​，直到一个透视变换。然后我们发现了一个透视变换H，即$M_1H=[I \ \ \ \  0]和M_2H=[A\ \ \ \ B]$​</p>
<p>我们现在将介绍代数方法，它利用基本矩阵F的概念来解决两个相机的运动问题的结构。如图5所示，代数方法的主要思想是计算两个相机矩阵$M_1$​和$M_2$​，这只能计算到一个透视变换H。由于每个Mi只能计算一个透视变换H，我们总是可以考虑一个H，这样第一个相机投影矩阵$M_1H^{−1}$​是典型的。当然，同样的转换也必须应用于第二个相机，这导致了显示的形式：</p>
<script type="math/tex; mode=display">
M_1H^{-1}=[I \ \ \ \ \ 0]\ \ \ \ M_2H^{-1}=[A\ \ \ \ \ B]\tag{4.2}</script><p>​        为了完成这一任务，我们必须首先使用前面的课程注释中提到的八点算法来计算基本矩阵F。我们现在将使用F来估计射影相机矩阵$M_1和M_2$​。为了做这个估计，我们将P定义为图像p和p’中相应观测值的相应三维点。由于我们已经将$H^{−1}$​应用于两个相机投影矩阵，所以我们也必须将H应用于结构，给我们$\tilde P=HP$​。因此，我们可以将像素坐标$p$和$p’$与转换后的结构联系起来如下：</p>
<script type="math/tex; mode=display">
\begin{matrix}
p=M_1P=M_1H^{−1}H P=[I\ \ |\ \ 0]\tilde P\\
p'=M_2P=M_2H^{−1}HP=[A\ \ |\ \ b]\tilde P
\end{matrix}\tag{4.3}</script><p>两个图像对应的p和p’之间的一个有趣的属性通过一些创造性的替换而出现：</p>
<script type="math/tex; mode=display">
\begin{align}
p' 
&= [A|b]\tilde P\\[2ex]
&=  A[I|0]\tilde P + b \\[2ex]
&= Ap + b\\[2ex]
\end{align} \tag{4.4}</script><p>利用公式4.4，我们可以将p’和b之间的交叉积写为：</p>
<script type="math/tex; mode=display">
p' × b = (Ap + b) × b = Ap × b \tag{4.5}</script><p>根据交叉积的定义，p’×b垂直于p’。因此，我们可以写道：</p>
<script type="math/tex; mode=display">
\begin{align}
0
&= p' ^T (p' × b)\\[2ex]
&= p' ^T (Ap × b) \\[2ex]
&= p' ^T · (b × Ap) \\[2ex]
&= p' ^T [b]_×Ap
\end{align}
\tag{4.6}</script><p>看看这个约束条件，它应该会提醒你基本矩阵$p’^TFp=0$​的一般定义。如果我们设置了$F=[b]_×A$​，那么提取A和b就会简单地分解为一个分解问题。</p>
<p>让我们从确定$b$开始。同样，根据交叉积的定义，我们可以简单地把$Fb$写成</p>
<script type="math/tex; mode=display">
F b = [b]_×Ab = (b × A)b = 0 \tag{4.7}</script><p>由于F是奇异的，$b$可以用SVD,在$||b||=0$的条件下计算为$k=0$的最小二乘解。</p>
<p>一旦$b$知道，我们就可以计算$A$。如果我们设置了一个$A=−[b]_×F$，那么我们可以验证这个定义满足$F=[b]_×A$​：</p>
<script type="math/tex; mode=display">
\begin{align}
[b_×]A' =
&−[b×][b×]F\\[2ex]
&= (bb^T − |b|^2I)F \\[2ex]
&= bb^TF + |b|^2F\\[2ex]
&= 0 + 1 · F \\[2ex]
&= F
\end{align}
\tag{4.8}</script><p>​    因此，我们确定了相机矩阵$M_1H^{−1}$和$M_2H^{−1}$的两个表达式：</p>
<script type="math/tex; mode=display">
\tilde M_1 = [I\ \ \ \  0] \ \ \ \ \ \ \ \tilde M_2 = [−[e_×]F \ \ \ \ e] \tag{4.10}</script><h3 id="4-2-从本征矩阵中确定运动"><a href="#4-2-从本征矩阵中确定运动" class="headerlink" title="4.2 从本征矩阵中确定运动"></a>4.2 从本征矩阵中确定运动</h3><p>改进由代数方法得到的重建的一个有用的方法是使用校准的相机。利用基本矩阵是标准化坐标基本矩阵的一种特殊情况，可以提取出相机矩阵的更精确的初始估计。回想一下，通过使用基本矩阵E，我们假设我们已经校准了相机，从而知道内在相机矩阵$K$。我们可以直接从归一化图像坐标，也可以从它与基本矩阵$F$和内在矩阵$K$的关系来计算基本矩阵$E$：</p>
<script type="math/tex; mode=display">
E = K^TFK \tag{4.11}</script><p>因为基本矩阵假设我们有校准的相机，我们应该记住它只有$5$个自由度，因为它只有编码外部参数：相机之间的旋转$R$和平移$t$。幸运的是，这正是我们想要提取的用来创建运动矩阵的信息。首先，记住基本矩阵E可以表示为</p>
<script type="math/tex; mode=display">
E = [t]_×R \tag{4.12}</script><p>因此，也许我们可以找到一种策略来将E纳入其两个组成部分。首先，我们应该注意到交叉积矩阵$[t]_×$是偏对称的。我们定义了两个我们将在分解中使用的矩阵：</p>
<script type="math/tex; mode=display">
W=\left[
\begin{matrix}
0&-1&0\\
1&0&0\\
0&0&1
\end{matrix}
\right]
,
\ \ \ \ \ \ \
Z=\left[
\begin{matrix}
0&1&0\\
-1&0&0\\
0&0&0
\end{matrix}
\right]
\tag{4.13}</script><p>我们稍后将使用的一个重要特性是$Z=diag(1,1,0)W$到一个标志。类似地，我们也将使用$ZW=ZW^T=diag(1,1,0)$到一个符号。</p>
<p>由于特征值分解的结果，我们可以创建一个已知的一般偏对称矩阵的块分解。因此，我们可以将$[t]_×$写为</p>
<script type="math/tex; mode=display">
[t]_× = UZU^T \tag{4.14}</script><p>其中$U$是某个正交矩阵。因此，我们可以将该分解数重写为：</p>
<script type="math/tex; mode=display">
E = Udiag(1,1,0)(W U^TR)\tag{4.15}</script><p>仔细观察这个表达式，我们发现它非常类似于奇异值分解$E=UΣV^T$，其中Σ包含两个相等的奇异值。如果我们知道E，并且我们假设它采用了$E=Udiag(1,1,0)V^T$的形式，那么我们得到了E的以下分解：</p>
<script type="math/tex; mode=display">
[t]_×=UZU^T，\ \ R=UWV^T \ \ or\ \  UW^TV^T \tag{4.17}</script><p>通过检验，我们可以证明所给定的分解是有效的。我们还可以证明没有其他因素的分解。$[t]_×$的形式是由它的左零空间必须与E的零空间相同而决定的。给定一元矩阵U和V，任何旋转R都可以分解为$UXV^T$，其中X是另一个旋转矩阵。在替换这些值后，我们得到了$ZX=diag(1,1,0)$。因此，X必须等于W或$W^T$。</p>
<p>请注意，E的这种分解只保证了矩阵$UWV^T$或$UW^TV^T$是正交的。为了确保R是一个有效的旋转，我们只是要确保R的行列式是正的：</p>
<script type="math/tex; mode=display">
R=(detUW^TV^T)UWV^T\ \ \ \ or \ \ \ \ (detUW^TV^T)UW^TV^T \tag{4.17}</script><p>与类似于旋转$R$如何取两个潜在值相似，平移向量$t$也可以取几个值。从交叉积的定义中来看，我们知道</p>
<script type="math/tex; mode=display">
t × t = [t]_×t = UZU^T t = 0 \tag{4.18}</script><p>知道$U$是一元的，我们可以发现$||[t]_×||F=\sqrt{2}$。因此，我们从这个分解的$t$估计将从上面的方程和$E$是已知的，这意味着</p>
<script type="math/tex; mode=display">
t= \pm U\left[\begin{matrix}0\\0\\1\end{matrix}\right]=\pm u_3 \tag{4.13}</script><p>其中$u_3$是$U$的第三列。通过检查，我们还可以通过将$[t]_×=UZU^T$重新格式化为已知的向量$t$来验证我们得到相同的结果。</p>
<p><img src="/2021/12/07/L4/blog\source\_posts\视觉4.assets\image-20211206004541777-16387227427507.png" alt="image-20211206004541777"></p>
<p>图6：从基本矩阵中提取相对相机旋转R和平移t有四种可能的解决方案。然而，只有(a)中重建点在两个摄像机前。（图片取自哈特利和齐泽尔曼出版社的教科书第260页）</p>
<p>如图6所示，由于$R$和$t$同时存在两种选项，因此$R$和$t$都存在两种选项。直观地说，这四对对包括所有$16$种可能的对，即在特定方向旋转相机或在相反方向旋转相机，以及在特定方向或相反方向移动相机的选择。因此，在理想条件下，我们只需要三角化一个点来确定正确的一对$R$，$t$对。对于正确的一对$R$，$t$，三角化的点$\hat P$存在于两个相机的前面，这意味着它相对于两个相机参考系统都有一个正的$z$坐标。由于测量噪声，我们通常不依赖于三角点，而是三角测量许多点，并确定正确的一对$R$，$t$，作为两个相机前包含这些点的大多数。</p>
<h2 id="5-一个来自运动管道的结构示例"><a href="#5-一个来自运动管道的结构示例" class="headerlink" title="5 一个来自运动管道的结构示例"></a>5 一个来自运动管道的结构示例</h2><p>在找到相对运动矩阵$M_i$后，我们可以用它们来确定点$X_j$的世界坐标。在代数方法的情况下，这些点的估计将修正透视变换h。在从基本矩阵中提取相机矩阵时，估计可以被知道。在这两种情况下，三维点都可以通过前面描述的三角测量方法从估计的相机矩阵中计算出来。</p>
<p>对多视图案例的扩展可以通过链接成对的摄像机来完成。利用代数方法或基本矩阵，我们可以利用代数方法得到任意一对相机的相机矩阵和三维点的解，只要有足够的点对应。重建的3D点与相机对之间可用的点对应关系相关联。我们接下来将看到，这些成对的解决方案可以以一种称为捆绑调整的方法组合在一起（优化）。</p>
<h3 id="5-1-套件调整"><a href="#5-1-套件调整" class="headerlink" title="5.1 套件调整"></a>5.1 套件调整</h3><p>到目前为止，我们讨论的从运动问题解决结构的方法有很大的局限性。该分解方法假设所有的点在每幅图像中都是可见的。这是不太可能发生的，因为当我们有很多图像，或者有些图像相距遥远时，就会被遮挡，无法找到对应关系。最后，代数方法产生了成对的解，可以组合成一个摄像机链，但不能解决使用所有摄像机和三维点的相干优化重建。</p>
<p>为了解决这些限制，我们引入了<strong>束调整</strong>，这是一种从运动问题中求解结构的非线性方法。在优化中，我们的目标是尽量减少重投影误差，即一个重建点对估计摄像机的投影与其对所有摄像机和所有点的相应观测值之间的像素距离。之前，当讨论三角剖分的非线性优化方法时，我们主要关注这两个相机盒，我们自然地假设每个相机看到了两者之间的所有对应关系。然而，由于束束调整处理几个相机，它只计算每个相机可以看到的观测结果的重投影误差。最终，这个优化问题与我们在讨论三角测量的非线性方法时引入的问题非常相似。</p>
<p>求解束调整非线性优化的两种常用方法包括高斯-牛顿算法和莱文伯格-马夸特算法。您可以参考上一节关于高斯牛顿算法的细节，并参考哈特利和泽瑟曼教科书，了解更多关于莱文伯格-马夸特算法的细节。</p>
<p>综上所述，与我们所调查的其他方法相比，管束调整有一些重要的优点和局限性。它特别有用，因为它可以平滑地处理大量的视图，而且也可以处理每个图像都不能观察到特定点时的情况。然而，主要的限制是它是一个特别大的最小化问题，因为参数随着视图数量的增长。此外，由于它依赖于非线性优化技术，因此需要一个很好的初始条件。因此，束调整经常被用作来自运动实现的大多数结构的最后一步（即，在因子分解或代数方法之后），因为一种因子分解或代数方法可以为优化问题提供一个很好的初始解决方案。</p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
        <tag>cs231a</tag>
      </tags>
  </entry>
  <entry>
    <title>npuSE Chapter 1：绪论</title>
    <url>/2021/12/06/Chaper1%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="npuSE-Chapter-1：绪论"><a href="#npuSE-Chapter-1：绪论" class="headerlink" title="npuSE Chapter 1：绪论"></a>npuSE Chapter 1：绪论</h1><h2 id="1-1-多项式拟合的例子"><a href="#1-1-多项式拟合的例子" class="headerlink" title="1.1 多项式拟合的例子"></a>1.1 多项式拟合的例子</h2><p>假设有这样一种情况，我们通过函数产生$N$个数据点，并在其中加入服从高斯分布的随机噪声，能否仅通过这$N$​个数据点找出其隐含的分布规律，也就是他们对应的函数。这就涉及到了去寻找一条曲线去拟合这些数据点，引出了本节所讲的“多项式曲线拟合”</p>
<p><img src="https://s4.ax1x.com/2021/12/06/oyZ224.png" alt></p>
<p>假设有一个训练集，其中有$N$个观测值$x$，也就是$N$个测试样本，那这个训练集可以表示为：$x\equiv(x_1,\cdots,x_N)^{\rm T}$</p>
<p>同时，还有$X$对应的目标值：$t\equiv(t_1,\cdots, t_N)^{\rm T}$</p>
<p>我们要利用这些以上数据去建立曲线去为新的预测。</p>
<p>多项式函数：</p>
<script type="math/tex; mode=display">
y(x, w)= w_0+w_1x+w_2x^2+\cdots+ w_Mx^{ M}=\sum_{j=0}^{M}w_jx^{j}\tag{1.1}</script><p>我们的任务就是去寻找适当的多项式系数$w_0$,$w_1$,$w_M$，构造多项式曲线$y(x,w)$。为了寻找最优的多项式系数，我们构造出误差函数（error function,也有的地方称为损失函数）：</p>
<script type="math/tex; mode=display">
E(w)=\frac{1}{2}\sum_{n=1}^{N}\{y(x_n,w)-t_n\}^2\tag{1.2}</script><p>$E(w)$达到最小式，我们构造的和目标值最接近，对数据拟合的最好。当$E(w)=0$,  表明$y(x_n,w)$​经过每个点。</p>
<p>E(w)的几何说明：</p>
<p><img src="https://s4.ax1x.com/2021/12/06/oyZhrR.png" alt></p>
<p>选择的$w$向量使得$E(w)$​越小越好，来解决曲线拟合问题。</p>
<p>$E(w)$​关于$w$是二次函数，他的导数是关于$w$的一次函数，因此有唯一解，记为$w*$​</p>
<p>不同的$M$​值对应的$E(w)$​最小所获得的曲线</p>
<p><img src="https://s4.ax1x.com/2021/12/06/oyZ4q1.png" alt></p>
<p>从上图可以看出，不同次数的多项式函数对数据的拟合程度不同，虽然次数越高对训练集的拟合程度越好，它甚至可以穿过每一个训练集的每一个数据点，让错误函数为零，但是，这会出现过拟的现象。</p>
<p>“过拟”是指建立的模型对训练数据拟合的非常好，但是对测试数据的预测能力非常差。</p>
<p>使用100个测试数据集，使用新的噪声，然后按照均方根$E_{\rm RMS}$的方法对不同的$M$值测得的误差，这个均方差错误函数可以描述出对不同样本数和不同规模的数据的拟合程度。</p>
<script type="math/tex; mode=display">
E_{\rm RMS} =\sqrt{\frac{2E(w^*)}{N}}\tag{1.3}</script><p><img src="https://s4.ax1x.com/2021/12/06/oyZRxJ.png" alt></p>
<p>值得一提的是，当训练样本数越多的时候，训练出的模型越好，如下图所示同样是次数为$9$​的多项式函数曲线，左图是使用$15$​个样本训练出来的，而右图是使用$100$​个样本训练出来的，可以明显看出，$100$​​个样本训练出来的多项式函数对样本的拟合程度更好。</p>
<p><img src="https://s4.ax1x.com/2021/12/06/oyZoa6.png" alt></p>
<p>为了避免过拟现象，我们可以采用“正则化”的方法，为误差函数末尾添加正则项：</p>
<script type="math/tex; mode=display">
\tilde{E}(w)=\frac{1}{2}\sum_{n=1}^N\{y(x_n,w)-tn\}^2+\frac{\lambda}{2}||w||^2\tag{1.4}</script><p>其中：</p>
<script type="math/tex; mode=display">
||w||^2=w^{\rm T}w=w_0^2+w_1^2+\cdots+w_M^2</script><p>$λ$衡量$E$和惩罚项之间的权重。 $\frac{\lambda}{2}||w||^2$是惩罚项，避免获得系数过大。</p>
<p>可以从式子看出，当多项式系数数量级增长时，会导致错误函数值变大，这样就能有效抑制多项式系数数量级的增长。</p>
<p><img src="https://s4.ax1x.com/2021/12/06/oyZIVx.png" alt></p>
<p>对多项式的存在的重要性有控制作用，对其数值的选择也至关重要，其控制的重要性见下图。</p>
<p><img src="https://s4.ax1x.com/2021/12/06/oyZTIK.png" alt></p>
<p>可惜的是，目前作者还没有提出如何寻找出使错误函数最小的方法，在Coursera上Andrew NG的机器学习视频中，在一开始的多元线性函数参数寻优的方法中，就提及了”梯度下降”的方法。</p>
<p><img src="https://s4.ax1x.com/2021/12/06/oyZbGD.png" alt></p>
<h2 id="1-2-概率理论"><a href="#1-2-概率理论" class="headerlink" title="1.2 概率理论"></a>1.2 概率理论</h2><p>概率基本知识：</p>
<p>例子：</p>
<p><img src="https://s4.ax1x.com/2021/12/06/oyZqRe.png" alt></p>
<p>两个盒子，红色和蓝色。红色盒子里有两个苹果，六个橘子。蓝色盒子里有三个苹果，一个橘子。随机选取一个盒子，从这个盒子随机选取一个水果，然后观察，放回原处。</p>
<p>盒子变量用$B$表示包含$r($红色$)$和$b($蓝色$)$  $ p(B=r)=4/10$ </p>
<p>水果变量用F表示包含$a($苹果$)$和$o($橘子$)$</p>
<p><img src="https://s4.ax1x.com/2021/12/06/oyZLxH.png" alt></p>
<p>联合概率分布：</p>
<script type="math/tex; mode=display">
P(X=x_i,Y=y_i)=\frac{n_{ij}}{N}</script><p>边缘概率分布：</p>
<script type="math/tex; mode=display">
P(X=x_i)=\sum_{j=1}^{L}P(X=x_i, Y=y_i)</script><p>条件概率分布：</p>
<script type="math/tex; mode=display">
P(Y=y_i|X=x_i)=\frac{n_{ij}}{c_i}</script><p>两个主要的法则和定理：</p>
<p>加法法则：</p>
<script type="math/tex; mode=display">
P(X=x_i)=\sum_{j=1}^{L}P(X=x_i,Y=y_i)</script><p>乘法法则：</p>
<script type="math/tex; mode=display">
\begin{align}
P(X=x_i,Y=y_i)&=\frac{n_{ij}}{N}\\
&=\frac{n_{ij}}{c_i}\cdot\frac{c_i}{N}\\
&= P(Y=y_i|X=x_i)P(X=x_i)

\end{align}</script><p>贝叶斯定理：</p>
<script type="math/tex; mode=display">
P(Y|X)=\frac{P(X|Y)P(Y)}{P(X)}</script><h3 id="1-2-1概率密度"><a href="#1-2-1概率密度" class="headerlink" title="1.2.1概率密度"></a>1.2.1概率密度</h3><p>在上面考虑的都是离散值，对于连续值而言，就要使用到“概率密度”的概念。</p>
<p>假设$x$​​落在区间$(x,x+δx)$​​内，且$δx\to0$​，则$x$出现的概率为$p(x)δx$，其中$p(x)$称为概率密度。如下图：</p>
<p><img src="https://s4.ax1x.com/2021/12/06/oyZzZt.png" alt></p>
<p>概率密度也可称为概率密度函数，它应该满足以下两个条件：</p>
<script type="math/tex; mode=display">
\begin{matrix}
p(x)\geq0\\[2ex]
\int_{-\infty}^\infty p(x) = 1
\end{matrix}</script><p>落在区间$(a,b)$的概率为：</p>
<script type="math/tex; mode=display">
p(x\in(a, b))=\int_{a}^b p(x){\rm d}x</script><p>概率密度在向量上的应用：</p>
<p>概率密度的概念同样可以使用在向量情况。假设我们有若干个变量$x_1, \cdots ,x_D$，可以定义一个联合概率密度$p(x)=p(x_1,\cdots,xD)$​，其同样要满足以下两个条件：</p>
<script type="math/tex; mode=display">
\begin{matrix}
p(x)\geq0\\[2ex]
\int_{-\infty}^\infty p(x) = 1
\end{matrix}</script><p>在连续值的情况下，加法规则和乘法规则变换成如下形式：</p>
<script type="math/tex; mode=display">
\begin{matrix}
p(x)=\int p(x, y){\rm d}y\\[2ex]
p(x, y)= p(y|x)\cdot p(x)
\end{matrix}</script><h3 id="1-2-2-期望和方差"><a href="#1-2-2-期望和方差" class="headerlink" title="1.2.2 期望和方差"></a>1.2.2 期望和方差</h3><h4 id="1-期望-Expectation-："><a href="#1-期望-Expectation-：" class="headerlink" title="1. 期望(Expectation)："></a>1. 期望(Expectation)：</h4><p>描述平均取值大小</p>
<p>对于服从$p(x)$概率分布的的函数$f(x)$，其数学期望定义如下：</p>
<p>若$f(x)$是离散的：</p>
<script type="math/tex; mode=display">
E[f]=\sum_{x}p(x)f(x)</script><p>若$f(x)$是连续的：</p>
<script type="math/tex; mode=display">
E[f]=\int p(x) f(x){\rm d}x</script><p>对于有多个变量的函数，其数学期望可参照$E_x[f(x,y)]$​​,这种形式（假设有两个变量），这表明$f(x,y)$​按照变量$x$​的概率分布$p(x)$​,然后求函数$f(x,y)$的平均值，其数学期望的结果是关于变量y的函数,对于这种情况，我们可以考虑使用”条件数学期望”，其定义如下：</p>
<script type="math/tex; mode=display">
E_x[f|y]=\sum_{x}p(x|y)f(x)</script><h4 id="2-方差-Variance-："><a href="#2-方差-Variance-：" class="headerlink" title="2. 方差(Variance)："></a>2. 方差(Variance)：</h4><p>变量与均值的偏离程度。</p>
<p>定义如下：</p>
<script type="math/tex; mode=display">
{\rm var}[f]=E[(f(x)-E[f(x)])^2]</script><p>或者展开是：</p>
<script type="math/tex; mode=display">
{\rm var}[f]=E[f(x)^2]-E[f(x)]^2</script><h3 id="1-2-3-贝叶斯概率"><a href="#1-2-3-贝叶斯概率" class="headerlink" title="1.2.3 贝叶斯概率"></a>1.2.3 贝叶斯概率</h3><p>贝叶斯学派（Bayesian）和频率学派(Frequentist)在对待概率（或是不确定度）上的区别，从根本上说，他们是出发的理念不同，频率学派认为参数皆有定值，只是我们还没有观察到，所以可以通过做大量的实验去统计其潜在的规律，得出参数值。贝叶斯学派则认为参数是随机值，因为我们没有观察到，所以参数和随机值没什么区别，参数是可以有分布的。但是这两个学派中也有许多想通的地方。</p>
<p>所以这小节一开始就提出了有许多事情是无法通过大量实验去预测结果的，比如，月亮是否在绕日轨道上，北极冰盖是否在本世纪末消失。所以作者建议我们用贝叶斯的观点去看待概率，其提供了对不确定度的量化。</p>
<p>贝叶斯学派经常关注的是后验概率，将先验概率转化为后验概率。</p>
<p>现在我们结合贝叶斯定理和在1.1节中提到的多项式拟合解释一下。贝叶斯定理定义：</p>
<script type="math/tex; mode=display">
p(w|D)=\frac{p(D|w)p(w)}{p(D)}</script><p>在多项式拟合中，我们的目的是寻找模型参数，在观察数据之前，先假设的概率分布为$p(w)$，$p(w)$就是所谓的先验概率。数据的影响可表示为条件概率$p(D|W)$，其表示不同参数向量导致不同的数据的可能性，也被称为似然函数，它的准确形式表达会在之后的章节详细介绍。$p(W|D)$被称为后验概率。其意义就是在观察$D=\{t_1,\cdots, tn\}$后，对参数向量不确定度的评价。因此，可以看出，后验概率正比于似然函数乘与先验概率：</p>
<script type="math/tex; mode=display">
{\rm posterior }∝{\rm likelihood}\times{\rm prior}</script><p>特别地，在频率学派中，通常关注于找到最大似然函数（maximum likelihood），其中$w$将$p(w|D)$​的值最大化。似然函数的负对数是错误函数（error function），最大化似然函数等价于最小化错误函数。</p>
<h3 id="1-2-4-高斯分布"><a href="#1-2-4-高斯分布" class="headerlink" title="1.2.4 高斯分布"></a>1.2.4 高斯分布</h3><p>本小节主要是讲高斯分布及其应用，其也称为正态分布。定义如下：</p>
<script type="math/tex; mode=display">
N(x|\mu,\sigma^2)=\frac{1}{(2\pi \sigma^2)^{\frac{1}{2}}}\exp\{-\frac{1}{2\sigma^2}(x-\mu)^2\}</script><p>其中，$\mu$是平均值，$\sigma^2$是方差，$\sigma$称为标准差</p>
<script type="math/tex; mode=display">
E[x]=\int_{-\infty}^{\infty}N(x|\mu,\sigma^2)x{\rm d}x=\mu</script><script type="math/tex; mode=display">
E[x]=\int_{-\infty}^{\infty}N(x|\mu,\sigma^2)x^2{\rm d}x=\mu^2+\sigma^2</script><script type="math/tex; mode=display">
{\rm var}[x]=E[x^2]-E[x]^2=\sigma^2</script><p>下图是单变量的高斯分布图：</p>
<p><img src="https://s4.ax1x.com/2021/12/06/oyZjsA.png" alt></p>
<p>高斯分布应满足以下两个条件：</p>
<script type="math/tex; mode=display">
N(x|\mu, \sigma^2)>0</script><script type="math/tex; mode=display">
\int_{-\infty}^{\infty} N(x|\mu, \sigma^2){\rm d}x=1</script><p>接下来，我们讨论如何找到一个给定数据集的高斯分布。</p>
<p>给定一个数据集：</p>
<script type="math/tex; mode=display">
x=(x_1,\cdots,x_n)^{\rm T}</script><p>如下图所示：</p>
<p><img src="https://s4.ax1x.com/2021/12/06/oyZvqI.png" alt></p>
<p>假设产生这些数据点的是一个均值为u，方差为σ2的高斯分布，只是这两个参数的具体值还不知道罢了。</p>
<p>因此，似然函数（likelihood function）如下：</p>
<script type="math/tex; mode=display">
p(X|\mu,\sigma^2)=\Pi_{n=1}^N N(x_n|\mu,\sigma ^2)</script><p>它的直观意义是通过不断调整$u$、$σ^2$参数，让各个数据点的高斯值相乘，使得$p(x|u,σ^2)$最大，那么对应的$u$、$σ^2$就是所要求的高斯分布的参数。</p>
<p>为了计算和分析的方便，可以将似然函数转换成（自然）对数形式，因为（自然）对数是单调递增的，其取最大值时，似然函数也会取到最大值。（自然）对数形式如下：</p>
<script type="math/tex; mode=display">
\ln p(X|\mu,\sigma^2)=-\frac{1}{2\sigma^2}\sum_{n=1}^N(x_n-\mu)^2-\frac{N}{2}\ln\sigma^2-\frac{N}{2}\ln(2\pi)</script><p>通过以下式子可以找到最优的$u$、$σ^2$​：</p>
<script type="math/tex; mode=display">
\mu_{\rm ML}=\frac{1}{N}\sum_{n=1}^{N}x_n</script><p>$\ln$对$u$求导等于$0$</p>
<script type="math/tex; mode=display">
\sigma^2_{\rm ML}=\frac{1}{N}\sum_{n=1}^{N}(x_n-\mu_{\rm ML})^2</script><p>$\ln$对$σ^2$求导等于$0$</p>
<p>但是，使用最大似然函数求高斯分布的方法存在一定限制，会产生”偏离（bias）”现象。具体的解释在以后的章节……（均值是正确的，但是方差存在问题）</p>
<p>回顾曲线拟合：</p>
<p>在第一章1.1中时，我们从错误函数最小化去求多项式曲线模型中的参数，在这个小节中，我们从概率的角度去解决这个问题。多项式曲线模型和错误函数如下：</p>
<script type="math/tex; mode=display">
E(w)=\frac{1}{2}\sum_{n=1}^{N}\{y(x_n,w)-t_n\}^2\tag{1.2}</script><p>首先，假设对于给定的训练值，对应的目标值服从高斯分布，那么</p>
<script type="math/tex; mode=display">
p(t|x,w,\beta)=N(t|y(x,w), \beta^{-1})</script><p>其中$β^{-1}=σ^2$，这个式子表示给定$x$时得到$t$的概率，可以用下图表示：</p>
<p><img src="https://s4.ax1x.com/2021/12/06/oyeSdP.png" alt></p>
<p>因此，我们可以构造似然函数用训练数据去找出最优的参数$w$和$β$，似然函数如下：</p>
<script type="math/tex; mode=display">
p(t|x,w,\beta)=\Pi_{n=1}^N N(t_n|y(x_n, w), \beta^{-1})</script><p>转化为对数形式：</p>
<script type="math/tex; mode=display">
\ln p(t|x,w,\beta)=-\frac{\beta}{2}\sum_{n=1}^{N}\{y(x_n,w)-t_n\}^2+\frac{N}{2}\ln\beta-\frac{N}{2}\ln(2\pi)</script><p>设：$A=\ln p(t|x,w,\beta)$，$B =-\frac{\beta}{2}\sum_{n=1}^{N}\{y(x_n,w)-t_n\}^2$，$C =\frac{N}{2}\ln\beta-\frac{N}{2}\ln(2\pi)$</p>
<p>$A$​​是$w$​和$β$​的函数，先将$β$​固定，那么寻求$A$​的最大值，只依赖于$w$​，可以将$C$​去掉，将$A$最大化相当于将$B$最小化，最后将系数$β/2$ 换成$1/2$。可以看出，寻找最优的$WML$时，最大化似然函数等价于最小化错误函数，对于$β$，可以使用下列式子得到最优值。</p>
<script type="math/tex; mode=display">
\frac{1}{\beta_{\rm ML}}=\frac{1}{N}\sum_{n=1}^{N}\{y(x_n, w_{\rm ML})-t_n\}^2</script><h2 id="1-3-模型选择"><a href="#1-3-模型选择" class="headerlink" title="1.3 模型选择"></a>1.3 模型选择</h2><p>在之前提到的多项式曲线拟合中就可以看出，多项式的最高次数影响着所建模型的对测试数据（testing data）性能，项数小，拟合效果不好，项数过大，容易出现过拟合现象（over-fitting）。这就涉及到了一个模型选择的问题。</p>
<p>如果我们有大量的数据，可以用来建立多个模型，然后再使用同一独立的数据集去评价各个模型的性能，选取性能最好的那个模型及其参数。如果使用小数据多次迭代进行模型比较选择，容易出现过拟的现象。但是，在许多情况下，提供给建模的训练和测试数据都十分有限，又想建个好模型，怎么办呢？</p>
<p>解决这个窘境的办法之一就是使用交叉验证（cross-validation），将可用的数据集分成$S$份（一般是分成相同大小），用$S-1$份去训练各个模型，用剩下的一份去测试模型，如此重复$S$次，将各个模型的性能平均，选取平均性能最好的模型和参数。图解如下：</p>
<p><img src="https://s4.ax1x.com/2021/12/06/oyepIf.png" alt></p>
<p>交叉验证的主要缺点就是S决定了建模比较过程中的迭代次数，如果S过大的话，而且单个模型中还会有多个复杂的模型参数，这会造成大量的计算花费。因此，理想的情况是仅使用训练数据（training data），对多个模型和参数的选择比较在一次训练过程（training run）完成。所以我们要找到一种仅依赖于训练数据并且不会引起过拟的性能评估方法。</p>
<p>在历史上，其中之一就是the Akaike information criterion, or AIC (Akaike, 1974)，通过使下面的式子达到最大来选择模型：</p>
<h2 id="1-4-维数灾难"><a href="#1-4-维数灾难" class="headerlink" title="1.4 维数灾难"></a>1.4 维数灾难</h2><p>维数灾难的意思是模型复杂度随着空间维数的增加而成指数增长。这一节举了两个例子来说明这个问题。一个是石油、水、天然气中的成分的例子，另一个仍然是curve fitting，但扩展到高维空间，在高维空间我们的模型会变成1.74这个样子，复杂度陡增:</p>
<script type="math/tex; mode=display">
y(x,w)=w_0+\sum_{i=1}^{D}w_i x_i+\sum_{i=1}^{D}\sum_{j=1}^{D}w_{ij}x_ix_j+\sum_{i=1}^{D}\sum_{j=1}^{D}\sum_{k=1}^{D}w_{ij}x_ix_jx_k</script><p>其中，$D$​为变量个数。</p>
<p>我们前面的多项式拟合问题中只有一个输入变量，在实际的问题中，可能就有多个变量，分布在高维空间中。</p>
<p><img src="https://s4.ax1x.com/2021/12/06/oyePJS.png" alt></p>
<p>三个不同的状态：</p>
<p>红色表同质</p>
<p>绿色表环形</p>
<p>蓝色表层状</p>
<p>求$x$属于哪一类</p>
<p><img src="https://s4.ax1x.com/2021/12/06/oyeiRg.png" alt></p>
<p>现在要对一个点$(x_6,x_7)$​（那个黑叉）进行分类。</p>
<p>我们一般的做法是将其分为多个大小相同的 cell，黑叉所在的 cell 里最多的类别作为黑叉的类别。比如上面所示，$x$​应该被分为红色那个类别。</p>
<p>这就引发了一个问题：现在我们的输入是$(x_6,x_7)$,是二维的，如果我们输入时三维的呢？</p>
<p>我们需要把训练空间需要时三维的。我们在二维的情况下有$42$个cells，三维的时候就需要分为$43$cells。同理$n$维的话，需要$4n$​个cell。如下图，可见这是随着维数呈指数增长的。</p>
<p><img src="https://s4.ax1x.com/2021/12/06/oyeCi8.png" alt></p>
<p>再例如我们有一个$D$维的球体，假设体积$V_D(r) = K_Dr^D$, $r$代表半径，其中$K_D$与 $D$ 有关。</p>
<p>我们需要求 $r=1$ 与 $r=1-ε$ 之间的比例</p>
<script type="math/tex; mode=display">
\frac{V_D(1)-V_D(1-ε)}{V_D(1)}=1-(1-ε)^D</script><p><img src="https://s4.ax1x.com/2021/12/06/oyeFzQ.png" alt></p>
<p>最后提到维数灾难并不能阻止我们解决高维空间的问题，原因有二</p>
<ol>
<li><p>真实的数据通常在一个有限的、较低维度的空间内，尤其是目标变量发生重要改变的方向非常有限；</p>
</li>
<li><p>真实数据往往有一定的平稳性：通常来讲输入变量的细小变化也只能引起目标变量的细小变化，所以我们可以利用插值方法预测目标变量。</p>
</li>
</ol>
<h2 id="1-5-决策理论"><a href="#1-5-决策理论" class="headerlink" title="1.5 决策理论"></a>1.5 决策理论</h2><p> 概率论、决策理论、信息论是机器学习的三个理论基础。概率论说的已经很多了，决策理论提及的比较少。简单说就是当我们已经有了概率结果$p(t)$后，如何做出判断。如果$p(t)=0.99$，这个判断相对容易一点；如果$p(t)=0.6$，我们会觉得不太可信。</p>
<p>例如：</p>
<p>癌症的例子：</p>
<p>一个患者 做了 $X$ 光检查，结果用 $x$ 表示。</p>
<p>需要判断他是一个癌症患者或者是非癌症患者，用$C$表示。$C=0$标示癌症，$C=1$标示正常$(C_0，C_1)$ 。推测问题包括取得$p(x,ck)$,它给了我们对这问题最完整的概率描述，这是推理阶段，最后我们还是必须决定是否给这个患者治病，就是决定阶段。</p>
<p>现在我们关心的就是，我们获得了一张 $x$ 光照片，怎么放入癌症和正常的这两个类别中， 也就是 $p(C|x)$。</p>
<p>使用贝叶斯法则如下：</p>
<script type="math/tex; mode=display">
p(C|x)=\frac{p(C)p(x|C)}{p(x)}</script><p>$P(C_1)$代表人群中癌症患者的比例（就是随机一个人在做 $X$ 光之前，是癌症患者的概率）也就是先验概率。我们的直觉告诉我们，我们的直觉告诉我们要选择一个后验概率较大的类，如果我们不想把 $x$​​ 放到错误的类别中。下面就要证明这种直觉是正确的。</p>
<h3 id="1-5-1-最小化错分概率"><a href="#1-5-1-最小化错分概率" class="headerlink" title="1.5.1 最小化错分概率"></a>1.5.1 最小化错分概率</h3><p>我们需要一个规则，对输入的每个$x$，将其标记类别。假设这个规则将$x$分配到$K$个区域，$R_k$ 叫做决策区域，$R_k$中的 $x$ 都将分配到 $C_k$ 中。在这些决策区域之间的部分叫做决策边界。注意：不是所有的的决策区域都是连续的。</p>
<script type="math/tex; mode=display">
\begin{align}
p({\rm mistake}) &= p(x\in R_1,C_2)+p(x\in R_2,C_1)\\[2ex]
&= \int_{R_1}p(x,C_2){\rm d}x+\int_{R_2}p(x, C_1){\rm d}x
\end{align}</script><p>对于一个给定的$x$：</p>
<script type="math/tex; mode=display">
\begin{align}
p({\rm correct}) &= \sum_{k=1}^{K}p(x\in R_k,C_k)\\[2ex]
&= \sum_{k=1}^{K}\int_{R_k}p(x,C_k){\rm d}x
\end{align}</script><p>要使得$p({\rm correct})$最大 （$p({\rm mistake})$最小），就需要选择一个 $C_k$使得 $p(x,C_k)$最大， 而 $p(x,C_k)= p(C_k|x)p(x)$,而对于所有的 $p(x,C_k)$，$p(x)$都是一样的，所以只需要使得 $p(C_k|x)$最大，而他就是后验概率。这就解释了我们为什么使用最大后验概率。</p>
<p>最小化误分类比例可以通过$P(x,C_1)$和$P(x,C_2)$来判断就可以了。我们可以看下图，这图很简单，假设$P(x,C_1)$和$P(x,C_2)$有着这样的两条曲线，绿色、蓝色、红色所处的概率关系各不相同。$R_1$，$R_2$称作决策区域，其分界面是决策边界。如果将分界面设置在$x-$处，红色就会是误分类的点。向左移动$x-$到$x_0$处，红色区域消失，完全按照$P(x,C_1)$和$P(x,C_2)$的大小来分类，使误分类率最低。</p>
<p><img src="https://s4.ax1x.com/2021/12/06/oyeAMj.png" alt></p>
<h3 id="1-5-2-最小化期望损失"><a href="#1-5-2-最小化期望损失" class="headerlink" title="1.5.2 最小化期望损失"></a>1.5.2 最小化期望损失</h3><p>癌症病人没病———&gt;有病</p>
<p>癌症病人有病———&gt;没病 事大了</p>
<p>代价函数来衡量损失。引入损失矩阵。</p>
<p><img src="https://s4.ax1x.com/2021/12/06/oyeEss.png" alt></p>
<p>我们的目标就是使得$\sum_k L_{kj}p(x,c_k)$​最小。</p>
<p>例子：</p>
<p>$p({\rm 癌症}|x) = 0.2$   $p({\rm 正常}|x) =0.7$ </p>
<p>将$x$​分类到正常：</p>
<script type="math/tex; mode=display">
{\rm 损失函数值} = L_{\rm 癌症\,\, 正常}p({\rm 癌症}|x) + L_{\rm 正常 \,\,正常}p({\rm 正常}|x)= 0.2*1000+0=200</script><p>将$x$分类到癌症：</p>
<script type="math/tex; mode=display">
{\rm 损失函数值} = L_{\rm 正常\,\, 癌症}p({\rm 正常}|x) + L_{\rm 癌症\,\, 癌症}p({\rm 癌症}|x)= 0.7*1=0.7</script><h3 id="1-5-3-拒绝判断"><a href="#1-5-3-拒绝判断" class="headerlink" title="1.5.3 拒绝判断"></a>1.5.3 拒绝判断</h3><p><img src="https://s4.ax1x.com/2021/12/06/oyeeZq.png" alt></p>
<h3 id="1-5-4-推论和决策"><a href="#1-5-4-推论和决策" class="headerlink" title="1.5.4 推论和决策"></a>1.5.4 推论和决策</h3><p>分类问题俩阶段：</p>
<p>推论阶段，得到$p(Ck|x)$(后验概率),</p>
<p>决策阶段，根据后验概率做最优的分配</p>
<p>另一种办法是判别函数：直接由一个函数将$x$映射到决策。</p>
<p>解决决策问题的方法</p>
<p>第一种：</p>
<p>先计算$p(x|Ck)$，通过贝叶斯公式得到后验概率</p>
<script type="math/tex; mode=display">
P(C_k|x)=\frac{p(x|C_k)p(C_k)}{p(x)}</script><p>而，</p>
<script type="math/tex; mode=display">
p(x)=\sum p(x|C_k)p(C_k)</script><p>使用决策论来决定如何分类。</p>
<p>第二种：</p>
<p>先得到后验概率$p(C_k|x)$,然后按照决策论的方法分配数据。</p>
<p>第三种：</p>
<p>找到一个函数将x直接映射到类别，这个函数叫做判别函数。在这里概率没有起到作用。</p>
<p>这三种方法的优缺点。</p>
<p>第一种方法：</p>
<p>需要$x$和$C_k$的联合分布，要找到$p(x|C_k)$需要很多的训练数据。</p>
<p>第二种方法：</p>
<p>如果我们只想做一个分类，计算$p(x,C_k)$是非常消耗计算资源并且需要大量的数据的。实际上我们只需要一个后验概率而已。</p>
<p>第三种方法：</p>
<p>直接将$x$映射到类别，连后验概率都省掉而来。</p>
<p><img src="https://s4.ax1x.com/2021/12/06/oyeVLn.png" alt></p>
<p>后验概率还是非常有用的：</p>
<p>比如：</p>
<p>减小风险：</p>
<p>使用损失矩阵进行修正，以减小我们的分类错误的风险，得到不同的决策。第三种方法需重新分析数据建模</p>
<p>拒绝决策：</p>
<p>有后验概率我们可以使用拒绝域，但是如果是第三种方法，就做不到。</p>
<p>补偿先验类别：</p>
<p>如果癌症患者的比例是$1:1000$，$99.9\%$。假设我们使用modified的data得到了后验概率分布$p(C_k|x)$. 我们可以先使用我们人工制造的数据进行分类， 然后再乘以实际中对应的癌症与正常的比例得到新的后验概率。</p>
<p>结合不同的模型：</p>
<p>分成子问题分别求解，使用$x_r$ , $X_b$​ 表示测试癌症的x-ray和验血。</p>
<p>后验概率:$P(C_k|x_I,x_B ) = P(x_I ,x_B |C_k) P(C_k) / P(x_I ,x_B )$​</p>
<script type="math/tex; mode=display">
\begin{align}
p(C_k|x_1, x_B) & ∝ p(x_1,x_B|C_k)p(C_K)\\[2ex]
& ∝ p(x_1|C_k)p(x_B|C_k)p(C_K)\\[2ex]
& ∝ \frac{p(C_k|x_1)p(C_k|x_B)}{p(C_k)}
\end{align}</script><h3 id="1-5-5-回归问题中的损失函数"><a href="#1-5-5-回归问题中的损失函数" class="headerlink" title="1.5.5 回归问题中的损失函数"></a>1.5.5 回归问题中的损失函数</h3><p>损失函数：</p>
<script type="math/tex; mode=display">
E[L]=\iint L(t,y(x))p(x,t){\rm d}x{\rm d}t</script><script type="math/tex; mode=display">
E[L]=\iint(t-y(x))^2 p(x, t){\rm d}x{\rm d}t</script><p>我们目标就是取一个$y(x)$使得$E[L]$​最小</p>
<script type="math/tex; mode=display">
\frac{\partial  E[L]}{\partial y(x)}=2\int\{y(t)-t\}p(x,t){\rm d}t=0</script><script type="math/tex; mode=display">
\int y(x)p(x,t ){\rm d}t = \int tp(x,t){\rm d}t\\</script><script type="math/tex; mode=display">
y(x)\int p(x,t){\rm d}t=y(x)p(x)=\int tp(x,t){\rm d}t</script><script type="math/tex; mode=display">
y(x)=\frac{\int tp(x,t){\rm d}t}{p(x)}=\int tp(t|x){\rm d}t=E_t[t|x]</script><p><img src="https://s4.ax1x.com/2021/12/06/oyemd0.png" alt></p>
<p>解决回归问题：</p>
<p>第一：先找到$p(x,t)$然后找到$p(t|x)$,最后使用</p>
<script type="math/tex; mode=display">
y(t)=\frac{\int tp(x,t){\rm d}t}{p(x)}=\int tp(t|x){\rm d}t=E_t[t|x]</script><p>得到$y(x)$</p>
<p>第二：先找到$p(t|x)$ 再使用</p>
<script type="math/tex; mode=display">
y(x)=\frac{\int tp(x,t){\rm d}t}{p(x)}=\int tp(t|x){\rm d}t=E_t[t|x]</script><p>得到$y(x)$</p>
<p>第三：直接找到$y(x)$</p>
<p>优缺点与分类问题一样。</p>
<h2 id="1-6-信息理论"><a href="#1-6-信息理论" class="headerlink" title="1.6 信息理论"></a>1.6 信息理论</h2><p>信息量：变量的“惊讶程度”</p>
<p>变量的信息量：</p>
<p>如果 $x,y$ 独立的话，就是他们的和, $h(x, y) = h(x) + h(y)$ 。还有$p(x, y) = p(x)p(y)$. 我们可以断定 $h(x)$可以使用 $\log$ 来作为那个递增函数：</p>
<p>因为 $\log(p(x)p(y)) =\log(p(x))+\log(p(y))$​，因为 $p(x)$​是在$(0,1)$​的所以 $h(x) = -\log[p(x)]$​才能保证 $h(x)$​大于$0$.</p>
<p>如果我们选择 $\log2$的话，$h(x)$的单位叫做 bit。</p>
<h3 id="1-6-1-熵"><a href="#1-6-1-熵" class="headerlink" title="1.6.1 熵"></a>1.6.1 熵</h3><p>平均信息量（熵 entropy） ：</p>
<p>变量$x$的平均信息量为：</p>
<script type="math/tex; mode=display">
H[x]=\sum p(x)h(x)=-\sum_{x}p(x)\log_2 p(x)</script><p>熵的意义：</p>
<p>例如：一个变量$x$有$ 8$种状态，每一种状态的概率都是 $\frac{1}{8}$.那么$x$的熵为：</p>
<script type="math/tex; mode=display">
-\sum_{1}^8\frac{1}{8}\log_2\frac{1}{8}=3</script><p>再例如：如果$x$的$8 $种状态为$\{a,b,c,d,e,f,g,h\}$的概率分布为$(\frac{1}{2},\frac{1}{4},\frac{1}{8},\frac{1}{16},\frac{1}{64},\frac{1}{64},\frac{1}{64},\frac{1}{64})$，那么$x$的熵为：</p>
<script type="math/tex; mode=display">
H[x]=-\frac{1}{2}\log_2\frac{1}{2}-\frac{1}{4}\log_2\frac{1}{4}-\frac{1}{8}\log_2\frac{1}{8}-\frac{1}{16}\log_2\frac{1}{16}-\frac{4}{64}\log_2\frac{1}{64}=2{\rm bits}</script><p>结论：非均匀分布的比均匀分布的熵更小。熵与$x$分布的杂乱程度有关。越杂乱越小。</p>
<h3 id="1-6-2-熵与编码"><a href="#1-6-2-熵与编码" class="headerlink" title="1.6.2 熵与编码"></a>1.6.2 熵与编码</h3><p>对于上面的例子，我们可以对每一种状态$\{a,b,c,d,e,f,g,h\}$​​编码<br>$0, 10, 110, 1110, 111100, 111101, 111110, 111111$.编码的平均长度如下。</p>
<script type="math/tex; mode=display">
{\rm average \,\,code\,\, length} = \frac{1}{2}\times1+\frac{1}{4}\times 2+\frac{1}{8}\times3+\frac{1}{16}\times 4+4\times\frac{1}{64}\times6 = 2{\rm bits}</script><p>这与熵相等的。</p>
<p>使用自然对数定义熵（ natural logarithms）。</p>
<p>平衡热力学中的材料来分析， 也可以把它当成衡量杂乱的标准。</p>
<p>考虑有$N$个相同的物体，要放到一组罐子中，在$i^{\rm th}$个罐子中有$n_i$个物体。<br>这就有$N!$种分发。如果我们不考虑罐子里的物体的排列，那么有：</p>
<script type="math/tex; mode=display">
w=\frac{N!}{\Pi^i n_i!}</script><p>熵的定义就是：</p>
<script type="math/tex; mode=display">
H=\frac{1}{N}\ln W=\frac{1}{N}\ln N!-\frac{1}{N}\sum_i\ln n_i!</script><p>当$N$趋近无穷大时候，$\frac{n_i}{N}$是固定的。并且$\ln N! = N\ln N - N$ ,就得到$H$如下：</p>
<script type="math/tex; mode=display">
H=-\lim_{N\to\infty}\sum(\frac{n_i}{N})\ln(\frac{n_i}{N})=-\sum p_i\ln p_i</script><p><img src="https://s4.ax1x.com/2021/12/06/oyeKiT.png" alt></p>
<h3 id="1-6-3-差熵"><a href="#1-6-3-差熵" class="headerlink" title="1.6.3 差熵"></a>1.6.3 差熵</h3><p>中值定理：</p>
<script type="math/tex; mode=display">
\int_{i\Delta}^{(i+1)\Delta}p(x){\rm d}x=p(x_i)\Delta</script><p>套用离散分布的公式：</p>
<script type="math/tex; mode=display">
H=-\lim_{N\to\infty}\sum_i(\frac{n_i}{N})\ln(\frac{n_i}{N})=-\sum_ip_i\ln p_i</script><p>使用：$\sum_i p(x_i)\Delta=1$得到：</p>
<script type="math/tex; mode=display">
\begin{align}
H_\Delta&=-\sum_i p(x_i)\Delta\ln(p(x_i)\Delta)\\[2ex]
&=-\sum_ip(x_i)\Delta\ln p(x_i)-\ln\Delta
\end{align}</script><p>当$Δ$趋近无穷的时候：右边第一项就等于</p>
<script type="math/tex; mode=display">
\lim_{\Delta\to 0} \left[ \sum_ip(x_i)\Delta\ln p(x_i) \right]=-\int p(x)\ln p(x){\rm d}x</script><p>右边这项就叫做差熵 （differential entropy） 。离散和连续形式的熵相差了一个$\lnΔ(Δ\to∞)$ 。</p>
<p>结论：要精确地确定一个连续的变量需要大量的数据。</p>
<p>连续分布的最大熵</p>
<p>离散分布时候最大熵？？？？？</p>
<script type="math/tex; mode=display">
\int_{-\infty}^\infty p(x){\rm d}x= 1</script><script type="math/tex; mode=display">
\int_{-\infty}^\infty xp(x){\rm d}x= \mu</script><script type="math/tex; mode=display">
\int_{-\infty}^\infty (x-\mu)^2p(x){\rm d}x= \sigma^2</script><p>使用拉格朗日法，</p>
<p>问题转变为：在上面的约束条件下，当$p(x)$为什么分布的时候，下面式子的最小。</p>
<script type="math/tex; mode=display">
-\int_{-\infty} ^\infty p(x)\ln p(x){\rm d}x+\lambda_1\left(\int_{-\infty}^{\infty}p(x){\rm d} x-1\right)+\lambda_2\left(\int_{-\infty}^{\infty}xp(x){\rm d}x-\mu\right)+\lambda_3\left(\int_{-\infty}^\infty(x-\mu)^2p(x){\rm d}x-\sigma^2\right)</script><p>最终计算结果是高斯分布：$N(\mu,σ^2)$</p>
<p>在高斯分布的情况下差熵：</p>
<script type="math/tex; mode=display">
H[x]=\frac{1}{2}(1+\ln2^\pi\sigma^2)</script><p>从这个式子我们也可以看出随着$σ^2$的增大，高斯分布变得更扁，熵变得越大。</p>
<h3 id="1-6-4-条件熵："><a href="#1-6-4-条件熵：" class="headerlink" title="1.6.4 条件熵："></a>1.6.4 条件熵：</h3><p>当我们有一个联合分布$p(x,y)$,如果我么 现在知道了$x$的值，需要额外的信息知道对应的$y$的值，这个额外的信息就是$-\ln p(y|x)$.平均额外的信息就表示为：</p>
<script type="math/tex; mode=display">
H[y|x]=-\iint p(x,y)\ln p(y|x){\rm d}x{\rm d}y</script><p>这就叫做条件熵（conditional entropy）</p>
<p>容易得到$H[x,y] = H[y|x]+H[x]$​</p>
<p>结论： 需要用来描述$x$和$y$的信息是用来描述$x$的信息加上在$x$的条件下用来描述$y$​的额外信息。</p>
<h3 id="1-6-5-相对熵：（KL-散度）"><a href="#1-6-5-相对熵：（KL-散度）" class="headerlink" title="1.6.5 相对熵：（KL 散度）"></a>1.6.5 相对熵：（KL 散度）</h3><p>一个不知道的分布$p(x)$,我们使用$q(x)$取近似拟合它。假如我们要把$x$发送到一个接收器，我们使用$q(x)$来设计编码方案，得到的就不是最佳方案，会比最佳方案多发送一些信息。这个信息就是</p>
<script type="math/tex; mode=display">
KL(p||q)=-\int p(x)\ln q(x){\rm d}x-\left(-\int p(x)\ln p(x)\right)=-\int p(x)\ln\frac{q(x)}{p(x)}{\rm d}x</script><p>这就叫做相对熵，或者KL 散度 。KL散度不是对称的$KL(p||q)!=KL(q||p)$</p>
<p>KL-divergence，俗称KL距离，常用来衡量两个概率分布的距离。</p>
<p>根据shannon的信息论，给定一个字符集的概率分布，我们可以设计一种编码，使得表示该字符集组成的字符串平均需要的比特数最少。假设这个字符集是$X$​，对$x∈X$，其出现概率为$P(x)$，那么其最优编码平均需要的比特数等于这个字符集的熵：$H(X)=∑x∈XP(x)\log[1/P(x)]$</p>
<p>在同样的字符集上，假设存在另一个概率分布$Q(X)$。如果用概率分布$P(X)$的最优编码（即字符$x$的编码长度等于$\log\left[1/P(x)\right]$） ，来为符合分布$Q(X)$的字符编码，那么表示这些字符就会比理想情况多用一些比特数。KL-divergence就是用来衡量这种情况下平均每个字符多用的比特数，因此可以用来衡量两个分布的距离。即：<br>$DKL(Q||P)= ∑ x ∈ XQ(x)[\log(1/P(x))] - ∑ x ∈ XQ(x)[\log[1/Q(x)]]= ∑ x ∈<br>XQ(x)\log[Q(x)/P(x)]$由于$-\log(u)$是凸函数，因此有下面的不等式<br>$DKL(Q||P) = -∑x∈XQ(x)\log[P(x)/Q(x)] = E[-\log[P(x)/Q(x)]] ≥ -\log E[P(x)/Q(x)] =-\log∑x∈XQ(x)P(x)/Q(x) = 0$</p>
<p>即KL-divergence始终是大于等于$0$的。当且仅当两分布相同时，KL-散度等于$0$</p>
<p>下面证明：$KL(p||q)&gt;=0$ 只有$p(x) = q(x)$的时候等于$0$。这也可以理解为只有在$p$的情况下式最优的，使用最短的平均编码。其他情况下都不是最优的。</p>
<p>引入凸函数：</p>
<p><img src="https://s4.ax1x.com/2021/12/06/oyeMJU.png" alt></p>
<p>凸函数满足</p>
<script type="math/tex; mode=display">
f(\lambda a+(1-\lambda)b)\leq \lambda f(a)+(1-\lambda)f(b)</script><p>叫做凸函数。</p>
<p>满足</p>
<script type="math/tex; mode=display">
f(\lambda a+(1-\lambda)b)< \lambda f(a)+(1-\lambda)f(b)</script><p>叫做严格凸函数。</p>
<p>我们可以证明：</p>
<script type="math/tex; mode=display">
f(\sum_{i=1}^M\lambda_i x_i)\leq\sum_{i=1}^{M} f(\lambda_ix_i)</script><p>满足：$\sum_{i=1}^M\lambda_i=1$，并且$f(x)$是凸函数</p>
<p>我们可以把λi看做是$p(x_i)$ ,概率分布，满足： $\sum_{i=1}^{M}p(x_i)=1$</p>
<p>可以得到$f(E[x])\leq E[f(x)]$</p>
<p>即，$f(\int xp(x)){\rm d}x\leq \int f(x)p(x){\rm d}x$</p>
<p>把上式子应用于下面的$KL(p||q)$.</p>
<script type="math/tex; mode=display">
KL(p||q)=-\int p(x)\ln\frac{q(x)}{p(x)}{\rm d}x=\int p(x)\left[-\ln\frac{q(x)}{p(x)}\right]{\rm d}x</script><p>而$-\ln(x)$是凸函数。就有：</p>
<script type="math/tex; mode=display">
-\ln\left(\int p(x)\frac{q(x)}{p(x)}\right){\rm d}x\leq\int\ln p(x)\left[-\ln \frac{q(x)}{p(x)}\right]{\rm d}x</script><script type="math/tex; mode=display">
-\ln\left(\int p(x)\frac{q(x)}{p(x)}\right){\rm d}x=-\ln\int p(x){\rm d}x=-\ln 1=0</script><p>所以：</p>
<script type="math/tex; mode=display">
KL(p||q)=-\int p(x)\ln \frac{q(x)}{p(x)}{\rm d}x=\int p(x)\left[-\ln\frac{q(x)}{p(x)}\right]{\rm d}x \geq 0</script><p>这就可以使用KL divergence 作为一个两个分布不同程度的度量。</p>
<p>如果我们使用不同的分布， 那么我们就会得到一个不那么有效的编码， 这就将一些额外信息发送了，这个平均的额外信息就等于KL divergence。</p>
<p>最小化$KL(p||q)$与最大似然函数的等价。</p>
<p>假设我们通过调整参数 $θ$​​，想得到一个分布的近似的分布。我们可以使$p(x)$​​,$q(x|θ)$​​之间的$KL(p||q)$最小。但是我们不知道$p$，但是这个不影响我们的计算（下面会看到） 。</p>
<p>假设我们有N个观察点。</p>
<script type="math/tex; mode=display">
\begin{align}
KL(p||q)&=\sum_{n=1}^N\{-\ln q(x_n|\theta)\}-\sum_{n=1}^N\left[-\ln p(x_n)\right]\\[2ex]
& = -\sum_{n=1}^N\ln q(x_n|\theta)+\sum_{n=1}^N\left[\ln p(x_n)\right]

\end{align}</script><p>注意右边第二项没有$θ$，我们只需要最大化</p>
<script type="math/tex; mode=display">
\sum_{n=1}^N\ln q(x|\theta)=\ln\{\Pi_{n=1}^N q(x_n|\theta)\}</script><p>就是我们前面将的最大似然估计。</p>
<p>变量间的交互信息（mutual information）</p>
<p>我们有$x,y$的分布$p(x,y)$,如果$x,y$是独立的，$p(x,y)=p(x)p(y)$,如果$x,y$不独立，我们也可以使用$KL$来评估$x,y$是否是近似独立的。</p>
<script type="math/tex; mode=display">
I[x,y]=KL\{p(x, y)||[p(x)p(y)]\}=-\iint p(x,y)\frac{p(x)p(y)}{p(x,y)}{\rm d}x{\rm d}y</script><p>这叫做$x,y$的mutual information.使用加法法则和乘法法则可以得到</p>
<script type="math/tex; mode=display">
I[x,y]=H[x]-H[x|y]</script><p>可以把$p(x)$看做是先验概率，$p(x|y)$为后验概率，$I[x,y]$从贝叶斯的角度可以解释为：当知道一个$y$后，$x$的不确定性的减少量。例如当$y$与$x$独立时候，知道$y$对$x$一点影响都没有，那么$I[x,y] = H[x]-H[x|y] =H[x]-H[x]=0$。减少量为$0$。如果$x=y$那么$h[x|y]=0$.减少量为$H[x]$,表示告诉$y$后$x$就定了。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>npuSE</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>npuCS 第一讲 基础算法</title>
    <url>/2021/12/06/basicACML1/</url>
    <content><![CDATA[<h1 id="第一讲-基础算法"><a href="#第一讲-基础算法" class="headerlink" title="第一讲 基础算法"></a>第一讲 基础算法</h1><h2 id="1-1-排序"><a href="#1-1-排序" class="headerlink" title="1.1 排序"></a>1.1 排序</h2><h3 id="1-1-1-快速排序——分治"><a href="#1-1-1-快速排序——分治" class="headerlink" title="1.1.1 快速排序——分治"></a>1.1.1 快速排序——分治</h3><h4 id="1-原理讲解"><a href="#1-原理讲解" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><p>快速排序的主要思想是<strong>分治</strong>与<strong>递归</strong>。</p>
<p>分治，顾名思义，即将一个问题分为若干子问题，待子问题全部解决，问题也就解决了。</p>
<p>递归，指函数直接或间接调用函数本身。斐波那契数列的定义就是递归的。</p>
<p>首先我们从数组q[]单拎出来一个元素a，称它为关键字。</p>
<p>一趟快速排序把除关键字a外的数列q[]按指定的关键字分成小于、大于关键字两部分，并将数组重新排列，使得q[] =【小于关键字】关键字【大于关键字】，然后递归调用分别排序【小于关键字】和【大于关键字】两个部分，待两者分别有序时排序完成。</p>
<p>举个例子：</p>
<p>以每个待排序区间[l , r]中间的元素q[l + r &gt;&gt; 1]为关键字，给定数组q[]={1, 9, 2, 6, 0, 8, 1, 7} (下标从0开始)</p>
<p>1.关键字下标 l + r &gt;&gt; 1 = 0 + 7 &gt;&gt; 1 = 3，q[3] = 6，故数组被拆分成 <strong>{1, 2, 0, 1}</strong> 6 <strong>{9, 8, 7}</strong> 三部分，递归调用分别排序 {1, 2, 0, 1}、{9, 8, 7}；</p>
<p>2.针对第1趟小于关键字的部分{1, 2, 0, 1}，关键字下标 l + r &gt;&gt; 1 = 0 + 3 &gt;&gt; 1＝1，q[1] = 2，故递归调用给定的区间被拆分为 <strong>{1, 0, 1}</strong> 2 两部分，递归调用排序 {1, 0, 1}；</p>
<p>3.针对第2趟小于关键字的部分{1, 0, 1}，关键字下标 l + r &gt;&gt; 1 = 0 + 2 &gt;&gt; 1 = 1，q[1] = 0，故递归调用给定的区间被分为 0 <strong>{1, 1}</strong> 两部分，结束递归；</p>
<p>4.针对第1趟大于关键字的部分{9, 8, 7}，关键字下标 l + r &gt;&gt; 1 = 5 + 7 &gt;&gt; 1 = 6，q[6] = 8，故递归调用给定的区间被分为7 8 9 三部分，结束递归，排序完成。</p>
<p>快速排序之所以快，是因为相较于冒泡排序，每次交换都是跳跃式的，不仅限于相邻的数的交换，因而总的比较次数和交换次数少了，速度自然就提高了，快速排序的平均复杂度为O(nlogn)。但在最坏的情况，即完全逆序时，仍是所有相邻的数进行了交换，因此快速排序的最差时间复杂度也是O(n^2)。</p>
<h4 id="2-模板讲解"><a href="#2-模板讲解" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> <span class="comment">// 对q数组给定区间[l, r]进行快速排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果待排序的区间只有一个元素或没有元素则说明已排好序</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// x &gt;&gt; 1 指 x 的二进制表示右移一位的结果，与 x/2 同效且更快</span></span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 从前往后找大于等于 x 的元素，从后往前找小于等于 x 的元素，如果不是同一个元素则交换</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//i是最先的使q[i] &gt;= x的下标</span></span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="comment">//j是最后的使q[j] &lt;= x的下标</span></span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x); </span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//while循环结束后有 i &gt;= j，即所有大于等于x的元素都在小于等于x的元素的后面</span></span><br><span class="line">    <span class="comment">// 对小于等于 x 的部分 和 大于等于 x 的部分分别进行快速排序，保证排序的正确性</span></span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">//由于q[j]不一定等于x，故不能拆分成q[l~j-1] q[j] q[j+1~r]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例1-1-1：快速排序"><a href="#例1-1-1：快速排序" class="headerlink" title="例1.1.1：快速排序"></a>例1.1.1：快速排序</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定你一个长度为 $n$ 的整数数列。</p>
<p>请你使用快速排序对这个数列按照从小到大进行排序。</p>
<p>并将排好序的数列按顺序输出。</p>
<h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><p>输入共两行，第一行包含整数 $n$。</p>
<p>第二行包含 $n$ 个整数（所有整数均在 $1∼10^9$ 范围内），表示整个数列。</p>
<h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出共一行，包含 $n$ 个整数，表示排好序的数列。</p>
<h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n≤100000$</p>
<h5 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 1 2 4 5</span><br></pre></td></tr></table></figure>
<h5 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>
<h5 id="参考代码："><a href="#参考代码：" class="headerlink" title="参考代码："></a>参考代码：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span>&#123;</span><br><span class="line">	*a += *b;</span><br><span class="line">	*b = *a - *b;</span><br><span class="line">	*a -= *b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">		<span class="keyword">do</span></span><br><span class="line">			i++;</span><br><span class="line">		<span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">		<span class="keyword">do</span></span><br><span class="line">			j--;</span><br><span class="line">		<span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j)</span><br><span class="line">			swap(&amp;q[i], &amp;q[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	quick_sort(q, l, j);</span><br><span class="line">	quick_sort(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">int</span> a[MAXN];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">	quick_sort(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-1-2-归并排序"><a href="#1-1-2-归并排序" class="headerlink" title="1.1.2 归并排序"></a>1.1.2 归并排序</h3><h4 id="1-原理讲解-1"><a href="#1-原理讲解-1" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><p>归并排序也是递归的一个典例。归并排序的过程分为两步：</p>
<p>1.将给定的数组从中拆分成两个，分别归并排序；</p>
<p>2.将得到的两个有序的数组合并成一个有序的数组。</p>
<p>数组合并使用到了双指针的思想，设给定的数组拆分成了数组 a , b，当 a[i] &lt;= b[j] 时应将 a[i] 放到答案数组的下一个位置，同时 i 自增；否则应将 b[j] 放到答案数组中同时 j 指向 b 的下一个下标。</p>
<p>归并排序同时还能实现<strong>寻找逆序对</strong>的功能：</p>
<p>逆序对：在数组 a[] 中满足 i &lt; j 且 a[i] &gt; a[j] 的 (i, j) 被称为 a[] 的逆序对</p>
<p>归并排序的合并过程中，当 a[i] &gt;b[j] 时，有b[1] &lt;= b[2] &lt;= ··· &lt;= b[j] &lt;a[i]，即有j个数形成了逆序对，反之则不能构成逆序对。</p>
<h4 id="2-模板讲解-1"><a href="#2-模板讲解-1" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*int cnt;*/</span> <span class="comment">//逆序对的数量</span></span><br><span class="line"><span class="keyword">int</span> tmp[N];<span class="comment">//寄存数组 最大需要的空间为 n*size，n为待排序长度，size为存储每个元素需要的空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//拆分后分别排序</span></span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    merge_sort(q, l, mid);</span><br><span class="line">    merge_sort(q, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="comment">//合并两个有序数组，使用tmp数组做寄存器</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k++] = q[j++], <span class="comment">/*cnt += mid - i + 1*/</span>; <span class="comment">//注释中为求逆序对的语句</span></span><br><span class="line"><span class="comment">//别忘了“没有对手”的最大的数们</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k++] = q[j++];</span><br><span class="line"><span class="comment">//从寄存器中调出</span></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例1-1-2：归并排序（输入同例1-1-1，输出另加一行输出1个整数表示逆序对数量）"><a href="#例1-1-2：归并排序（输入同例1-1-1，输出另加一行输出1个整数表示逆序对数量）" class="headerlink" title="例1.1.2：归并排序（输入同例1.1.1，输出另加一行输出1个整数表示逆序对数量）"></a>例1.1.2：归并排序（输入同例1.1.1，输出另加一行输出1个整数表示逆序对数量）</h4><h5 id="参考代码：-1"><a href="#参考代码：-1" class="headerlink" title="参考代码："></a>参考代码：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10005</span></span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="keyword">int</span> tmp[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	merge_sort(q, l, mid);</span><br><span class="line">	merge_sort(q, mid + <span class="number">1</span>, r);</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">		<span class="keyword">if</span> (q[i] &lt;= q[j])</span><br><span class="line">			tmp[k++] = q[i++];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			tmp[k++] = q[j++], cnt += mid - i + <span class="number">1</span>; <span class="comment">//逆序</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">		tmp[k++] = q[i++];</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= r)</span><br><span class="line">		tmp[k++] = q[j++];</span><br><span class="line">	<span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++)</span><br><span class="line">		q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, i;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">	merge_sort(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n%d &quot;</span>, cnt);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-1-3-排序小结"><a href="#1-1-3-排序小结" class="headerlink" title="1.1.3 排序小结"></a>1.1.3 排序小结</h3><div class="table-container">
<table>
<thead>
<tr>
<th>排序种类</th>
<th>快速排序</th>
<th>归并排序</th>
</tr>
</thead>
<tbody>
<tr>
<td>平均时间复杂度</td>
<td>O(nlog2n)</td>
<td>O(nlog2n)</td>
</tr>
<tr>
<td>最坏时间复杂度</td>
<td>O(n^2)</td>
<td>O(nlog2n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="1-2-二分"><a href="#1-2-二分" class="headerlink" title="1.2 二分"></a>1.2 二分</h2><h3 id="1-2-1-整数二分"><a href="#1-2-1-整数二分" class="headerlink" title="1.2.1 整数二分"></a>1.2.1 整数二分</h3><h4 id="1-原理讲解-2"><a href="#1-原理讲解-2" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><p>二分前提：数组在区间内有序</p>
<p>二分的主要思想就是将铺开的网逐渐收紧。举个例子，罪犯位于[1, 10]这个区间的某整数点上，我如果能判断罪犯在5或之前/6或以后，我就可以把区间缩小为[1, 5]/[6, 10]，如此继续找下去就可以把范围缩小到某个点上。</p>
<p>二分的主要作用是找到满足条件的最值。例如找到[1, 10]中最大的小于5的数，mid1 = 5，答案在[1, 5]区间内；mid2=3，答案在[3, 5]区间内，mid3=4，答案在[4, 5]区间内，答案为4。</p>
<h4 id="2-模板讲解-2"><a href="#2-模板讲解-2" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用</span></span><br><span class="line"><span class="comment">// 即求满足条件的最小值时使用：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用</span></span><br><span class="line"><span class="comment">// 即求满足条件的最大值时使用：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>; <span class="comment">//注意 “+ 1”，缺失致使 mid == l 进入死循环</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例1-2-1-数的范围"><a href="#例1-2-1-数的范围" class="headerlink" title="例1.2.1 数的范围"></a>例1.2.1 数的范围</h4><p>给定一个按照升序排列的长度为 $n$ 的整数数组，以及 $q$ 个查询。</p>
<p>对于每个查询，返回一个元素 $k$ 的起始位置和终止位置（位置从 $0$ 开始计数）。</p>
<p>如果数组中不存在该元素，则返回 $-1$ $-1$。</p>
<h5 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $n$ 和 $q$，表示数组长度和询问个数。</p>
<p>第二行包含 $n$ 个整数（均在 $1∼10000$ 范围内），表示完整数组。</p>
<p>接下来 $q$ 行，每行包含一个整数 $k$，表示一个询问元素。</p>
<h5 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h5><p>共 $q$ 行，每行包含两个整数，表示所求元素的起始位置和终止位置。</p>
<p>如果数组中不存在该元素，则返回 $-1$ $-1$。</p>
<h5 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n≤100000$</p>
<p>$1≤q≤10000$</p>
<p>$1≤k≤10000$</p>
<h5 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 3</span><br><span class="line">1 2 2 3 3 4</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4</span><br><span class="line">5 5</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure>
<h5 id="参考代码：-2"><a href="#参考代码：-2" class="headerlink" title="参考代码："></a>参考代码：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10005</span></span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">//C用bool还得引个头文件，忒麻烦，拿char替了</span></span><br><span class="line">	<span class="keyword">if</span> (a[x] &gt;= k)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (chk(mid))</span><br><span class="line">			r = mid;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			l = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, q, i;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">		<span class="keyword">int</span> x = bsearch1(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (a[x] != k) &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;-1 -1&quot;</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line">		<span class="keyword">while</span> (a[x + <span class="number">1</span>] == a[x])</span><br><span class="line">			x++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-2-浮点数二分"><a href="#1-2-2-浮点数二分" class="headerlink" title="1.2.2 浮点数二分"></a>1.2.2 浮点数二分</h3><h4 id="1-原理讲解-3"><a href="#1-原理讲解-3" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><p>与整数二分的主要作用相同，依旧是逐步缩小范围，最终聚焦在某点上，但浮点数的二分受精度的限制，只要答案落在 [actual_ans - eps, actual_ans + eps] 范围内即可</p>
<h4 id="2-模板讲解-3"><a href="#2-模板讲解-3" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例1-2-2-数的三次方根"><a href="#例1-2-2-数的三次方根" class="headerlink" title="例1.2.2 数的三次方根"></a>例1.2.2 数的三次方根</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个浮点数 $n$，求它的三次方根。</p>
<h5 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h5><p>共一行，包含一个浮点数 $n$。</p>
<h5 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h5><p>共一行，包含一个浮点数，表示问题的解。</p>
<p>注意，结果保留 $6$ 位小数。</p>
<h5 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h5><p>$−10000≤n≤10000$</p>
<h5 id="输入样例：-2"><a href="#输入样例：-2" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000.00</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10.000000</span><br></pre></td></tr></table></figure>
<h5 id="参考代码：-3"><a href="#参考代码：-3" class="headerlink" title="参考代码："></a>参考代码：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">double</span> n;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">chk</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x * x * x &gt;= n)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">bsearch3</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (r - l &gt; eps / <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (chk(mid))</span><br><span class="line">			r = mid;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			l = mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.6lf&quot;</span>, bsearch3(<span class="number">-30</span>, <span class="number">30</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-大整数"><a href="#1-3-大整数" class="headerlink" title="1.3 大整数"></a>1.3 大整数</h2><h3 id="1-3-1-大整数加法"><a href="#1-3-1-大整数加法" class="headerlink" title="1.3.1 大整数加法"></a>1.3.1 大整数加法</h3><h4 id="1-原理讲解-4"><a href="#1-原理讲解-4" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><p>众所周知，unsigned long long 类型的最大值才2^64 - 1，如果我想存一个巨大的比1 &lt;&lt; 64还大的数就只能另辟蹊径。</p>
<p>存放大整数使用到vector容器，vector实际上模拟的是动态内存分配的数组，可以用数组的方式修改元素，也可以向队列一样向队尾增加元素(push_back)。vector的使用比静态数组要慢，但比malloc要快很多。</p>
<p>规定先放入容器中的是较低位，后放入容器的是较高位。</p>
<p>这里的加减乘除的主要思想就是模拟手算，都是大家小学就学过的内容。加法我们常从低位算起，若该位和大于 9 则高位 + 1。</p>
<h4 id="2-模板讲解-4"><a href="#2-模板讲解-4" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前提：A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, vector&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//保证A的位数不比B少</span></span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C; <span class="comment">//答案寄存在C中返回</span></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>; <span class="comment">//t 是上一位运算的进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例1-3-1：大整数加法"><a href="#例1-3-1：大整数加法" class="headerlink" title="例1.3.1：大整数加法"></a>例1.3.1：大整数加法</h4><p>给定两个正整数，计算它们的和。</p>
<h5 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h5><p>共两行，每行包含一个整数。</p>
<h5 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h5><p>共一行，包含所求的和。</p>
<h5 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤$整数长度$≤100000$</p>
<h5 id="输入样例：-3"><a href="#输入样例：-3" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12</span><br><span class="line">23</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-3"><a href="#输出样例：-3" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">35</span><br></pre></td></tr></table></figure>
<h5 id="参考代码：-4"><a href="#参考代码：-4" class="headerlink" title="参考代码："></a>参考代码：</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; A, vector&lt;<span class="keyword">int</span>&gt; B)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		t += A[i];</span><br><span class="line">		<span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>())</span><br><span class="line">			t += B[i];</span><br><span class="line">		C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">		t /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (t)</span><br><span class="line">		C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> CA[MAXN], CB[MAXN];</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; A, B;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s %s&quot;</span>, CA, CB);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="built_in">strlen</span>(CA) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">		A.<span class="built_in">push_back</span>(CA[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="built_in">strlen</span>(CB) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">		B.<span class="built_in">push_back</span>(CB[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; C = <span class="built_in">add</span>(A, B);</span><br><span class="line">	<span class="keyword">while</span> (C.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C.<span class="built_in">back</span>());</span><br><span class="line">		C.<span class="built_in">pop_back</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-2-大整数减法"><a href="#1-3-2-大整数减法" class="headerlink" title="1.3.2 *大整数减法"></a>1.3.2 *大整数减法</h3><h4 id="1-原理讲解-5"><a href="#1-原理讲解-5" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><p>模拟减法，从低位开始减，不够减的从高位借 1。</p>
<h4 id="2-模板讲解-5"><a href="#2-模板讲解-5" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前提：A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, vector&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t; <span class="comment">//t为借位后的A[i]</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;　<span class="comment">//t表示借位</span></span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>(); <span class="comment">//舍弃高位的0</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例1-3-2：大整数减法"><a href="#例1-3-2：大整数减法" class="headerlink" title="例1.3.2：大整数减法"></a>例1.3.2：大整数减法</h3><p>给定两个正整数，计算它们的差，计算结果可能为负数。</p>
<h5 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h5><p>共两行，每行包含一个整数。</p>
<h5 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h5><p>共一行，包含所求的差。</p>
<h5 id="数据范围-4"><a href="#数据范围-4" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤$整数长度$≤10^5$</p>
<h5 id="输入样例：-4"><a href="#输入样例：-4" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">32</span><br><span class="line">11</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-4"><a href="#输出样例：-4" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure>
<h5 id="参考代码：-5"><a href="#参考代码：-5" class="headerlink" title="参考代码："></a>参考代码：</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, vector&lt;<span class="keyword">int</span>&gt; &amp;B)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		t = A[i] - t;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>())</span><br><span class="line">			t -= B[i];</span><br><span class="line">		C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">		<span class="keyword">if</span> (t &lt; <span class="number">0</span>)</span><br><span class="line">			t = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			t = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">		C.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">cmp</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">char</span> *b)</span> </span>&#123; <span class="comment">//比较两个以字符串形式存储的大整数的大小 若 a &gt;= b 则返回1，否则返回0</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(a) != <span class="built_in">strlen</span>(b))</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">strlen</span>(a) &gt; <span class="built_in">strlen</span>(b);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(a); i++)</span><br><span class="line">		<span class="keyword">if</span> (a[i] != b[i])</span><br><span class="line">			<span class="keyword">return</span> a[i] &gt; b[i];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> CA[MAXN], CB[MAXN];</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; A, B;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s %s&quot;</span>, CA, CB);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="built_in">strlen</span>(CA) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">		A.<span class="built_in">push_back</span>(CA[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="built_in">strlen</span>(CB) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">		B.<span class="built_in">push_back</span>(CB[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">int</span> m = <span class="built_in">cmp</span>(CA, CB);</span><br><span class="line">	<span class="keyword">if</span> (!m) <span class="comment">//若 A &lt; B 则输出-(B - A)</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; C = m ? <span class="built_in">sub</span>(A, B) : <span class="built_in">sub</span>(B, A);</span><br><span class="line">	<span class="keyword">while</span> (C.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C.<span class="built_in">back</span>());</span><br><span class="line">		C.<span class="built_in">pop_back</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-3-大整数乘整数"><a href="#1-3-3-大整数乘整数" class="headerlink" title="1.3.3 大整数乘整数"></a>1.3.3 大整数乘整数</h3><h4 id="1-原理讲解-6"><a href="#1-原理讲解-6" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><p>从低位向高位乘，该进位进位</p>
<h4 id="2-模板讲解-6"><a href="#2-模板讲解-6" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前提：A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>; <span class="comment">//存储低位的进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例1-3-3-：大整数乘整数"><a href="#例1-3-3-：大整数乘整数" class="headerlink" title="例1.3.3 ：大整数乘整数"></a>例1.3.3 ：大整数乘整数</h4><p>给定两个正整数 $A$ 和 $B$，请你计算 $A×B$ 的值。</p>
<h5 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h5><p>共两行，第一行包含整数 $A$，第二行包含整数 $B$。</p>
<h5 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h5><p>共一行，包含 $A×B$ 的值。</p>
<h5 id="数据范围-5"><a href="#数据范围-5" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤$A的长度$≤100000$,</p>
<p>$0≤$B$≤10000$</p>
<h5 id="输入样例：-5"><a href="#输入样例：-5" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-5"><a href="#输出样例：-5" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>
<h5 id="参考代码：-6"><a href="#参考代码：-6" class="headerlink" title="参考代码："></a>参考代码：</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>())</span><br><span class="line">			t += A[i] * B;</span><br><span class="line">		C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">		t /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, B;</span><br><span class="line">	<span class="keyword">char</span> CA[MAXN];</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, CA, &amp;B);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="built_in">strlen</span>(CA) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">		A.<span class="built_in">push_back</span>(CA[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; C = <span class="built_in">mul</span>(A, B);</span><br><span class="line">	<span class="keyword">while</span> (C.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C.<span class="built_in">back</span>());</span><br><span class="line">		C.<span class="built_in">pop_back</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-4-大整数除以整数"><a href="#1-3-4-大整数除以整数" class="headerlink" title="1.3.4 *大整数除以整数"></a>1.3.4 *大整数除以整数</h3><h4 id="1-原理讲解-7"><a href="#1-原理讲解-7" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><p>从高位开始除，每除完一次余数*10+被除数下一位就是下一次整除的被除数</p>
<h4 id="2-模板讲解-7"><a href="#2-模板讲解-7" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A / b = C ... r, 前提：A &gt;= 0, b &gt; 0, r = 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例-1-3-4：大整数除以整数"><a href="#例-1-3-4：大整数除以整数" class="headerlink" title="例:1.3.4：大整数除以整数"></a>例:1.3.4：大整数除以整数</h4><p>给定两个非负整数 $A$，$B$，请你计算 $A/B$ 的商和余数。</p>
<h5 id="输入格式-6"><a href="#输入格式-6" class="headerlink" title="输入格式"></a>输入格式</h5><p>共两行，第一行包含整数 $A$，第二行包含整数 $B$。</p>
<h5 id="输出格式-6"><a href="#输出格式-6" class="headerlink" title="输出格式"></a>输出格式</h5><p>共两行，第一行输出所求的商，第二行输出所求余数。</p>
<h5 id="数据范围-6"><a href="#数据范围-6" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤$A的长度$≤100000$,</p>
<p>$1≤$B$≤10000$,</p>
<p>$B$ 一定不为 $0$</p>
<h5 id="输入样例：-6"><a href="#输入样例：-6" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-6"><a href="#输出样例：-6" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h5 id="参考代码：-7"><a href="#参考代码：-7" class="headerlink" title="参考代码："></a>参考代码：</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> B, <span class="keyword">int</span> *r)</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		*r = <span class="number">10</span> * (*r) + A[i];</span><br><span class="line">		C.<span class="built_in">push_back</span>(*r / B);</span><br><span class="line">		*r %= B;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">		C.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, B, r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> CA[MAXN];</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, CA, &amp;B);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="built_in">strlen</span>(CA) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">		A.<span class="built_in">push_back</span>(CA[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; C = <span class="built_in">sub</span>(A, B, &amp;r);</span><br><span class="line">	<span class="keyword">while</span> (C.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C.<span class="built_in">back</span>());</span><br><span class="line">		C.<span class="built_in">pop_back</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n%d&quot;</span>, r);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-4-前缀和与差分"><a href="#1-4-前缀和与差分" class="headerlink" title="1.4 前缀和与差分"></a>1.4 前缀和与差分</h2><h3 id="1-4-1-一维前缀和"><a href="#1-4-1-一维前缀和" class="headerlink" title="1.4.1 一维前缀和"></a>1.4.1 一维前缀和</h3><h4 id="原理讲解"><a href="#原理讲解" class="headerlink" title="原理讲解"></a>原理讲解</h4><p>定义：数组 a[] 的前缀和 s[i] = a[1] + a[2] + ··· + a[i]</p>
<p>作用：O(1)求出 a[l] + ··· + a[r]，即 s[r] - s[l-1]</p>
<p>几何直观：</p>
<p><img src="/2021/12/06/basicACML1/一维前缀和.png" alt></p>
<h4 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求前缀和</span></span><br><span class="line"><span class="comment">// 前提：s[0]=0;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line"><span class="comment">// 求 a[l] ~ a[r] 的和</span></span><br><span class="line">sum = s[r] - s[l - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<h4 id="例1-4-1：-前缀和"><a href="#例1-4-1：-前缀和" class="headerlink" title="例1.4.1： 前缀和"></a>例1.4.1： 前缀和</h4><p>输入一个长度为 $n$ 的整数序列。</p>
<p>接下来再输入 $m$ 个询问，每个询问输入一对 $l,r$。</p>
<p>对于每个询问，输出原序列中从第 $l$ 个数到第 $r$ 个数的和。</p>
<h5 id="输入格式-7"><a href="#输入格式-7" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含两个整数 $n$ 和 $m$。</p>
<p>第二行包含 $n$ 个整数，表示整数数列。</p>
<p>接下来 $m$ 行，每行包含两个整数 $l$ 和 $r$，表示一个询问的区间范围。</p>
<h5 id="输出格式-7"><a href="#输出格式-7" class="headerlink" title="输出格式"></a>输出格式</h5><p>共 $m$ 行，每行输出一个询问的结果。</p>
<h5 id="数据范围-7"><a href="#数据范围-7" class="headerlink" title="数据范围"></a>数据范围</h5><p>$≤l≤r≤n$,</p>
<p>$1≤n,m≤100000$,</p>
<p>$−1000≤$数列中元素的值$≤1000$</p>
<h5 id="输入样例：-7"><a href="#输入样例：-7" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">2 1 3 6 4</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-7"><a href="#输出样例：-7" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">6</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<h5 id="参考代码：-8"><a href="#参考代码：-8" class="headerlink" title="参考代码："></a>参考代码：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">int</span> n, m, l, r;</span><br><span class="line"><span class="keyword">int</span> a[N], s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">		s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[r] - s[l - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-2-二维前缀和"><a href="#1-4-2-二维前缀和" class="headerlink" title="1.4.2 二维前缀和"></a>1.4.2 二维前缀和</h3><h4 id="1-原理讲解-8"><a href="#1-原理讲解-8" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><p>定义：二维数组a[] [] 的二维前缀和 S[i, j] = 第i行j列格子左上部分所有元素的和</p>
<script type="math/tex; mode=display">
S[i][j]=\sum_{k_1=1}^i\sum_{k_2=1}^ja[i][j]</script><p>作用：O(1)求出矩阵的某一子矩阵中元素之和</p>
<p>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]</p>
<p><img src="/2021/12/06/basicACML1/二维前缀和.png" alt></p>
<p>几何直观：如上图，所求即红色部分，整体减去左、右斜线阴影部分再加上交叉斜线阴影部分即可得。</p>
<h4 id="2-模板讲解-8"><a href="#2-模板讲解-8" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求前缀和</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line">        s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 几何直观：整体 = 左、右斜线阴影部分和 - 交叉斜线部分 +　红色部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求给定矩形内元素的和</span></span><br><span class="line"><span class="comment">// 给定左上坐标 (x1, y1) 右下坐标 (x2, y2)</span></span><br><span class="line">sum = s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<h4 id="例1-4-2：子矩阵的和"><a href="#例1-4-2：子矩阵的和" class="headerlink" title="例1.4.2：子矩阵的和"></a>例1.4.2：子矩阵的和</h4><p>输入一个 $n$ 行 $m$ 列的整数矩阵，再输入 $q$ 个询问，每个询问包含四个整数 $x_1,y_1,x_2,y_2$ 表示一个子矩阵的左上角坐标和右下角坐标。</p>
<p>对于每个询问输出子矩阵中所有数的和。</p>
<h5 id="输入格式-8"><a href="#输入格式-8" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含三个整数 $n，m，q$。</p>
<p>接下来 $n$ 行，每行包含 $m$ 个整数，表示整数矩阵。</p>
<p>接下来 $q$ 行，每行包含四个整数 $x_1,y_1,x_2,y_2$，表示一组询问。</p>
<h5 id="输出格式-8"><a href="#输出格式-8" class="headerlink" title="输出格式"></a>输出格式</h5><p>共 $q$ 行，每行输出一个询问的结果。</p>
<h5 id="数据范围-8"><a href="#数据范围-8" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n,m≤1000$,</p>
<p>$1≤q≤200000$,</p>
<p>$1≤x_1≤x_2≤n$,</p>
<p>$1≤y_1≤y_2≤m$,</p>
<p>$−1000≤$矩阵内元素的值$≤1000$</p>
<h5 id="输入样例：-8"><a href="#输入样例：-8" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4 3</span><br><span class="line">1 7 2 4</span><br><span class="line">3 6 2 8</span><br><span class="line">2 1 2 3</span><br><span class="line">1 1 2 2</span><br><span class="line">2 1 3 4</span><br><span class="line">1 3 3 4</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-8"><a href="#输出样例：-8" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">17</span><br><span class="line">27</span><br><span class="line">21</span><br></pre></td></tr></table></figure>
<h5 id="参考代码：-9"><a href="#参考代码：-9" class="headerlink" title="参考代码："></a>参考代码：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n, m, q, i, j, x1, x2, y1, y2;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1005</span>][<span class="number">1005</span>], s[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">			s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j];</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-3-一维差分"><a href="#1-4-3-一维差分" class="headerlink" title="1.4.3 一维差分"></a>1.4.3 一维差分</h3><h4 id="1-原理讲解-9"><a href="#1-原理讲解-9" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><p>定义：数组 a[] 的差分数组 c[i] = a[i] - a[i - 1]</p>
<p>作用：O(1)的给数组中的一个区间 [l, r] 同时加上一个数 k：c[l] += k, c[r + 1] -= k</p>
<p>几何直观：</p>
<p><img src="/2021/12/06/basicACML1/一维差分1.png" alt></p>
<p>操作完毕后有 a[i] = c[1] + c[2] + ··· + c[i]</p>
<p>差分可看作前缀和的逆运算</p>
<h4 id="2-模板讲解-9"><a href="#2-模板讲解-9" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给区间[l, r]中的每个数加上k：c[l] += k, c[r + <span class="number">1</span>] -= k</span><br></pre></td></tr></table></figure>
<h4 id="例1-4-3-差分"><a href="#例1-4-3-差分" class="headerlink" title="例1.4.3 差分"></a>例1.4.3 差分</h4><p>输入一个长度为 $n$ 的整数序列。</p>
<p>接下来输入 $m$ 个操作，每个操作包含三个整数 $l,r,c$，表示将序列中 $[l,r]$ 之间的每个数加上 $c$。</p>
<p>请你输出进行完所有操作后的序列。</p>
<h5 id="输入格式-9"><a href="#输入格式-9" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含两个整数 $n$ 和 $m$。</p>
<p>第二行包含 $n$ 个整数，表示整数序列。</p>
<p>接下来 $m$ 行，每行包含三个整数 $l，r，c$，表示一个操作。</p>
<h5 id="输出格式-9"><a href="#输出格式-9" class="headerlink" title="输出格式"></a>输出格式</h5><p>共一行，包含 $n$ 个整数，表示最终序列。</p>
<h5 id="数据范围-9"><a href="#数据范围-9" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n,m≤100000$,</p>
<p>$1≤l≤r≤n$,</p>
<p>$−1000≤c≤1000$,</p>
<p>$−1000≤$整数序列中元素的值$≤1000$</p>
<h5 id="输入样例：-9"><a href="#输入样例：-9" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 3</span><br><span class="line">1 2 2 1 2 1</span><br><span class="line">1 3 1</span><br><span class="line">3 5 1</span><br><span class="line">1 6 1</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-9"><a href="#输出样例：-9" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4 5 3 4 2</span><br></pre></td></tr></table></figure>
<h5 id="参考代码：-10"><a href="#参考代码：-10" class="headerlink" title="参考代码："></a>参考代码：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">int</span> n, m, l, r, k;</span><br><span class="line"><span class="keyword">int</span> a[N], c[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">		c[i] = a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;k);</span><br><span class="line">		c[l] += k;</span><br><span class="line">		c[r + <span class="number">1</span>] -= k;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		a[i] = a[i - <span class="number">1</span>] + c[i];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-4-二维差分"><a href="#1-4-4-二维差分" class="headerlink" title="1.4.4 二维差分"></a>1.4.4 二维差分</h3><h4 id="1-原理讲解-10"><a href="#1-原理讲解-10" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><p>和一维差分相似，二维差分也是为统一增减区域内的值服务的，其运算与二维前缀和互为逆运算</p>
<p>定义：c[x, y] = a[i, j] - a[i - 1, j] - a[i, j - 1] + a[i - 1, j - 1]</p>
<p>作用：O(1)的给数组中的一个区域[(x1, y1), (x2, y2)]同时加上一个数 k：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c[x1, y1] += k, c[x2 + 1, y1] -= k,c[x1, y2 + 1] -= k, c[x2 + 1, y2 + 1] += k;</span><br></pre></td></tr></table></figure>
<h4 id="2-模板讲解-10"><a href="#2-模板讲解-10" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上k：</span><br><span class="line">c[x1, y1] += k, c[x2 + <span class="number">1</span>, y1] -= k,c[x1, y2 + <span class="number">1</span>] -= k, c[x2 + <span class="number">1</span>, y2 + <span class="number">1</span>] += k;</span><br></pre></td></tr></table></figure>
<h4 id="例1-4-4-差分矩阵"><a href="#例1-4-4-差分矩阵" class="headerlink" title="例1.4.4 差分矩阵"></a>例1.4.4 差分矩阵</h4><p>输入一个 $n$ 行 $m$ 列的整数矩阵，再输入 $q$ 个操作，每个操作包含五个整数 $x_1,y_1,x_2,y_2,c$，其中$ (x_1,y_1)$ 和 $(x_2,y_2)$ 表示一个子矩阵的左上角坐标和右下角坐标。</p>
<p>每个操作都要将选中的子矩阵中的每个元素的值加上 $c$。</p>
<p>请你将进行完所有操作后的矩阵输出。</p>
<h5 id="输入格式-10"><a href="#输入格式-10" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $n,m,q$。</p>
<p>接下来 $n$ 行，每行包含 $m$ 个整数，表示整数矩阵。</p>
<p>接下来 $q$ 行，每行包含 $5$ 个整数 $x_1,y_1,x_2,y_2,c$，表示一个操作。</p>
<h5 id="输出格式-10"><a href="#输出格式-10" class="headerlink" title="输出格式"></a>输出格式</h5><p>共 $n$ 行，每行 $m$ 个整数，表示所有操作进行完毕后的最终矩阵。</p>
<h5 id="数据范围-10"><a href="#数据范围-10" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n,m≤1000$,</p>
<p>$1≤q≤100000$,</p>
<p>$1≤x_1≤x_2≤n$,</p>
<p>$1≤y_1≤y_2≤m$,</p>
<p>$−1000≤c≤1000$,</p>
<p>$−1000≤$矩阵内元素的值$≤1000$</p>
<h5 id="输入样例：-10"><a href="#输入样例：-10" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4 3</span><br><span class="line">1 2 2 1</span><br><span class="line">3 2 2 1</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 2 2 1</span><br><span class="line">1 3 2 3 2</span><br><span class="line">3 1 3 4 1</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-10"><a href="#输出样例：-10" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 3 4 1</span><br><span class="line">4 3 4 1</span><br><span class="line">2 2 2 2</span><br></pre></td></tr></table></figure>
<h5 id="参考代码：-11"><a href="#参考代码：-11" class="headerlink" title="参考代码："></a>参考代码：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n, m, q, i, j, x1, x2, y1, y2, cc;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">1005</span>][<span class="number">1005</span>], a[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">			c[i][j] += a[i][j];</span><br><span class="line">			c[i + <span class="number">1</span>][j] -= a[i][j];</span><br><span class="line">			c[i][j + <span class="number">1</span>] -= a[i][j];</span><br><span class="line">			c[i + <span class="number">1</span>][j + <span class="number">1</span>] += a[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;cc);</span><br><span class="line">		c[x1][y1] += cc;</span><br><span class="line">		c[x2 + <span class="number">1</span>][y1] -= cc;</span><br><span class="line">		c[x1][y2 + <span class="number">1</span>] -= cc;</span><br><span class="line">		c[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += cc;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">			a[i][j] = a[i][j - <span class="number">1</span>] + a[i - <span class="number">1</span>][j] - a[i - <span class="number">1</span>][j - <span class="number">1</span>] + c[i][j];</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-5-双指针算法"><a href="#1-5-双指针算法" class="headerlink" title="1.5 双指针算法"></a>1.5 双指针算法</h2><h4 id="1-原理讲解-11"><a href="#1-原理讲解-11" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><p>双指针算法用于查找最长的满足性质 P 的区间 S，在右指针 r 向右移动的同时向右移动左指针 l 以保证区间 [l, r] 满足性质 P，并找出最长的区间。</p>
<h4 id="2-模板讲解-11"><a href="#2-模板讲解-11" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>, maxl = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; r &lt;= n; r++)&#123; <span class="comment">//数组范围[1, n]</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r &amp;&amp; !P(l, r)) <span class="comment">//保证[l, r]满足性质P</span></span><br><span class="line">        l++;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= r) <span class="comment">//更新满足性质的最大区间长度</span></span><br><span class="line">        maxl = max(maxl, r - l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例1-5-1：最长连续不重复子序列"><a href="#例1-5-1：最长连续不重复子序列" class="headerlink" title="例1.5.1：最长连续不重复子序列"></a>例1.5.1：最长连续不重复子序列</h4><p>给定一个长度为 $n$ 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。</p>
<h5 id="输入格式-11"><a href="#输入格式-11" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $n$。</p>
<p>第二行包含 $n$ 个整数（均在 $0∼10^5$ 范围内），表示整数序列。</p>
<h5 id="输出格式-11"><a href="#输出格式-11" class="headerlink" title="输出格式"></a>输出格式</h5><p>共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。</p>
<h5 id="数据范围-11"><a href="#数据范围-11" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n≤10^5$</p>
<h5 id="输入样例：-11"><a href="#输入样例：-11" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 2 3 5</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-11"><a href="#输出样例：-11" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h5 id="参考代码：-12"><a href="#参考代码：-12" class="headerlink" title="参考代码："></a>参考代码：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n, i, j, maxl;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100005</span>], vis[<span class="number">100005</span>]; <span class="comment">//vis[]数组用于存储在当前区间中是否已经包含该数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; n;) &#123;</span><br><span class="line">		<span class="keyword">while</span> (j &lt; n &amp;&amp; vis[a[j]] == <span class="number">0</span>) <span class="comment">//当区间[i, j - 1]中没有a[j]时扩展为区间[i, j]</span></span><br><span class="line">			vis[a[j++]]++;</span><br><span class="line">		<span class="keyword">if</span> (maxl &lt; j - i) <span class="comment">//更新满足性质的最长区间长度</span></span><br><span class="line">			maxl = j - i;</span><br><span class="line">		<span class="keyword">while</span> (vis[a[j]]) <span class="comment">//当区间中存在a[j]时将左边界更新为值为a[j]的下标+1</span></span><br><span class="line">			vis[a[i++]]--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, maxl);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例1-5-2：数组元素的目标和"><a href="#例1-5-2：数组元素的目标和" class="headerlink" title="例1.5.2：数组元素的目标和"></a>例1.5.2：数组元素的目标和</h4><p>给定两个升序排序的有序数组 $A$ 和 $B$，以及一个目标值 $x$。</p>
<p>数组下标从 $0$ 开始。</p>
<p>请你求出满足 $A[i]+B[j]=x$ 的数对 $(i,j)$。</p>
<p>数据保证有唯一解。</p>
<h5 id="输入格式-12"><a href="#输入格式-12" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含三个整数 $n,m,x$，分别表示 $A$ 的长度，$B$ 的长度以及目标值 $x$。</p>
<p>第二行包含 $n$ 个整数，表示数组 $A$。</p>
<p>第三行包含 $m$ 个整数，表示数组 $B$。</p>
<h5 id="输出格式-12"><a href="#输出格式-12" class="headerlink" title="输出格式"></a>输出格式</h5><p>共一行，包含两个整数 $i$ 和 $j$。</p>
<h5 id="数据范围-12"><a href="#数据范围-12" class="headerlink" title="数据范围"></a>数据范围</h5><p>数组长度不超过 $10^5$。</p>
<p>同一数组内元素各不相同。</p>
<p>$1≤$数组元素$≤10^9$</p>
<h5 id="输入样例：-12"><a href="#输入样例：-12" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5 6</span><br><span class="line">1 2 4 7</span><br><span class="line">3 4 6 8 9</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-12"><a href="#输出样例：-12" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1</span><br></pre></td></tr></table></figure>
<h5 id="参考代码：-13"><a href="#参考代码：-13" class="headerlink" title="参考代码："></a>参考代码：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">int</span> n, m, x;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;x);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>, j = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">//i是当前访问的数组b[]中元素的下标 j是a[]的</span></span><br><span class="line">		<span class="keyword">while</span> (b[i] + a[j] &lt; x)</span><br><span class="line">			j++;</span><br><span class="line">		<span class="keyword">if</span> (b[i] + a[j] == x) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, j, i);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-6-位运算"><a href="#1-6-位运算" class="headerlink" title="1.6 位运算"></a>1.6 位运算</h2><h4 id="1-原理讲解-12"><a href="#1-原理讲解-12" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><h5 id="基本位运算"><a href="#基本位运算" class="headerlink" title="基本位运算"></a>基本位运算</h5><p>c中所有整型都以2进制的形式进行存储，而非负整数则以原码的形式存储。</p>
<p>位运算包括但不仅限于按位与 &amp;，按位或 |，按位异或 ^、按位取反 ~、左移运算 &lt;&lt;、右移运算&gt;&gt;等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">按位与运算指整数n, m的2进制形式n(B)，m(B)的相同位置进行如下的与运算的得到的结果</span><br><span class="line">0 &amp; 0 = 0</span><br><span class="line">0 &amp; 1 = 0</span><br><span class="line">1 &amp; 0 = 0</span><br><span class="line">1 &amp; 1 = 1 //与运算的特点是当且仅当二者同真时为真，只要有一者为假即为假</span><br><span class="line">例如：3 = 011(B), 5= 101(B), 则 3 &amp; 5 = 001(B) = 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">按位或运算指整数n, m的2进制形式n(B)，m(B)的相同位置进行如下的或运算的得到的结果</span><br><span class="line">0 | 0 = 0</span><br><span class="line">0 | 1 = 1</span><br><span class="line">1 | 0 = 1</span><br><span class="line">1 | 1 = 1 //或运算的特点是只要有一者为真时即为真，当且仅当两者都为假时为假</span><br><span class="line">例如：3 = 011(B), 5 = 101(B), 则 3 | 5 = 111(B) = 7</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">按位或运算指整数n, m的2进制形式n(B)，m(B)的相同位置进行如下的或运算的得到的结果</span><br><span class="line">0 ^ 0 = 0</span><br><span class="line">0 ^ 1 = 1</span><br><span class="line">1 ^ 0 = 1</span><br><span class="line">1 ^ 1 = 0 //异或运算的特点是当且仅当两者不同时为真，两者相同时为假</span><br><span class="line">例如：3 = 011(B), 5 = 101(B), 则 3 ^ 5 = 110(B) = 6</span><br></pre></td></tr></table></figure>
<p>在引入按位取反运算之前，还需铺垫C中负整数的表示方式。负整数在C中用补码存储，补码即反码 +1，而反码即除符号位外均按位取反，例如 A = 23用二进制表示为 = 00010111(B)，-A 的源码 = 10010111(B)，反码 B = 11101000(B)，补码 C = 01101001(B)，lowbit(A) = A &amp; -A = A(B) &amp; C(B) = 00000001(B) = 1。</p>
<p>反码运算：</p>
<script type="math/tex; mode=display">
(X)_{反}=\left\{ \begin{array}{ll}
X & \textrm{ 0 ≤ X < $2^{n-1}$}\\
2^{n}-1-|x| & \textrm{-$2^{n-1}$ < X ≤ 0}
\end{array} \right.</script><p>其中n为整数2进制表示的位 (bit) 数</p>
<p>补码运算：</p>
<script type="math/tex; mode=display">
(X)_{补}=\left\{ \begin{array}{ll}
X & \textrm{ 0 ≤ X < $2^{n-1}$}\\
2^{n}-|x| & \textrm{-$2^{n-1}$ ≤ X < 0}
\end{array} \right.</script><p>因而，负数的补码还原成原数有</p>
<script type="math/tex; mode=display">
X=(X)_补-2^n</script><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">按位取反是单目运算，即原数中的1全部用0替换，反之原数中的0全部用1替换</span><br><span class="line">~16 = ~00010000(B) = 11101111(B) = -17</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">左移运算即将x的二进制表示x(B)的有效值向左移动并在空位补0</span><br><span class="line">例如 5 &lt;&lt; 2 = 101(B) &lt;&lt; 2 = 10100(B) = 20</span><br><span class="line">实际上左移k位可以看作在原数的基础上乘上2的k次幂</span><br><span class="line">例如：x &lt;&lt; 1 = x * 2, x &lt;&lt; 2 = x * 4, x &lt;&lt; n = x * pow(2, n)</span><br><span class="line">左移运算比乘法快得多，但仅限于乘2的倍数，其实也可以利用左移运算进行固定整数的乘法</span><br><span class="line">例如：(x &lt;&lt; 1 + x &lt;&lt; 3) = x * 10</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">右移运算即将x的二进制表示x(B)的有效值向右移动并舍弃移动后第0位之前的数</span><br><span class="line">例如 21 &gt;&gt; 2 = 10101(B) &gt;&gt; 1 = 101(B) = 5</span><br><span class="line">实际上右移k位可以看作在原数的基础上作2的k次幂的整除</span><br><span class="line">例如 x &gt;&gt; 1 = x / 2, x &gt;&gt; 3 = x / 8, x &gt;&gt; n = x / pow(2, n)</span><br><span class="line">右移运算比除法快得多，因此在整数二分时我们常常写作mid = (l + r) &gt;&gt; 1</span><br></pre></td></tr></table></figure>
<h5 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">求n的第k位数字: n &gt;&gt; k &amp; <span class="number">1</span> <span class="comment">// 将n右移k位后与1按位与</span></span><br><span class="line">返回n的最后一位<span class="number">1</span>：<span class="built_in">lowbit</span>(n) = n &amp; -n</span><br></pre></td></tr></table></figure>
<p>为何 A &amp; -A 能返回 n 的最后一位1？</p>
<p>假设A的最后一位1在右数第k位，则有A = 0ab···c10······0，(-A) 原 = 1ab···c10······0，(-A) 反 = 1xy···z01······1，(-A) 补 = 1xy···z10······0，因而 A &amp; (-A) = 000···010······0</p>
<h5 id="一些结论"><a href="#一些结论" class="headerlink" title="一些结论"></a>一些结论</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4k^(4k+1)^(4k+2)^(4k+3) = 0</span><br></pre></td></tr></table></figure>
<h4 id="例1-6：进制中1的个数"><a href="#例1-6：进制中1的个数" class="headerlink" title="例1.6：进制中1的个数"></a>例1.6：进制中1的个数</h4><p>给定一个长度为 $n$ 的数列，请你求出数列中每个数的二进制表示中 $1$ 的个数。</p>
<h5 id="输入格式-13"><a href="#输入格式-13" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $n$。</p>
<p>第二行包含 $n$ 个整数，表示整个数列。</p>
<h5 id="输出格式-13"><a href="#输出格式-13" class="headerlink" title="输出格式"></a>输出格式</h5><p>共一行，包含 $n$ 个整数，其中的第 $i$ 个数表示数列中的第 $i$ 个数的二进制表示中 $1$ 的个数。</p>
<h5 id="数据范围-13"><a href="#数据范围-13" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n≤100000$,</p>
<p>$0≤$数列中元素的值$≤10^9$</p>
<h5 id="输入样例：-13"><a href="#输入样例：-13" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-13"><a href="#输出样例：-13" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1 2 1 2</span><br></pre></td></tr></table></figure>
<h5 id="参考代码：-14"><a href="#参考代码：-14" class="headerlink" title="参考代码："></a>参考代码：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(n) (n)&amp;(-(n))</span></span><br><span class="line"><span class="keyword">int</span> n, a, cnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">		cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (a) &#123;</span><br><span class="line">			a -= lowbit(a);</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, cnt);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-7-离散化"><a href="#1-7-离散化" class="headerlink" title="1.7 离散化"></a>1.7 离散化</h2><h4 id="1-原理讲解-13"><a href="#1-原理讲解-13" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><p>离散化，用于将较大空间中的个体映射到有限的空间中。有些数据本身过大或为浮点数，自身无法作为数组的下标保存对应属性，如果只需利用这些数据的相对大小的属性，则可以将它们离散化处理。</p>
<p>例如，原数据1099999999，9，0，16726783，处理后则为3，1，0，2（存储它们的数组下标）。</p>
<h4 id="2-模板讲解-12"><a href="#2-模板讲解-12" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());   <span class="comment">// 去掉重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">// 找到第一个大于等于x的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1, 2, ...n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例1-7：-区间和"><a href="#例1-7：-区间和" class="headerlink" title="例1.7： 区间和"></a>例1.7： 区间和</h4><p>假定有一个无限长的数轴，数轴上每个坐标上的数都是 $0$。</p>
<p>现在，我们首先进行 $n$ 次操作，每次操作将某一位置 $x$ 上的数加 $c$。</p>
<p>接下来，进行 $m$ 次询问，每个询问包含两个整数 $l$ 和 $r$，你需要求出在区间 $[l,r]$ 之间的所有数的和。</p>
<h5 id="输入格式-14"><a href="#输入格式-14" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含两个整数 $n$ 和 $m$。</p>
<p>接下来 $n$ 行，每行包含两个整数 $x$ 和 $c$。</p>
<p>再接下来 $m$ 行，每行包含两个整数 $l$ 和 $r$。</p>
<h5 id="输出格式-14"><a href="#输出格式-14" class="headerlink" title="输出格式"></a>输出格式</h5><p>共 $m$ 行，每行输出一个询问中所求的区间内数字和。</p>
<h5 id="数据范围-14"><a href="#数据范围-14" class="headerlink" title="数据范围"></a>数据范围</h5><p>$−10^9≤x≤10^9$,</p>
<p>$1≤n,m≤10^5$,</p>
<p>$−10^9≤l≤r≤10^9$,</p>
<p>$−10000≤c≤10000$</p>
<h5 id="输入样例：-14"><a href="#输入样例：-14" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">3 6</span><br><span class="line">7 5</span><br><span class="line">1 3</span><br><span class="line">4 6</span><br><span class="line">7 8</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-14"><a href="#输出样例：-14" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">0</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h5 id="参考代码：-15"><a href="#参考代码：-15" class="headerlink" title="参考代码："></a>参考代码：</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; alls;</span><br><span class="line"><span class="keyword">int</span> x[MAXN], c[MAXN], l[MAXN], r[MAXN];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span> * MAXN], s[<span class="number">3</span> * MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">//找到第一个大于等于x的位置</span></span><br><span class="line">	<span class="keyword">int</span> ll = <span class="number">0</span>, rr = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (ll &lt; rr) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = ll + rr &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (alls[mid] &gt;= x)</span><br><span class="line">			rr = mid;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			ll = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> rr + <span class="number">1</span>; <span class="comment">//映射到[1, alls.size()]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m, i, j;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x[i], &amp;c[i]);</span><br><span class="line">		alls.<span class="built_in">push_back</span>(x[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l[i], &amp;r[i]);</span><br><span class="line">		alls.<span class="built_in">push_back</span>(l[i]);</span><br><span class="line">		alls.<span class="built_in">push_back</span>(r[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());</span><br><span class="line">	alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span> (n--; n &gt;= <span class="number">0</span>; n--)</span><br><span class="line">		a[<span class="built_in">find</span>(x[n])] += c[n];</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= alls.<span class="built_in">size</span>(); i++)</span><br><span class="line">		s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[<span class="built_in">find</span>(r[i])] - s[<span class="built_in">find</span>(l[i]) - <span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-8-区间合并"><a href="#1-8-区间合并" class="headerlink" title="1.8 *区间合并"></a>1.8 *区间合并</h2><h4 id="模板讲解"><a href="#模板讲解" class="headerlink" title="模板讲解"></a>模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将所有存在交集的区间合并</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span> <span class="comment">//待处理的区间集合</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res; <span class="comment">//寄存合并好的区间</span></span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>()); <span class="comment">//按左边界的大小排序</span></span><br><span class="line">    <span class="keyword">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>; <span class="comment">//上一个处理的区间起点和终点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first) <span class="comment">//如果上一个（合并好的）区间的终点比下一个区间的起点小，即两个区间没有相交的部分</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;); <span class="comment">//如果不是初值就将上一个合并好的区间推到寄存器中</span></span><br><span class="line">            st = seg.first, ed = seg.second; <span class="comment">//重置上一个处理的区间起点和终点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second); <span class="comment">//区间合并</span></span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;); <span class="comment">//如果起点不是初值说明存在合并好的区间</span></span><br><span class="line">    segs = res; <span class="comment">//将寄存器中合并好的区间传给segs</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例1-8-区间合并"><a href="#例1-8-区间合并" class="headerlink" title="例1.8 区间合并"></a>例1.8 区间合并</h4><p>给定 $n$ 个区间 $[l_i,r_i]$，要求合并所有有交集的区间。</p>
<p>注意如果在端点处相交，也算有交集。</p>
<p>输出合并完成后的区间个数。</p>
<p>例如：$[1,3]$ 和 $[2,6]$ 可以合并为一个区间 $[1,6]$。</p>
<h5 id="输入格式-15"><a href="#输入格式-15" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $n$。</p>
<p>接下来 $n$ 行，每行包含两个整数 $l$ 和 $r$。</p>
<h5 id="输出格式-15"><a href="#输出格式-15" class="headerlink" title="输出格式"></a>输出格式</h5><p>共一行，包含一个整数，表示合并区间完成后的区间个数。</p>
<h5 id="数据范围-15"><a href="#数据范围-15" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n≤100000$,</p>
<p>$−10^9≤l_i≤r_i≤10^9$</p>
<h5 id="输入样例：-15"><a href="#输入样例：-15" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">5 6</span><br><span class="line">7 8</span><br><span class="line">7 9</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-15"><a href="#输出样例：-15" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h5 id="参考代码：-16"><a href="#参考代码：-16" class="headerlink" title="参考代码："></a>参考代码：</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span> </span>&#123;</span><br><span class="line">	vector&lt;PII&gt; res;</span><br><span class="line">	<span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">		<span class="keyword">if</span> (ed &lt; seg.first) &#123;</span><br><span class="line">			<span class="keyword">if</span> (st != <span class="number">-2e9</span>)</span><br><span class="line">				res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">			st = seg.first, ed = seg.second;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			ed = <span class="built_in">max</span>(ed, seg.second);</span><br><span class="line">	<span class="keyword">if</span> (st != <span class="number">-2e9</span>)</span><br><span class="line">		res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">	segs = res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, l, r;</span><br><span class="line">	vector&lt;PII&gt; VPII;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">		VPII.<span class="built_in">push_back</span>(&#123;l, r&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">merge</span>(VPII);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, VPII.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>npuCS 第二讲 数据结构</title>
    <url>/2021/12/06/basicACML2/</url>
    <content><![CDATA[<h1 id="第二讲-数据结构"><a href="#第二讲-数据结构" class="headerlink" title="第二讲 数据结构"></a>第二讲 数据结构</h1><h2 id="2-0-树"><a href="#2-0-树" class="headerlink" title="2.0 树"></a>2.0 树</h2><h3 id="2-0-1树的定义"><a href="#2-0-1树的定义" class="headerlink" title="2.0.1树的定义"></a>2.0.1树的定义</h3><p>树是由一个集合以及在该集合上定义的一种关系构成的，集合中的元素称为树的结点，所定义的关系称为父子关系。父子关系在树的结点之间建立了一个层次结构，在这种层次结构中有一个结点具有特殊的地位，这个结点称为该树的根结点。</p>
<h3 id="2-0-2树的基本术语"><a href="#2-0-2树的基本术语" class="headerlink" title="2.0.2树的基本术语"></a>2.0.2树的基本术语</h3><p>节点的度：一个节点含有的子树的个数称为该节点的度；</p>
<p>叶节点或终端节点：度为$0$的节点称为叶节点；</p>
<p>非终端节点或分支节点：度不为$0$的节点；</p>
<p>双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；</p>
<p>孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；</p>
<p>兄弟节点：具有相同父节点的节点互称为兄弟节点；</p>
<p>树的度：一棵树中，最大的节点的度称为树的度；</p>
<p>节点的层次：从根开始定义起，根为第$1$层，根的子节点为第$2$层，以此类推；</p>
<p>树的高度或深度：树中节点的最大层次；</p>
<p>堂兄弟节点：双亲在同一层的节点互为堂兄弟；</p>
<p>节点的祖先：从根到该节点所经分支上的所有节点；</p>
<p>子孙：以某节点为根的子树中任一节点都称为该节点的子孙。</p>
<p>森林：由$m$（$m&gt;=0$）棵互不相交的树的集合称为森林；</p>
<h3 id="2-0-3-二叉树"><a href="#2-0-3-二叉树" class="headerlink" title="2.0.3 二叉树"></a>2.0.3 二叉树</h3><p>二叉树是数据结构中一种重要的数据结构，也是树表家族最为基础的结构。</p>
<p>二叉树的定义：二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。</p>
<h4 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入序列为前序遍历如 s[]=423002000   &#x27;0&#x27;表示无此节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[++k] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    a[++cnt].t = s[k];</span><br><span class="line">    <span class="keyword">int</span> rt = cnt;</span><br><span class="line">    a[cnt].l = <span class="built_in">Build</span>();</span><br><span class="line">    a[cnt].r = <span class="built_in">Build</span>();</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Order</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;a[k].t &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">PreOrder</span>(a[k].l);</span><br><span class="line">        <span class="built_in">PreOrder</span>(a[k].r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Order</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">PreOrder</span>(a[k].l);</span><br><span class="line">        cout&lt;&lt;a[k].t &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">PreOrder</span>(a[k].r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Order</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">PreOrder</span>(a[k].l);</span><br><span class="line">        <span class="built_in">PreOrder</span>(a[k].r);</span><br><span class="line">        cout&lt;&lt;a[k].t&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-1-链表与邻接表：树与图的存储"><a href="#2-1-链表与邻接表：树与图的存储" class="headerlink" title="2.1 链表与邻接表：树与图的存储"></a>2.1 链表与邻接表：树与图的存储</h2><h3 id="2-1-1-单链表"><a href="#2-1-1-单链表" class="headerlink" title="2.1.1 单链表"></a>2.1.1 单链表</h3><h4 id="1-原理讲解"><a href="#1-原理讲解" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><p>单链表常见的实现方法有两种，一种方式是定义一个结构体表示链表节点。这种方式有个明显的缺点，就是不能随机存取。如果要在某个节点之后插入或者删除节点，复杂度是$O(n)$，因为要从头开始逐个遍历到需要插入或者删除的节点。</p>
<p>因此算法题中使用单链表往往是通过数组实现，数组实现的单链表可以通过下标来索引节点，可以直接通过下标找到某个节点的值和下一个节点的，因此数组实现的单链表的最大优点就是快，因为插入和删除操作都是$O(1)$的时间复杂度，毕竟数组的特点就是随机存取。</p>
<p>单链表的一般操作有三个：在链表头插入一个数$a$、删除任意一个结点、在第$k$次插入的结点的后面添加一个结点。具体如何实现看模板代码。</p>
<p>用$head$存储链表头，$e[]$存储每个节点的值，$ne[]$存储节点的$next$指针，这样通过$ne[]$将每个节点链接起来，形成单链表。</p>
<h4 id="2-模板讲解"><a href="#2-模板讲解" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="keyword">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表头插入一个数a</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = a, ne[idx] = head, head = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将头结点删除，需要保证头结点存在</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = ne[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例2-1-1：单链表"><a href="#例2-1-1：单链表" class="headerlink" title="例2.1.1：单链表"></a>例2.1.1：单链表</h4><h5 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h5><p>实现一个单链表，链表初始为空，支持三种操作：</p>
<ol>
<li>向链表头插入一个数；</li>
<li>删除第 $k$ 个插入的数后面的数；</li>
<li>在第 $k$ 个插入的数后插入一个数。</li>
</ol>
<p>现在要对该链表进行 $M$ 次操作，进行完所有操作后，从头到尾输出整个链表。</p>
<p>注意：题目中第 $k$ 个插入的数并不是指当前链表的第 $k$ 个数。例如操作过程中一共插入了 $n$ 个数，则按照插入的时间顺序，这 $n$ 个数依次为：第 $1$ 个插入的数，第 $2$ 个插入的数，…第 $n$ 个插入的数。</p>
<h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $M$，表示操作次数。</p>
<p>接下来 $M$ 行，每行包含一个操作命令，操作命令可能为以下几种：</p>
<ol>
<li><em>H x</em>，表示向链表头插入一个数 $x$。</li>
<li><em>D k</em>，表示删除第 $k$ 个插入的数后面的数（当 $k$ 为 $0$ 时，表示删除头结点）。</li>
<li><em>I k x</em>，表示在第 $k$ 个插入的数后面插入一个数 $x$（此操作中 $k$ 均大于 $0$）。</li>
</ol>
<h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>共一行，将整个链表从头到尾输出。</p>
<h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤M≤100000$</p>
<p>所有操作保证合法。</p>
<h5 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">H 9</span><br><span class="line">I 1 1</span><br><span class="line">D 1</span><br><span class="line">D 0</span><br><span class="line">H 6</span><br><span class="line">I 3 6</span><br><span class="line">I 4 5</span><br><span class="line">I 4 5</span><br><span class="line">I 3 4</span><br><span class="line">D 6</span><br></pre></td></tr></table></figure>
<h5 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 4 6 5</span><br></pre></td></tr></table></figure>
<h5 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;                        <span class="comment">//m次操作</span></span><br><span class="line"><span class="keyword">int</span> e[N], ne[N], head, idx;   <span class="comment">//e存储每个结点的值，ne存储每个结点所指向的结点的下标，head存储头结点的下标，idx表示当前正在进行操作的结点的下标。(三个下标一个值)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;      <span class="comment">//head指向空结点</span></span><br><span class="line">    idx = <span class="number">1</span>;        <span class="comment">//从1开始输入结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_head</span><span class="params">(<span class="keyword">int</span> x)</span>   <span class="comment">//往头结点添加结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = head, head = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x)</span>    <span class="comment">//一般情况，往第k次插入的结点的后面添加一个结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span>        <span class="comment">//删除一个结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k, x;</span><br><span class="line">        <span class="keyword">char</span> a;</span><br><span class="line"></span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a == <span class="string">&#x27;H&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add_to_head</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>)head = ne[head];   <span class="comment">//一定要注意这里的特判，即删除头结点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">remove</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(k, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">       cout &lt;&lt; e[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-2-双链表"><a href="#2-1-2-双链表" class="headerlink" title="2.1.2 双链表"></a>2.1.2 双链表</h3><h4 id="1-原理讲解-1"><a href="#1-原理讲解-1" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><p>双链表与单链表相比，不仅要存储左边节点的下标还要存储右边节点的下标，也就是要开两个数组存储每个节点的左右两个指针。开头是头结点，结尾是尾结点。这样的话既可以从头结点往后遍历，也可以从尾结点往前遍历。</p>
<p>双链表的基本操作有五种：删除任意一个结点、在头结点(最左侧)插入数据、在尾结点(最右侧)插入数据、在第k次插入的数据左边插入数据、在第k次插入的数据右边插入数据。但是后面四种插入操作都可以用同一个函数来描述。具体如何实现看模板代码。</p>
<h4 id="2-模板讲解-1"><a href="#2-模板讲解-1" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="keyword">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//0是左端点，1是右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在节点a的右边插入一个数x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = a, r[idx] = r[a];</span><br><span class="line">    l[r[a]] = idx, r[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点a</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[r[a]] = l[a];</span><br><span class="line">    r[l[a]] = r[a];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="例2-1-2-双链表"><a href="#例2-1-2-双链表" class="headerlink" title="例2.1.2:双链表"></a>例2.1.2:双链表</h4><h5 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h5><p>实现一个双链表，双链表初始为空，支持 $5$ 种操作：</p>
<ol>
<li>在最左侧插入一个数；</li>
<li>在最右侧插入一个数；</li>
<li>将第 $k$ 个插入的数删除；</li>
<li>在第 $k$ 个插入的数左侧插入一个数；</li>
<li>在第 $k$ 个插入的数右侧插入一个数</li>
</ol>
<p>现在要对该链表进行 $M$ 次操作，进行完所有操作后，从左到右输出整个链表。</p>
<p><strong>注意</strong>:题目中第 $k$ 个插入的数并不是指当前链表的第 $k$ 个数。例如操作过程中一共插入了 $n$ 个数，则按照插入的时间顺序，这 $n$ 个数依次为：第 $1$ 个插入的数，第 $2$ 个插入的数，…第 $n$ 个插入的数。</p>
<h5 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $M$，表示操作次数。</p>
<p>接下来 $M$ 行，每行包含一个操作命令，操作命令可能为以下几种：</p>
<ol>
<li><em>L x</em>，表示在链表的最左端插入数 $x$。</li>
<li><em>R x</em>，表示在链表的最右端插入数 $x$。</li>
<li><em>D k</em>，表示将第 $k$ 个插入的数删除。</li>
<li><em>IL k x</em>，表示在第 $k$ 个插入的数左侧插入一个数。</li>
<li><em>IR k x</em>，表示在第 $k$ 个插入的数右侧插入一个数。</li>
</ol>
<h5 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h5><p>共一行，将整个链表从左到右输出。</p>
<h5 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤M≤100000$</p>
<p>所有操作保证合法。</p>
<h5 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">R 7</span><br><span class="line">D 1</span><br><span class="line">L 3</span><br><span class="line">IL 2 10</span><br><span class="line">D 3</span><br><span class="line">IL 2 7</span><br><span class="line">L 8</span><br><span class="line">R 9</span><br><span class="line">IL 4 7</span><br><span class="line">IR 2 2</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 7 7 3 2 9</span><br></pre></td></tr></table></figure>
<h5 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> e[N], ne[N], pre[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    pre[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[pre[k]] = ne[k];</span><br><span class="line">    pre[ne[k]] = pre[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x)</span>            <span class="comment">//一般操作，在下标为k的结点右边插入数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = ne[k], pre[idx] = k;</span><br><span class="line">    pre[ne[k]] = idx, ne[k] = idx;</span><br><span class="line">    idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line">        <span class="keyword">int</span> k, x;</span><br><span class="line"></span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(<span class="number">0</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;R&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(pre[<span class="number">1</span>], x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="built_in">remove</span>(k + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; op;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(op == <span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">                <span class="built_in">add</span>(pre[k + <span class="number">1</span>], x);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">                <span class="built_in">add</span>(k + <span class="number">1</span>, x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = ne[<span class="number">0</span>]; i != <span class="number">1</span>; i = ne[i])</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,e[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-栈与队列：单调队列、单调栈"><a href="#2-2-栈与队列：单调队列、单调栈" class="headerlink" title="2.2 栈与队列：单调队列、单调栈"></a>2.2 栈与队列：单调队列、单调栈</h2><h3 id="2-2-1-栈"><a href="#2-2-1-栈" class="headerlink" title="2.2.1 栈"></a>2.2.1 栈</h3><h4 id="1-原理讲解-2"><a href="#1-原理讲解-2" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><p>栈是一种先进后出的线性表数据结构。其添加和删除元素都是发生在同一端，这一端称之为顶部，相对的那一端称为底部。当表中没有元素时称为空栈。</p>
<p>用数组实现的栈通常有四种操作：向栈顶插入一个数、从栈顶弹出一个数、栈顶的值、判断栈是否为空。</p>
<p>具体如何实现看模板代码。</p>
<h4 id="2-模板讲解-2"><a href="#2-模板讲解-2" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tt表示栈顶</span></span><br><span class="line"><span class="keyword">int</span> stk[N], tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向栈顶插入一个数</span></span><br><span class="line">stk[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从栈顶弹出一个数</span></span><br><span class="line">tt -- ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈顶的值</span></span><br><span class="line">stk[tt];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="keyword">if</span> (tt &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例2-2-1-模拟栈"><a href="#例2-2-1-模拟栈" class="headerlink" title="例2.2.1 模拟栈"></a>例2.2.1 模拟栈</h4><p>实现一个栈，栈初始为空，支持四种操作：</p>
<ol>
<li><em>push x</em> – 向栈顶插入一个数 $x$；</li>
<li><em>pop</em> – 从栈顶弹出一个数；</li>
<li><em>empty</em> – 判断栈是否为空；</li>
<li><em>query</em> – 查询栈顶元素。</li>
</ol>
<p>现在要对栈进行 $M$ 个操作，其中的每个操作 $3$ 和操作 $4$ 都要输出相应的结果。</p>
<h5 id="输入格"><a href="#输入格" class="headerlink" title="输入格"></a>输入格</h5><p>第一行包含整数 $M$，表示操作次数。</p>
<p>接下来 $M$ 行，每行包含一个操作命令，操作命令为 <em>push x</em>，<em>pop</em>，<em>empty</em>，<em>query</em> 中的一种。</p>
<h5 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h5><p>对于每个 <em>empty</em> 和 <em>query</em> 操作都要输出一个查询结果，每个结果占一行。</p>
<p>其中，<em>empty</em> 操作的查询结果为 <em>YES</em> 或 <em>NO</em>，<em>query</em> 操作的查询结果为一个整数，表示栈顶元素的值。</p>
<h5 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤M≤100000$,.</p>
<p>$1≤x≤10^9$</p>
<p>所有操作保证合法。</p>
<h5 id="输入样例：-2"><a href="#输入样例：-2" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">push 5</span><br><span class="line">query</span><br><span class="line">push 6</span><br><span class="line">pop</span><br><span class="line">query</span><br><span class="line">pop</span><br><span class="line">empty</span><br><span class="line">push 4</span><br><span class="line">query</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">5</span><br><span class="line">YES</span><br><span class="line">4</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>
<h5 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> stk[N], tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        string str;</span><br><span class="line"></span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(str == <span class="string">&quot;push&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            stk[++ tt] = x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str == <span class="string">&quot;pop&quot;</span>)</span><br><span class="line">          tt --;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str == <span class="string">&quot;empty&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tt &gt; <span class="number">0</span>)</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str == <span class="string">&quot;query&quot;</span>)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,stk[tt]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-2-队列"><a href="#2-2-2-队列" class="headerlink" title="2.2.2 队列"></a>2.2.2 队列</h3><h4 id="1-原理讲解-3"><a href="#1-原理讲解-3" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><p>队列与栈相反，是一种先进先出的线性表数据结构。允许删除的一端为队头；允许插入的一端为队尾。向队列中插入元素称为入队或者进队；删除元素称为出队或者离队。没有元素的队列为空队列。</p>
<p>使用数组q[]存储队列。通常队列有四种操作：向队尾插入一个数、从队头弹出一个数、队头的值、判断队列是否为空。具体如何实现看模板代码。</p>
<h4 id="2-模板讲解-3"><a href="#2-模板讲解-3" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><p>普通队列：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾</span></span><br><span class="line"><span class="keyword">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> (hh &lt;= tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>*循环队列：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾的后一个位置</span></span><br><span class="line"><span class="keyword">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[tt ++ ] = x;</span><br><span class="line"><span class="keyword">if</span> (tt == N) tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"><span class="keyword">if</span> (hh == N) hh = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> (hh != tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例2-2-2-模拟队列"><a href="#例2-2-2-模拟队列" class="headerlink" title="例2.2.2 模拟队列"></a>例2.2.2 模拟队列</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>实现一个队列，队列初始为空，支持四种操作：</p>
<ol>
<li><em>push x</em> – 向队尾插入一个数 xx；</li>
<li><em>pop</em> – 从队头弹出一个数；</li>
<li><em>empty</em> – 判断队列是否为空；</li>
<li><em>query</em> – 查询队头元素。</li>
</ol>
<p>现在要对队列进行 $M$ 个操作，其中的每个操作 $3$ 和操作 $4$ 都要输出相应的结果。</p>
<h5 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $M$，表示操作次数。</p>
<p>接下来 $M$ 行，每行包含一个操作命令，操作命令为 <em>push x</em>，<em>pop</em>，<em>empty</em>，<em>query</em> 中的一种。</p>
<h5 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h5><p>对于每个 <em>empty</em> 和 <em>query</em> 操作都要输出一个查询结果，每个结果占一行。</p>
<p>其中，<em>empty</em> 操作的查询结果为 <em>YES</em> 或 <em>NO</em>，<em>query</em> 操作的查询结果为一个整数，表示队头元素的值。</p>
<h5 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤M≤100000$,</p>
<p>$1≤x≤10^9$,</p>
<p>所有操作保证合法。</p>
<h5 id="输入样例：-3"><a href="#输入样例：-3" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">push 6</span><br><span class="line">empty</span><br><span class="line">query</span><br><span class="line">pop</span><br><span class="line">empty</span><br><span class="line">push 3</span><br><span class="line">push 4</span><br><span class="line">pop</span><br><span class="line">query</span><br><span class="line">push 6</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-3"><a href="#输出样例：-3" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NO</span><br><span class="line">6</span><br><span class="line">YES</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h5 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码"></a>AC代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> q[N], hh, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    string str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(str == <span class="string">&quot;push&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            q[++ tt] = x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str == <span class="string">&quot;pop&quot;</span>)</span><br><span class="line">            hh ++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str == <span class="string">&quot;empty&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span>(hh &gt; tt)<span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,q[hh]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-3-单调栈"><a href="#2-2-3-单调栈" class="headerlink" title="2.2.3 单调栈"></a>2.2.3 单调栈</h3><h4 id="1-原理讲解-4"><a href="#1-原理讲解-4" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><p>单调递增栈：在保持栈内元素单调递增的前提下（如果栈顶元素大于要入栈的元素，将将其弹出），将新元素入栈。</p>
<p>单调递减栈：在保持栈内元素单调递减的前提下（如果栈顶元素小于要入栈的元素，则将其弹出），将新元素入栈。</p>
<p>单调栈的时间复杂度是$O(n)$</p>
<h4 id="2-模板讲解-4"><a href="#2-模板讲解-4" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常见模型：找出每个数左边离它最近的比它大/小的数</span></span><br><span class="line"><span class="keyword">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (tt &amp;&amp; <span class="built_in">check</span>(stk[tt], i)) tt -- ;</span><br><span class="line">    stk[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例2-2-3-单调栈"><a href="#例2-2-3-单调栈" class="headerlink" title="例2.2.3 单调栈"></a>例2.2.3 单调栈</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个长度为 $N$ 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 $−1$。</p>
<h5 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $N$，表示数列长度。</p>
<p>第二行包含 $N$ 个整数，表示整数数列。</p>
<h5 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h5><p>共一行，包含 $N$ 个整数，其中第 $i$ 个数表示第 $i$ 个数的左边第一个比它小的数，如果不存在则输出 $−1$。</p>
<h5 id="数据范围："><a href="#数据范围：" class="headerlink" title="数据范围："></a>数据范围：</h5><p>$1≤N≤10^5$</p>
<p>$1≤$数列中元素$≤10^9$</p>
<h5 id="输入样例：-4"><a href="#输入样例：-4" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 2 7 5</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-4"><a href="#输出样例：-4" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1 3 -1 2 2</span><br></pre></td></tr></table></figure>
<h3 id="2-2-4-单调队列"><a href="#2-2-4-单调队列" class="headerlink" title="2.2.4 单调队列"></a>2.2.4 单调队列</h3><h4 id="1-原理讲解-5"><a href="#1-原理讲解-5" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><h4 id="2-模板讲解-5"><a href="#2-模板讲解-5" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常见模型：找出滑动窗口中的最大值/最小值</span></span><br><span class="line"><span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check_out</span>(q[hh])) hh ++ ;  <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check</span>(q[tt], i)) tt -- ;</span><br><span class="line">    q[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例2-2-4-滑动窗口"><a href="#例2-2-4-滑动窗口" class="headerlink" title="例2.2.4 滑动窗口"></a>例2.2.4 滑动窗口</h4><p>给定一个大小为 $n≤10^6$ 的数组。</p>
<p>有一个大小为 $k$ 的滑动窗口，它从数组的最左边移动到最右边。</p>
<p>你只能在窗口中看到 $k$ 个数字。</p>
<p>每次滑动窗口向右移动一个位置。</p>
<p>以下是一个例子：</p>
<p>该数组为 <em>[1 3 -1 -3 5 3 6 7]</em>，$k$ 为 33。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">窗口位置</th>
<th style="text-align:left">最小值</th>
<th style="text-align:left">最大值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">[1 3 -1] -3 5 3 6 7</td>
<td style="text-align:left">-1</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left">1 [3 -1 -3] 5 3 6 7</td>
<td style="text-align:left">-3</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left">1 3 [-1 -3 5] 3 6 7</td>
<td style="text-align:left">-3</td>
<td style="text-align:left">5</td>
</tr>
<tr>
<td style="text-align:left">1 3 -1 [-3 5 3] 6 7</td>
<td style="text-align:left">-3</td>
<td style="text-align:left">5</td>
</tr>
<tr>
<td style="text-align:left">1 3 -1 -3 [5 3 6] 7</td>
<td style="text-align:left">3</td>
<td style="text-align:left">6</td>
</tr>
<tr>
<td style="text-align:left">1 3 -1 -3 5 [3 6 7]</td>
<td style="text-align:left">3</td>
<td style="text-align:left">7</td>
</tr>
</tbody>
</table>
</div>
<p>你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。</p>
<h5 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h5><p>输入包含两行。</p>
<p>第一行包含两个整数 $n$ 和 $k$，分别代表数组长度和滑动窗口的长度。</p>
<p>第二行有 $n$ 个整数，代表数组的具体数值。</p>
<p>同行数据之间用空格隔开。</p>
<h5 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出包含两个。</p>
<p>第一行输出，从左至右，每个位置滑动窗口中的最小值。</p>
<p>第二行输出，从左至右，每个位置滑动窗口中的最大值。</p>
<h5 id="输入样例：-5"><a href="#输入样例：-5" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 3</span><br><span class="line">1 3 -1 -3 5 3 6 7</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-5"><a href="#输出样例：-5" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1 -3 -3 -3 3 3</span><br><span class="line">3 3 5 5 6 7</span><br></pre></td></tr></table></figure>
<h2 id="2-3-kmp"><a href="#2-3-kmp" class="headerlink" title="2.3 kmp"></a>2.3 kmp</h2><h4 id="1-原理讲解-6"><a href="#1-原理讲解-6" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><p>首先，什么是KMP算法。这是一个字符串匹配算法，对暴力的那种一一比对的方法进行了优化，使时间复杂度大大降低。</p>
<p> 然后是一些基本概念：</p>
<ol>
<li><p>$s[ ]$是模式串，即比较长的字符串。</p>
</li>
<li><p>$p[ ]$​是模板串，即比较短的字符串。</p>
</li>
<li>“非平凡前缀”：指除了最后一个字符以外，一个字符串的全部头部组合。</li>
<li>“非平凡后缀”：指除了第一个字符以外，一个字符串的全部尾部组合。（后面会有例子，均简称为前/后缀）</li>
<li>“部分匹配值”：前缀和后缀的最长共有元素的长度。</li>
<li>$next[ ]$是“部分匹配值表”，即$next$数组，它存储的是每一个下标对应的“部分匹配值”，是KMP算法的核心。</li>
</ol>
<p>核心思想：在每次失配时，不是把$p$串往后移一位，而是把$p$串往后移动至下一次可以和前面部分匹配的位置，这样就可以跳过大多数的失配步骤。而每次$p$串移动的步数就是通过查找$next[ ]$数组确定的。</p>
<h4 id="2-模板讲解-6"><a href="#2-模板讲解-6" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span></span><br><span class="line">求模式串的Next数组：</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    <span class="keyword">if</span> (j == m)</span><br><span class="line">    &#123;</span><br><span class="line">        j = ne[j];</span><br><span class="line">        <span class="comment">// 匹配成功后的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="例2-3：KMP字符串"><a href="#例2-3：KMP字符串" class="headerlink" title="例2.3：KMP字符串"></a>例2.3：KMP字符串</h4><p>给定一个模式串 $S$，以及一个模板串 $P$，所有字符串中只包含大小写英文字母以及阿拉伯数字。</p>
<p>模板串 $P$ 在模式串 $S$ 中多次作为子串出现。</p>
<p>求出模板串 $P$ 在模式串 $S$ 中所有出现的位置的起始下标。</p>
<h5 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行输入整数 $N$，表示字符串 $P$ 的长度。</p>
<p>第二行输入字符串 $P$。</p>
<p>第三行输入整数 $M$，表示字符串 $S$ 的长度。</p>
<p>第四行输入字符串 $S$。</p>
<h5 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h5><p>共一行，输出所有出现位置的起始下标（下标从 $0$ 开始计数），整数之间用空格隔开。</p>
<h5 id="数据范围-4"><a href="#数据范围-4" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤N≤10^5$</p>
<p>$1≤M≤10^6$</p>
<h5 id="输入样例：-6"><a href="#输入样例：-6" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">aba</span><br><span class="line">5</span><br><span class="line">ababa</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-6"><a href="#输出样例：-6" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 2</span><br></pre></td></tr></table></figure>
<h2 id="2-4-Trie"><a href="#2-4-Trie" class="headerlink" title="2.4 Trie"></a>2.4 Trie</h2><h4 id="1-原理讲解-7"><a href="#1-原理讲解-7" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><p>Trie是一种高效存储和查询字符串集合的数据结构。</p>
<p>Trie树的基本性质可以归纳为：<br>（1）根节点不包含字符，除根节点意外每个节点只包含一个字符。</p>
<p>（2）从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。</p>
<p>（3）每个节点的所有子节点包含的字符串不相同。</p>
<p>（4）如果字符的种数为n，则每个结点的出度为n，这也是空间换时间的体现，浪费了很多的空间。</p>
<p>（5）插入查找的复杂度为O(n)，n为字符串长度。</p>
<p>Trie 的优点在于它的时间复杂度。它的插入和查询时间复杂度都为 O(k) ，其中 k 为 key 的长度，与 Trie 中保存了多少个元素无关；</p>
<p>Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。<br>Trie树的基本操作是插入和查询。</p>
<p>这里举一个例子：</p>
<p>比如在Trie树中存储这些单词：{abcdef, abdef, aced, bcdf, bcff, cdaa, bcdc}，操作步骤如下：</p>
<p>依次插入每个单词，对于每个单词，从单词开头遍历到单词结尾，如果某个字母Trie树中没有出现，则扩展出一条新的路径，继续插入剩余字母，最后在单词的末尾处加一，记录单词出现的次数。</p>
<p><img src="/2021/12/06/basicACML2/Trie.png" alt></p>
<h4 id="2-模板讲解-7"><a href="#2-模板讲解-7" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">// 0号点既是根节点，又是空节点</span></span><br><span class="line"><span class="comment">// son[][]存储树中每个节点的子节点</span></span><br><span class="line"><span class="comment">// cnt[]存储以每个节点结尾的单词数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询字符串出现的次数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="例2-4：Trie字符串统计"><a href="#例2-4：Trie字符串统计" class="headerlink" title="例2.4：Trie字符串统计"></a>例2.4：Trie字符串统计</h4><p>维护一个字符串集合，支持两种操作：</p>
<ol>
<li><em>I x</em> 向集合中插入一个字符串 $x$；</li>
<li><em>Q x</em> 询问一个字符串在集合中出现了多少次。</li>
</ol>
<p>共有 $N$ 个操作，输入的字符串总长度不超过 $10^5$，字符串仅包含小写英文字母。</p>
<h5 id="输入格式-6"><a href="#输入格式-6" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $N$，表示操作数。</p>
<p>接下来 $N$ 行，每行包含一个操作指令，指令为 <em>I x</em> 或 <em>Q x</em> 中的一种。</p>
<h5 id="输出格式-6"><a href="#输出格式-6" class="headerlink" title="输出格式"></a>输出格式</h5><p>对于每个询问指令 <em>Q x</em>，都要输出一个整数作为结果，表示 $x$ 在集合中出现的次数。</p>
<p>每个结果占一行。</p>
<h5 id="数据范围-5"><a href="#数据范围-5" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤N≤2∗10^4$</p>
<h5 id="输入样例：-7"><a href="#输入样例：-7" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">I abc</span><br><span class="line">Q abc</span><br><span class="line">Q ab</span><br><span class="line">I ab</span><br><span class="line">Q ab</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-7"><a href="#输出样例：-7" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h5 id="AC代码-4"><a href="#AC代码-4" class="headerlink" title="AC代码"></a>AC代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> s[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][u] == <span class="number">0</span>)</span><br><span class="line">            son[p][u] = ++ idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> s[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][u] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt[p]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> op;</span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">            <span class="built_in">insert</span>(s);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">query</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-5-并查集"><a href="#2-5-并查集" class="headerlink" title="2.5 并查集"></a>2.5 并查集</h2><h4 id="1-原理讲解-8"><a href="#1-原理讲解-8" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><ol>
<li>将两个集合合并</li>
<li>询问两个元素是否在一个集合中</li>
</ol>
<p>基本原理：每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个节点存它的父节点，$p[x]$表示$x$的父节点</p>
<p>问题1：如何判断树根：<em>if(p[x] == x)</em></p>
<p>问题2：如何求$x$的集合编号：<em>while(p[x] != x) x = p[x];</em></p>
<p>问题3：如何合并两个集合：$px$是$x$的集合编号，$py$是$y$的集合编号。$p[x]=y$</p>
<h4 id="2-模板讲解-8"><a href="#2-模板讲解-8" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)朴素并查集：</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p[N]; <span class="comment">//存储每个点的祖宗节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回x的祖宗节点</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)*维护size的并查集：</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p[N], size[N];</span><br><span class="line">    <span class="comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回x的祖宗节点</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        size[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">    size[<span class="built_in">find</span>(b)] += size[<span class="built_in">find</span>(a)];</span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)*维护到祖宗节点距离的并查集：</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p[N], d[N];</span><br><span class="line">    <span class="comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回x的祖宗节点</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = <span class="built_in">find</span>(p[x]);</span><br><span class="line">            d[x] += d[p[x]];</span><br><span class="line">            p[x] = u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        d[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">    d[<span class="built_in">find</span>(a)] = distance; <span class="comment">// 根据具体问题，初始化find(a)的偏移量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="例2-5-1：合并集合"><a href="#例2-5-1：合并集合" class="headerlink" title="例2.5.1：合并集合"></a>例2.5.1：合并集合</h4><p>一共有 $n$ 个数，编号是 $1∼n$，最开始每个数各自在一个集合中。</p>
<p>现在要进行 $m$ 个操作，操作共有两种：</p>
<ol>
<li><em>M a b</em>，将编号为 $a$ 和 $b$ 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；</li>
<li><em>Q a b</em>，询问编号为 $a$ 和 $b$ 的两个数是否在同一个集合中；</li>
</ol>
<h5 id="输入格式-7"><a href="#输入格式-7" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行输入整数 $n$ 和 $m$。</p>
<p>接下来 $m$ 行，每行包含一个操作指令，指令为 <em>M a b</em> 或 <em>Q a b</em> 中的一种。</p>
<h5 id="输出格式-7"><a href="#输出格式-7" class="headerlink" title="输出格式"></a>输出格式</h5><p>对于每个询问指令 <em>Q a b</em>，都要输出一个结果，如果 aa 和 bb 在同一集合内，则输出 <em>Yes</em>，否则输出 <em>No</em>。</p>
<p>每个结果占一行。</p>
<h5 id="数据范围-6"><a href="#数据范围-6" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n,m≤10^5$</p>
<h5 id="输入样例：-8"><a href="#输入样例：-8" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">M 1 2</span><br><span class="line">M 3 4</span><br><span class="line">Q 1 2</span><br><span class="line">Q 1 3</span><br><span class="line">Q 3 4</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-8"><a href="#输出样例：-8" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure>
<h4 id="例2-5-2：-数组元素的目标和"><a href="#例2-5-2：-数组元素的目标和" class="headerlink" title="例2.5.2：*数组元素的目标和"></a>例2.5.2：*数组元素的目标和</h4><p>给定一个包含 $n$ 个点（编号为 $1∼n$）的无向图，初始时图中没有边。</p>
<p>现在要进行 $m$ 个操作，操作共有三种：</p>
<ol>
<li><em>C a b</em>，在点 $a$ 和点 $b$ 之间连一条边，$a$ 和 $b$ 可能相等；</li>
<li><em>Q1 a b</em>，询问点 $a$ 和点 $b$ 是否在同一个连通块中，$a$ 和 $b$ 可能相等；</li>
<li><em>Q2 a</em>，询问点 $a$ 所在连通块中点的数量；</li>
</ol>
<h5 id="输入格式-8"><a href="#输入格式-8" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行输入整数 $n$ 和 $m$。</p>
<p>接下来 $m$ 行，每行包含一个操作指令，指令为 <em>C a b</em>，<em>Q1 a b</em> 或 <em>Q2 a</em> 中的一种。</p>
<h5 id="输出格式-8"><a href="#输出格式-8" class="headerlink" title="输出格式"></a>输出格式</h5><p>对于每个询问指令 <em>Q1 a b</em>，如果 aa 和 bb 在同一个连通块中，则输出 <em>Yes</em>，否则输出 <em>No</em>。</p>
<p>对于每个询问指令 <em>Q2 a</em>，输出一个整数表示点 aa 所在连通块中点的数量</p>
<p>每个结果占一行。</p>
<h5 id="数据范围-7"><a href="#数据范围-7" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n,m≤10^5$</p>
<h5 id="输入样例：-9"><a href="#输入样例：-9" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">C 1 2</span><br><span class="line">Q1 1 2</span><br><span class="line">Q2 1</span><br><span class="line">C 2 5</span><br><span class="line">Q2 5</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-9"><a href="#输出样例：-9" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h2 id="2-6-堆"><a href="#2-6-堆" class="headerlink" title="2.6 堆"></a>2.6 堆</h2><h4 id="1-原理讲解-9"><a href="#1-原理讲解-9" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><p>堆(heap)是一种特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。<br>堆的性质：<br>1.堆中某个节点的值总是不大于或不小于其父节点的值。<br>2.堆总是一棵完全二叉树。</p>
<p>将根节点最大的堆叫做最大堆或大顶堆，根节点最小的堆叫做最小堆或小顶堆。</p>
<p>在堆中，如果一个结点的位置为k，则它的父结点的位置为[k/2],而它的两个子结点的位置则分别为2k和2k+1。</p>
<p>堆的基本操作有：插入一个数、求集合中的最小值、删除最小值、删除任意一个元素、修改任意一个元素。这些操作都可由两个函数up和down来实现。</p>
<p>下面分别来看up和down两个函数的具体操作：</p>
<p><img src="/2021/12/06/basicACML2/heap.png" alt></p>
<h4 id="2-模板讲解-9"><a href="#2-模板讲解-9" class="headerlink" title="2.模板讲解"></a>2.模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的位置</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的</span></span><br><span class="line"><span class="keyword">int</span> h[N], ph[N], hp[N], size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个点，及其映射关系</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i; i -- ) <span class="built_in">down</span>(i);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="例2-6-1：堆排序"><a href="#例2-6-1：堆排序" class="headerlink" title="例2.6.1：堆排序"></a>例2.6.1：堆排序</h4><p>输入一个长度为 $n$ 的整数数列，从小到大输出前 $m$ 小的数。</p>
<h5 id="输入格式-9"><a href="#输入格式-9" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $n$ 和 $m$。</p>
<p>第二行包含 $n$ 个整数，表示整数数列。</p>
<h5 id="输出格式-9"><a href="#输出格式-9" class="headerlink" title="输出格式"></a>输出格式</h5><p>共一行，包含 $m$ 个整数，表示整数数列中前 $m$ 小的数。</p>
<h5 id="数据范围-8"><a href="#数据范围-8" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤m≤n≤10^5$，</p>
<p>$1≤$数列中元素$≤10^9$</p>
<h5 id="输入样例：-10"><a href="#输入样例：-10" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">4 5 1 3 2</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-10"><a href="#输出样例：-10" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br></pre></td></tr></table></figure>
<h5 id="AC代码-5"><a href="#AC代码-5" class="headerlink" title="AC代码"></a>AC代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> sizeh, heap[N];   <span class="comment">//sizeh存储堆中的元素个数，heap存储堆中的元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> x)</span>      <span class="comment">//向下维护堆</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = x;        <span class="comment">//为了不修改x的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * x &lt;= sizeh &amp;&amp; heap[<span class="number">2</span> * x] &lt; heap[t]) <span class="comment">//经过这两个if的比较，就可以得出三者之间最小者的下标了</span></span><br><span class="line">        t = <span class="number">2</span> * x;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * x + <span class="number">1</span> &lt;= sizeh &amp;&amp; heap[<span class="number">2</span> * x + <span class="number">1</span>] &lt; heap[t])</span><br><span class="line">        t = <span class="number">2</span> * x + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(t != x)              <span class="comment">//如果两者不相等，则说明有一个子节点大于父节点，就交换两者的值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(heap[t], heap[x]);    <span class="comment">//交换两者的值</span></span><br><span class="line">        <span class="built_in">down</span>(t);                   <span class="comment">//从子结点开始向下维护</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    sizeh = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)  <span class="comment">//输入初始值</span></span><br><span class="line">        cin &gt;&gt; heap[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i --)  <span class="comment">//O(n)建堆</span></span><br><span class="line">        <span class="built_in">down</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,heap[<span class="number">1</span>]);</span><br><span class="line">        heap[<span class="number">1</span>] = heap[sizeh];    <span class="comment">//将最后一个节点的值覆盖根节点的值</span></span><br><span class="line">        sizeh --;                 <span class="comment">//删除最后一个节点(相当于删除了原来的根节点)</span></span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>);                  <span class="comment">//从根节点开始向下维护</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-7-Hash表"><a href="#2-7-Hash表" class="headerlink" title="2.7 Hash表"></a>2.7 Hash表</h2><h3 id="2-7-1-一般哈希"><a href="#2-7-1-一般哈希" class="headerlink" title="2.7.1 一般哈希"></a>2.7.1 一般哈希</h3><h4 id="1-原理讲解-10"><a href="#1-原理讲解-10" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><p>Hash表又称为散列表,一般由Hash函数(散列函数)与链表结构共同实现。与离散化思想类似，当我们要对若干复杂信息进行统计时,可以用Hash函数把这些复杂信息映射到一个容易维护的值域内。因为值域变简单、范围变小,有可能造成两个不同的原始信息被Hash函数映射为相同的值,所有我们需要处理这种冲突情况。</p>
<p>有一种称为“开散列”的解决方案是,建立一个邻接表结构,以Hash函数的值域作为表头数组head,映射后的值相同的原始信息被分到同一类,构成一个链表接在对应的表头之后,链表的节点上可以保存原始信息和一-些统计数据。</p>
<p>Hash表主要包括来两个基本操作：</p>
<ol>
<li><p>计算Hash函数的值。</p>
</li>
<li><p>定位到对应链表中依次遍历、比较。</p>
</li>
</ol>
<p>无论是检查任意一个给定的原始信息在Hash表中是否存在,还是更新它在Hash表中的统计数据,都需要基于这两个基本操作进行。</p>
<p>当Hash函数设计较好时,原始信息会被比较均匀地分配到各个表头之后,从而使每次查找,统计的时间降低到”原始信息总数除以表头数组长度”。若原始信息总数与表头数组长度都是$O(N)$级别且Hash函数分散均匀,几乎不产生冲突,那么每次查找,统计的时间复杂度期望为$O(1)$​。</p>
<p>例如,我们要在一个长度为$N$​的随机整数序列$A$​中统计每个数出现了多少次。当数列A中的值都比较小时，我们可以直接用一个数组计数(建立一个大小等于值域的数组进行统计和映射,其实就是最简单的Hash思想)。当数列A中的值很大时,我们可以把$A$排序后扫描统计。这里我们换一 个思路, 尝试一下Hash表的做法。</p>
<p>设计Hash函数为$H(x)=(x \mod P)+1$,其中$P$是一个比较大的质数, 但不超过$N$。显然这个Hash函数把数列$A$分成$P$类，我们可以依次考虑数列中的每个数$A[i]$,定位到$head[H(A[i])]$这个表头所指向的链表。如果该链表中不包含$A[i]$，我们就在表头后插入一个新节点$A[i]$, 并在该节点上记录$A[i]$出现了$1$次,否则我们就在直接找到已经存在的$A[i]$节，点将其出现次数$+1$。因为整数序列$A$是随机的， 所以最终所有的$A[]$会比较均匀地分散在各个表头之后,整个算法的时间复杂度可以近似达到$O(N)$。</p>
<p>上面的例子是一个非常简单的Hash表的直观应用。 对于非随机的数列,我们可以设计更好的Hash函数来保证其时间复杂度。同样的,如果我们需要维护的是比大整数复杂得多得信息的某些特性(如是否存在,出现次数等),也可以用Hash表来解决。字符串就是一种比较一般化的信息, 在本节的后半部分,我们将会介绍一个程序设计竞赛中极其常用的字符串Hash算法。</p>
<h4 id="2-模板讲解-10"><a href="#2-模板讲解-10" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>) 拉链法</span><br><span class="line">    <span class="keyword">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向哈希表中插入一个数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = (x % N + N) % N;</span><br><span class="line">        e[idx] = x;</span><br><span class="line">        ne[idx] = h[k];</span><br><span class="line">        h[k] = idx ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在哈希表中查询某个数是否存在</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = (x % N + N) % N;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">            <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) 开放寻址法</span><br><span class="line">    <span class="keyword">int</span> h[N];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = (x % N + N) % N;</span><br><span class="line">        <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">        &#123;</span><br><span class="line">            t ++ ;</span><br><span class="line">            <span class="keyword">if</span> (t == N) t = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="例2-7-1：-模拟散列表"><a href="#例2-7-1：-模拟散列表" class="headerlink" title="例2.7.1： 模拟散列表"></a>例2.7.1： 模拟散列表</h4><p>维护一个集合，支持如下几种操作：</p>
<ol>
<li><em>I x</em>，插入一个数 $x$；</li>
<li><em>Q x</em>，询问数 $x$ 是否在集合中出现过；</li>
</ol>
<p>现在要进行 $N$ 次操作，对于每个询问操作输出对应的结果。</p>
<h5 id="输入格式-10"><a href="#输入格式-10" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $N$，表示操作数量。</p>
<p>接下来 $N$ 行，每行包含一个操作指令，操作指令为 <em>I x</em>，<em>Q x</em> 中的一种。</p>
<h5 id="输出格式-10"><a href="#输出格式-10" class="headerlink" title="输出格式"></a>输出格式</h5><p>对于每个询问指令 <em>Q x</em>，输出一个询问结果，如果 $x$ 在集合中出现过，则输出 <em>Yes</em>，否则输出 <em>No</em>。</p>
<p>每个结果占一行。</p>
<h5 id="数据范围-9"><a href="#数据范围-9" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤N≤10^5$</p>
<p>$−10^9≤x≤10^9$</p>
<h5 id="输入样例：-11"><a href="#输入样例：-11" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">I 1</span><br><span class="line">I 2</span><br><span class="line">I 3</span><br><span class="line">Q 2</span><br><span class="line">Q 5</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-11"><a href="#输出样例：-11" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure>
<h3 id="2-7-2-字符串哈希"><a href="#2-7-2-字符串哈希" class="headerlink" title="2.7.2 字符串哈希"></a>2.7.2 字符串哈希</h3><h4 id="1-原理讲解-11"><a href="#1-原理讲解-11" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><p>核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低</p>
<p>小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果</p>
<h4 id="2-模板讲解-11"><a href="#2-模板讲解-11" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line">ULL h[N], p[N]; <span class="comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算子串 str[l ~ r] 的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="例2-7-2：字符串哈希"><a href="#例2-7-2：字符串哈希" class="headerlink" title="例2.7.2：字符串哈希"></a>例2.7.2：字符串哈希</h4><p>给定一个长度为 $n$ 的字符串，再给定 $m$ 个询问，每个询问包含四个整数 $l_1,r_1,l_2,r_2$，请你判断 $[l_1,r_1]$ 和 $[l_2,r_2]$ 这两个区间所包含的字符串子串是否完全相同。</p>
<p>字符串中只包含大小写英文字母和数字。</p>
<h5 id="输入格式-11"><a href="#输入格式-11" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $n$ 和 $m$，表示字符串长度和询问次数。</p>
<p>第二行包含一个长度为 $n$ 的字符串，字符串中只包含大小写英文字母和数字。</p>
<p>接下来 $m$ 行，每行包含四个整数 $l_1,r_1,l_2,r_2$，表示一次询问所涉及的两个区间。</p>
<p>注意，字符串的位置从 $1$ 开始编号。</p>
<h5 id="输出格式-11"><a href="#输出格式-11" class="headerlink" title="输出格式"></a>输出格式</h5><p>对于每个询问输出一个结果，如果两个字符串子串完全相同则输出 <em>Yes</em>，否则输出 <em>No</em>。</p>
<p>每个结果占一行。</p>
<h5 id="数据范围-10"><a href="#数据范围-10" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n,m≤10^5$</p>
<h5 id="输入样例：-12"><a href="#输入样例：-12" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 3</span><br><span class="line">aabbaabb</span><br><span class="line">1 3 5 7</span><br><span class="line">1 3 6 8</span><br><span class="line">1 2 1 2</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-12"><a href="#输出样例：-12" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>npuCS 第四讲 数学知识</title>
    <url>/2022/01/08/basicACML4/</url>
    <content><![CDATA[<h1 id="第四讲-数学知识"><a href="#第四讲-数学知识" class="headerlink" title="第四讲 数学知识"></a>第四讲 数学知识</h1><h2 id="4-1-质数"><a href="#4-1-质数" class="headerlink" title="4.1 质数"></a>4.1 质数</h2><h3 id="4-1-1-试除法判定质数"><a href="#4-1-1-试除法判定质数" class="headerlink" title="4.1.1 试除法判定质数"></a>4.1.1 试除法判定质数</h3><h4 id="1-原理讲解"><a href="#1-原理讲解" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><p>素数定义：因数只有1与本身的数</p>
<p>从定义出发，若 $a$​ 为素数，则2~$a-1$​均非其因数，即不能除尽，余数不为零<br>思路是正确的，但是，能不能优化呢？</p>
<p>我们发现，一个数可以表示成</p>
<script type="math/tex; mode=display">
a=i×j</script><p>若$i=j$,则</p>
<script type="math/tex; mode=display">
a=i^2</script><p>若 $i&gt;j$，则</p>
<script type="math/tex; mode=display">
a<i^2</script><p>于是，可以总结为</p>
<script type="math/tex; mode=display">
a≤i^2</script><p>判定范围变成了·</p>
<script type="math/tex; mode=display">
2≤i≤a/i</script><h4 id="2-模板讲解"><a href="#2-模板讲解" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例4-1-1：试除法判定质数"><a href="#例4-1-1：试除法判定质数" class="headerlink" title="例4.1.1：试除法判定质数"></a>例4.1.1：试除法判定质数</h4><p>给定 $n$ 个正整数 $a_i$，判定每个数是否是质数。</p>
<h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $n$。</p>
<p>接下来 $n$ 行，每行包含一个正整数 $a_i$。</p>
<h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>共 $n$ 行，其中第 $i$ 行输出第 $i$ 个正整数 $a_i$ 是否为质数，是则输出 <em>Yes</em>，否则输出 <em>No</em>。</p>
<h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5><script type="math/tex; mode=display">
1≤n≤100;</script><script type="math/tex; mode=display">
1≤a_i≤2^{31}−1;</script><h5 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<h5 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure>
<h3 id="4-1-2-试除法分解质因数"><a href="#4-1-2-试除法分解质因数" class="headerlink" title="4.1.2 试除法分解质因数"></a>4.1.2 试除法分解质因数</h3><h4 id="1-知识讲解"><a href="#1-知识讲解" class="headerlink" title="1. 知识讲解"></a>1. 知识讲解</h4><p>由4.1.1我们知道如何判定素数，现在我们由小及大地求其所有质因数及其指数<br>可以方便的想到，先由小及大地判断其因数，除去后再求商的质因数，由于非质因数可以分解成较小的质因数，而这在之前及时除尽了，故找到的因数都是质因数</p>
<h4 id="2-模板讲解-1"><a href="#2-模板讲解-1" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i, s ++ ;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例4-1-2：分解质因数"><a href="#例4-1-2：分解质因数" class="headerlink" title="例4.1.2：分解质因数"></a>例4.1.2：分解质因数</h4><p>给定 $n$ 个正整数 $a_i$，将每个数分解质因数，并按照质因数从小到大的顺序输出每个质因数的底数和指数。</p>
<h5 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $n$。</p>
<p>接下来 $n$ 行，每行包含一个正整数 $a_i$。</p>
<h5 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h5><p>对于每个正整数 $a_i$，按照从小到大的顺序输出其分解质因数后，每个质因数的底数和指数，每个底数和指数占一行。</p>
<p>每个正整数的质因数全部输出完毕后，输出一个空行。</p>
<h5 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h5><script type="math/tex; mode=display">
1≤n≤100</script><script type="math/tex; mode=display">
1≤a_i≤2×10^9</script><h5 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">6</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 1</span><br><span class="line">3 1</span><br><span class="line"></span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>
<h3 id="4-1-3-朴素筛法求素数"><a href="#4-1-3-朴素筛法求素数" class="headerlink" title="4.1.3 朴素筛法求素数"></a>4.1.3 朴素筛法求素数</h3><h4 id="1-知识讲解-1"><a href="#1-知识讲解-1" class="headerlink" title="1. 知识讲解"></a>1. 知识讲解</h4><p>我们之前求素数，是直接对所有数进行一次判断</p>
<p>事实上，对于从 1~ $n$​​ 的自然数列，我们不能先判断哪些数是，却可以先判断哪些数不是</p>
<p>这种不断筛去非理想的数，最后得到理想数集的思想就是筛法</p>
<p>对于基数 $a$ ,它是否是素数不确定，但是 2$a$ ，3$a$….k$a$​一定不是素数</p>
<p>基于这个思想，我们可以由小及大地排除掉一些数</p>
<p>当基数足够大时，自然数列中就只剩下素数了，这就是朴素筛法</p>
<h4 id="2-模板讲解-2"><a href="#2-模板讲解-2" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>;</span><br><span class="line">        primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= n; j += i)</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例4-1-3-筛质数"><a href="#例4-1-3-筛质数" class="headerlink" title="例4.1.3 筛质数"></a>例4.1.3 筛质数</h4><p>给定一个正整数 $n$，请你求出 $1∼n$ 中质数的个数。</p>
<h5 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h5><p>共一行，包含整数 $n$。</p>
<h5 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h5><p>共一行，包含一个整数，表示 $1∼n$ 中质数的个数。</p>
<h5 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n≤10^6$</p>
<h5 id="输入样例：-2"><a href="#输入样例：-2" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h5 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1000010;int primes[N], cnt;</span><br><span class="line">bool st[N];</span><br><span class="line"></span><br><span class="line">void get_primes(int n)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 2; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!st[i]) primes[cnt++] = i;</span><br><span class="line">        for(int j = 0; primes[j] &lt;= n / i; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j]*i] = true;</span><br><span class="line">            if(i % primes[j] == 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    get_primes(n);</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-4-线性筛法求素数"><a href="#4-1-4-线性筛法求素数" class="headerlink" title="4.1.4 线性筛法求素数"></a>4.1.4 线性筛法求素数</h3><h4 id="1-知识讲解-2"><a href="#1-知识讲解-2" class="headerlink" title="1. 知识讲解"></a>1. 知识讲解</h4><p>在4.1.3里，我们初步了解了筛法的原理</p>
<p>朴素筛法很好，但是我们不妨问问自己，这就够了吗？</p>
<p>仔细研究下朴素筛法，我们发现，有的数被筛过不止一次</p>
<p>例如36，可以被2，3先后筛去，造成了资源的浪费</p>
<p>仔细研究发现，我们发现要筛去一个合数，可以只通过其最小质因数筛去<br>例如</p>
<script type="math/tex; mode=display">
a_j=i×p[j]</script><p>其中 $i$ 是循环数，$p[j]$ 是自前而后第 $j$ 个素数，且 $i&gt;p[j]$，$a&lt;N$</p>
<p>若 $i ％ p[j]≠ 0$，则 $p[j]$ 是 $a_j$ 的最小素数因子， $a_j$ 可以被 $p[j]$ 筛去，此时 $j++$<br>再筛去下一个数</p>
<p>若 $i ％ p[j]=0$，则 $p[j]$ 是$i$ 的最小素数因子，数 $i$ 可以被 $p[j]$ 筛去</p>
<p>那么所有的数 $a_j$ 自然也能被 $p[j]$ 筛去，即使数 $a$ 也能被 $p[j+1]$ 筛去，避免了重复计算，所以此时$i++$进入下一轮筛去</p>
<h4 id="2-模板讲解-3"><a href="#2-模板讲解-3" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例4-1-4：筛质数"><a href="#例4-1-4：筛质数" class="headerlink" title="例4.1.4：筛质数"></a>例4.1.4：筛质数</h4><p>给定一个正整数 $n$，请你求出 ${1∼n}$ 中质数的个数。</p>
<h5 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h5><p>共一行，包含整数 $n$。</p>
<h5 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h5><p>共一行，包含一个整数，表示 ${1∼n}$ 中质数的个数。</p>
<h5 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h5><p>${1≤n≤10^6}$</p>
<h5 id="输入样例：-3"><a href="#输入样例：-3" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-3"><a href="#输出样例：-3" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="4-2-约数"><a href="#4-2-约数" class="headerlink" title="4.2 约数"></a>4.2 约数</h2><h3 id="4-2-1-试除法求所有约数"><a href="#4-2-1-试除法求所有约数" class="headerlink" title="4.2.1 试除法求所有约数"></a>4.2.1 试除法求所有约数</h3><h4 id="1-知识讲解-3"><a href="#1-知识讲解-3" class="headerlink" title="1. 知识讲解"></a>1. 知识讲解</h4><p>采用遍历法，于是有</p>
<script type="math/tex; mode=display">
a_i=i × (a_i/i)</script><p>若 $a_i%i$ % $i$=0,则记录下 $i$ 与 $a_i$ ；若 $a_i=i^2$,记录下 $i$ 即可</p>
<h4 id="2-模板讲解-4"><a href="#2-模板讲解-4" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i != x / i) res.<span class="built_in">push_back</span>(x / i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例4-2-1：试除法求约数"><a href="#例4-2-1：试除法求约数" class="headerlink" title="例4.2.1：试除法求约数"></a>例4.2.1：试除法求约数</h4><p>给定 $n$ 个正整数 $a_i$，对于每个整数 $a_i$，请你按照从小到大的顺序输出它的所有约数。</p>
<h5 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $n$。</p>
<p>接下来 $n$ 行，每行包含一个整数 $a_i$。</p>
<h5 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出共 $n$ 行，其中第 $i$ 行输出第 $i$ 个整数 $a_i$ 的所有约数。</p>
<h5 id="数据范围-4"><a href="#数据范围-4" class="headerlink" title="数据范围"></a>数据范围</h5><script type="math/tex; mode=display">
1≤n≤100,</script><script type="math/tex; mode=display">
2≤a_i≤2×10^9</script><h5 id="输入样例：-4"><a href="#输入样例：-4" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">6</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-4"><a href="#输出样例：-4" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 6 </span><br><span class="line">1 2 4 8</span><br></pre></td></tr></table></figure>
<h5 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int k;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    while(k--)</span><br><span class="line">    &#123;</span><br><span class="line">        int n;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        vector&lt;int&gt; a;</span><br><span class="line">        for(int i=1;i&lt;=n/i;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(n%i==0)</span><br><span class="line">            &#123;</span><br><span class="line">            a.push_back(i);        </span><br><span class="line">            if(i!=n/i) a.push_back(n/i);</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        sort(a.begin(),a.end());</span><br><span class="line">        for(auto t:a) cout&lt;&lt;t&lt;&lt;&quot; &quot;;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">return 0;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-2-约数个数和约数之和"><a href="#4-2-2-约数个数和约数之和" class="headerlink" title="4.2.2 约数个数和约数之和"></a>4.2.2 约数个数和约数之和</h3><h4 id="1-知识讲解-4"><a href="#1-知识讲解-4" class="headerlink" title="1. 知识讲解"></a>1. 知识讲解</h4><h4 id="2-模板讲解-5"><a href="#2-模板讲解-5" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">如果 N = p1^c1 * p2^c2 * ... *pk^ck</span><br><span class="line">约数个数： (c1 + <span class="number">1</span>) * (c2 + <span class="number">1</span>) * ... * (ck + <span class="number">1</span>)</span><br><span class="line">约数之和： (p1^<span class="number">0</span> + p1^<span class="number">1</span> + ... + p1^c1) * ... * (pk^<span class="number">0</span> + pk^<span class="number">1</span> + ... + pk^ck)</span><br></pre></td></tr></table></figure>
<h4 id="例4-2-2-1-约数个数"><a href="#例4-2-2-1-约数个数" class="headerlink" title="例4.2.2.1 约数个数"></a>例4.2.2.1 约数个数</h4><p>给定 $n$ 个正整数 $a_i$，请你输出这些数的乘积的约数个数，答案对10^9+7取模</p>
<h5 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $n$。</p>
<p>接下来 $n$ 行，每行包含一个整数 $a_i$。</p>
<h5 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出一个整数，表示所给正整数的乘积的约数个数，答案需对 $10^9+7$ 取模。</p>
<h5 id="数据范围-5"><a href="#数据范围-5" class="headerlink" title="数据范围"></a>数据范围</h5><script type="math/tex; mode=display">
1≤n≤100,</script><script type="math/tex; mode=display">
1≤a_i≤2×10^9</script><h5 id="输入样例：-5"><a href="#输入样例：-5" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">6</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-5"><a href="#输出样例：-5" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure>
<h4 id="例4-2-2-2：约数之和"><a href="#例4-2-2-2：约数之和" class="headerlink" title="例4.2.2.2：约数之和"></a>例4.2.2.2：约数之和</h4><p>给定 $n$ 个正整数 $a_i$，请你输出这些数的乘积的约数之和，答案对 $10^9+7$ 取模。</p>
<h5 id="输入格式-6"><a href="#输入格式-6" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $n$。</p>
<p>接下来 $n$ 行，每行包含一个整数 $a_i$。</p>
<h5 id="输出格式-6"><a href="#输出格式-6" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出一个整数，表示所给正整数的乘积的约数之和，答案需对 $10^9$+7$ 取模。</p>
<h5 id="数据范围-6"><a href="#数据范围-6" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n≤100$,</p>
<p>$1≤a_i≤2×10^9$</p>
<h5 id="输入样例：-6"><a href="#输入样例：-6" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">6</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-6"><a href="#输出样例：-6" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">252</span><br></pre></td></tr></table></figure>
<h2 id="4-3-欧拉函数"><a href="#4-3-欧拉函数" class="headerlink" title="4.3 欧拉函数"></a>4.3 欧拉函数</h2><h3 id="4-3-1-欧几里得算法"><a href="#4-3-1-欧几里得算法" class="headerlink" title="4.3.1 欧几里得算法"></a>4.3.1 欧几里得算法</h3><h4 id="1-知识讲解-5"><a href="#1-知识讲解-5" class="headerlink" title="1. 知识讲解"></a>1. 知识讲解</h4><p>辗转相除法， 又名欧几里德算法（Euclidean algorithm），是求最大公约数的一种方法。它的具体做法是：用较大数除以较小数，再用出现的余数（第一余数）去除除数，再用出现的余数（第二余数）去除第一余数，如此反复，直到最后余数是$0$为止。如果是求两个数的最大公约数，那么最后的除数就是这两个数的最大公约数。</p>
<p>另一种求两数的最大公约数的方法是更相减损法。</p>
<p>辗转相除法举例：</p>
<p>求 $10$ ，$25$的最大公约数：</p>
<p>$25 / 10 = 2 ······5$</p>
<p>$10 / 5   = 2 ······0$</p>
<p>所以$10$，$25$的最大公约数为$5$</p>
<p>优点</p>
<ol>
<li><p><em>gcd</em>函数的递归层数不会超过$4.785\lg N + 1.6723$, 其中$N == \max\{ a，b \}$，所以不会导致栈溢出。</p>
</li>
<li><p><em>gcd</em>函数不仅可以求解$(a, b)$的最大公约数，还可以求解小公倍数，$lcm(a, b)$ 代表$(a, b)$的最小公倍数</p>
<p>那么有 $lcm(a, b) * gcd(a, b) = a * b$​<br>所以：$lcm(a,b) = a * b / gcd(a, b)$ 但是最好写成：$lcm(a,b) = a  / gcd(a, b) * b$  这样一定程度可以避免 $a * b$ 爆<em>long long</em> .</p>
</li>
</ol>
<h4 id="2-模板讲解-6"><a href="#2-模板讲解-6" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例4-3-1：最大公约数"><a href="#例4-3-1：最大公约数" class="headerlink" title="例4.3.1：最大公约数"></a>例4.3.1：最大公约数</h4><p>给定 $n$ 对正整数 $a_i,b_i$，请你求出每对数的最大公约数。</p>
<h5 id="输入格式-7"><a href="#输入格式-7" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $n$。</p>
<p>接下来 $n$ 行，每行包含一个整数对 $a_i,b_i$。</p>
<h5 id="输出格式-7"><a href="#输出格式-7" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出共 $n$ 行，每行输出一个整数对的最大公约数。</p>
<h5 id="数据范围-7"><a href="#数据范围-7" class="headerlink" title="数据范围"></a>数据范围</h5><p>${1≤n≤10^5}$,</p>
<p>${1≤a_i,b_i≤2×10^9}$</p>
<h5 id="输入样例：-7"><a href="#输入样例：-7" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3 6</span><br><span class="line">4 6</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-7"><a href="#输出样例：-7" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h5 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int gcd(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123; </span><br><span class="line">int n,a,b,c;</span><br><span class="line">scanf(&quot;%d&quot;,n);</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;a,&amp;b);</span><br><span class="line">c=gdc(a,b);</span><br><span class="line">printf(&quot;%d\n&quot;,c);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-2-求欧拉函数"><a href="#4-3-2-求欧拉函数" class="headerlink" title="4.3.2 求欧拉函数"></a>4.3.2 求欧拉函数</h3><h4 id="1-知识讲解-6"><a href="#1-知识讲解-6" class="headerlink" title="1. 知识讲解"></a>1. 知识讲解</h4><p>欧拉函数的定义：</p>
<p>$1∼N$ 中与 $N$ 互质的数的个数被称为欧拉函数，记为 $ϕ(N)$。</p>
<p>若在算数基本定理中，$N=p^{a1}_1p^{a2}_2…p^{a_m}_m$​，则：$ϕ(N) = N×\frac{p_1−1}{p_1}×\frac{p_2−1}{p_2}×…×\frac{p_m−1}{p_m}$​<br>其中$p(1),p(2)…p(n)$为$x$的所有质因数;x是正整数; $\phi (1)=1$(唯一和$1$互质的数，且小于等于1)。注意：每种质因数只有一个。</p>
<h4 id="2-模板讲解-7"><a href="#2-模板讲解-7" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例4-3-2：欧拉函数"><a href="#例4-3-2：欧拉函数" class="headerlink" title="例4.3.2：欧拉函数"></a>例4.3.2：欧拉函数</h4><p>给定 $n$ 个正整数 $a_i$，请你求出每个数的欧拉函数。</p>
<p>欧拉函数的定义：</p>
<p>$1∼N$ 中与 $N$ 互质的数的个数被称为欧拉函数，记为 $ϕ(N)$。</p>
<p>若在算数基本定理中，$N=p^{a1}_1p^{a2}_2…p^{a_m}_m$，则：$ϕ(N) = N×\frac{p_1−1}{p_1}×\frac{p_2−1}{p_2}×…×\frac{p_m−1}{p_m}$</p>
<h5 id="输入格式-8"><a href="#输入格式-8" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $n$。</p>
<p>接下来 $n$ 行，每行包含一个正整数 $a_i$。</p>
<h5 id="输出格式-8"><a href="#输出格式-8" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出共 $n$ 行，每行输出一个正整数 $a_i$ 的欧拉函数。</p>
<h5 id="数据范围-8"><a href="#数据范围-8" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n≤100$,</p>
<p>$1≤a_i≤2×10^9$</p>
<h5 id="输入样例：-8"><a href="#输入样例：-8" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-8"><a href="#输出样例：-8" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h5 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"> #include&lt;math.h&gt;</span><br><span class="line">  int eular(int n)</span><br><span class="line"> &#123;</span><br><span class="line">      int res=n;</span><br><span class="line">   for(int i=2;i&lt;=sqrt(n);i++)//判断n是否为质数</span><br><span class="line">      &#123;</span><br><span class="line">          if(n%i==0)res=res/i*(i-1);//res=res*(1-1/i)先进行除法防止溢出 </span><br><span class="line">          while(n%i==0)n/=i;</span><br><span class="line">     &#125;</span><br><span class="line">     if(n&gt;1)res=res/n*(n-1);</span><br><span class="line">     return res;</span><br><span class="line"> &#125;</span><br><span class="line">14 int main() </span><br><span class="line">&#123;</span><br><span class="line">     int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    printf(&quot;%d&quot;,eular(n));</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-3-筛法求欧拉函数"><a href="#4-3-3-筛法求欧拉函数" class="headerlink" title="4.3.3 筛法求欧拉函数"></a>4.3.3 筛法求欧拉函数</h3><h4 id="1-知识讲解-7"><a href="#1-知识讲解-7" class="headerlink" title="1. 知识讲解"></a>1. 知识讲解</h4><p>用到以下几个性质：</p>
<ol>
<li>$phi(p) == p-1$​ 因为素数$p$除了$1$以外的因子只有$p$，所以与 $p$ 互素的个数是 $p - 1$个</li>
<li>$phi(p^k) == p^k - p^(k-1) == (p-1) * p^(k-1)$</li>
</ol>
<p>证明：</p>
<p>令$n == p^k$​​​​​,小于 $n$​​​​ 的正整数共有 $p^k-1$​​​​ 个,其中与 $p$​​​​ 不互素的个数共 $p^{k-1}-1 $​​​​个，它们是 $1*p,2*p,3*p … (p^{k-1}-1)*p$​</p>
<p>所以$phi(p^k) == (p^k-1) - (p^(k-1)-1) == p^k - p^(k-1) == (p-1) * p^(k-1)$​。</p>
<ol>
<li>如果$i \mod p == 0$, 那么 $\phi(i * p) == p * \phi(i)$ （证明略）</li>
</ol>
<p>举个例子：</p>
<p>假设 $p = 3$,$i = 6$,$p * i = 18 = 2 * 3^2$;</p>
<p>$\phi(3 * 6) == 18*(1-1/2)*(1-1/3) = 6$</p>
<p>$p * \phi(i) = 3 * \phi(6) = 3 * 6 * (1-1/2) *  (1-1/3) = 6 = \phi(i * p)$ 正确</p>
<ol>
<li>如果$i \mod p != 0$, 那么 $\phi(i * p) == \phi(i) * (p-1)$</li>
</ol>
<p>证明：</p>
<p>$i \mod p$ 不为$0$且$p$为质数, 所以$i$与$p$互质, 那么根据积性函数的性质 $\phi(i * p) == \phi(i) * \phi(p)$ 其中$\phi(p) == p-1$</p>
<p>所以$ \phi(i * p) == \phi(i) * (p-1)$​.</p>
<p>再举个例子：</p>
<p>假设$i = 4, p = 3, i * p = 3 * 4 = 12$</p>
<p>$\phi(12) = 12 * (1-1/2) * (1-1/3) = 4$</p>
<p>$\phi(i) * (p-1) = \phi(4) * (3-1) = 4 * (1-1/2) * 2 = 4 = \phi(i * p)$正确</p>
<h4 id="2-模板讲解-8"><a href="#2-模板讲解-8" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="keyword">int</span> euler[N];           <span class="comment">// 存储每个数的欧拉函数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_eulers</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    euler[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt ++ ] = i;</span><br><span class="line">            euler[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = primes[j] * i;</span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                euler[t] = euler[i] * primes[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            euler[t] = euler[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例4-3-3：筛法求欧拉函数"><a href="#例4-3-3：筛法求欧拉函数" class="headerlink" title="例4.3.3：筛法求欧拉函数"></a>例4.3.3：筛法求欧拉函数</h4><p>给定一个正整数 $n$，求 $1∼n$ 中每个数的欧拉函数之和。</p>
<h5 id="输入格式-9"><a href="#输入格式-9" class="headerlink" title="输入格式"></a>输入格式</h5><p>共一行，包含一个整数 $n$。</p>
<h5 id="输出格式-9"><a href="#输出格式-9" class="headerlink" title="输出格式"></a>输出格式</h5><p>共一行，包含一个整数，表示 $1∼n$ 中每个数的欧拉函数之和。</p>
<h5 id="数据范围-9"><a href="#数据范围-9" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n≤10^6$</p>
<h5 id="输入样例：-9"><a href="#输入样例：-9" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-9"><a href="#输出样例：-9" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure>
<h2 id="4-4-快速幂"><a href="#4-4-快速幂" class="headerlink" title="4.4 快速幂"></a>4.4 快速幂</h2><h4 id="1-知识讲解-8"><a href="#1-知识讲解-8" class="headerlink" title="1. 知识讲解"></a>1. 知识讲解</h4><p>快速幂:乘积的模，等于因子的模的乘积取模</p>
<script type="math/tex; mode=display">
(a×b)\%p=((a\%p)×(b\%p))\%p</script><p>压缩性能:把底数平方而让指数减半，达到缩短循环的目的</p>
<script type="math/tex; mode=display">
a^b=(a^2)^{b/2}</script><p>其中指数减半可以通过位运算来快速操作</p>
<h4 id="2-模板讲解-9"><a href="#2-模板讲解-9" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">求 m^k mod p，时间复杂度 <span class="built_in">O</span>(logk)。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span> % p, t = m;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k&amp;<span class="number">1</span>) res = res * t % p;</span><br><span class="line">        t = t * t % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例4-4：快速幂"><a href="#例4-4：快速幂" class="headerlink" title="例4.4：快速幂"></a>例4.4：快速幂</h4><p>给定 $n$ 组 $a_i,b_i,p_i$，对于每组数据，求出 $a_i^{b_i} \mod p_i$ 的值。</p>
<h5 id="输入格式-10"><a href="#输入格式-10" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $n$。</p>
<p>接下来 $n$ 行，每行包含三个整数 $a_i,b_i,p_i$。</p>
<h5 id="输出格式-10"><a href="#输出格式-10" class="headerlink" title="输出格式"></a>输出格式</h5><p>对于每组数据，输出一个结果，表示 $a_i^{b_i} \mod p_i$ 的值。</p>
<p>每个结果占一行。</p>
<h5 id="数据范围-10"><a href="#数据范围-10" class="headerlink" title="数据范围"></a>数据范围</h5><p>${1≤n≤100000}$,</p>
<p>${1≤a_i,b_i,p_i≤2×10^9}$</p>
<h5 id="输入样例：-10"><a href="#输入样例：-10" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3 2 5</span><br><span class="line">4 3 9</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-10"><a href="#输出样例：-10" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="4-5-扩展欧几里得算法"><a href="#4-5-扩展欧几里得算法" class="headerlink" title="4.5 扩展欧几里得算法"></a>4.5 扩展欧几里得算法</h2><h4 id="1-知识讲解-9"><a href="#1-知识讲解-9" class="headerlink" title="1. 知识讲解"></a>1. 知识讲解</h4><p>贝祖定理：已知整数$a,b,gcd(a,b)$,则一定存在整数 $x, y$ 满足等式 $ a * x + b * y = gcd(a,b)$；已知整数$a,b,x,y$,一定存在整数$k,d$满足 $a * x + b * y = d$,  $d=k*gcd(a,b)$​</p>
<p>这里的$a,b$是已知，$gcd(a,b)$表示的是$a$和$b$的最大公约数，所以扩展欧几里得算法既可以计算出最大公约数$gcd(a,b)$，又可以计算出变量$x$,$y$的一组解。</p>
<p>当$k$不为整数时，我们称$x，y$不全满足贝祖定理</p>
<p>在辗转相除法中，</p>
<script type="math/tex; mode=display">
a=a\%b+(a/b)*b</script><p>且</p>
<script type="math/tex; mode=display">
b*x_1+(a\%b)*y_1=gcd</script><p>代入得</p>
<script type="math/tex; mode=display">
a*y_1+b*(x_1-a/b*y_1)=gcd</script><p>故而我们得到x,y的一组解</p>
<script type="math/tex; mode=display">
\begin{cases}
x=y_1\\
y=x_1-(a/b)*y_1\\
\end{cases}</script><p>这就是我们的递归方程组</p>
<h4 id="2-模板讲解-10"><a href="#2-模板讲解-10" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求x, y，使得ax + by = gcd(a, b)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>; y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= (a/b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例4-7-扩展欧几里得算法"><a href="#例4-7-扩展欧几里得算法" class="headerlink" title="例4.7 扩展欧几里得算法"></a>例4.7 扩展欧几里得算法</h4><p>给定 $n$ 对正整数 $a_i,b_i$，对于每对数，求出一组 $x_i,y_i$i，使其满足 $a_i×x_i+b_i×y_i=gcd(a_i,b_i)$。</p>
<h5 id="输入格式-11"><a href="#输入格式-11" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $n$。</p>
<p>接下来 $n$ 行，每行包含两个整数 $a_i,b_i$。</p>
<h5 id="输出格式-11"><a href="#输出格式-11" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出共 $n$ 行，对于每组 $a_i,b_i$，求出一组满足条件的 $x_i,y_i$，每组结果占一行。</p>
<p>本题答案不唯一，输出任意满足条件的 $x_i,y_i$ 均可。</p>
<h5 id="数据范围-11"><a href="#数据范围-11" class="headerlink" title="数据范围"></a>数据范围</h5><p>${1≤n≤10^5}$,</p>
<p>${1≤a_i,b_i≤2×10^9}$</p>
<h5 id="输入样例：-11"><a href="#输入样例：-11" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">4 6</span><br><span class="line">8 18</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-11"><a href="#输出样例：-11" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1 1</span><br><span class="line">-2 1</span><br></pre></td></tr></table></figure>
<h5 id="示例代码-4"><a href="#示例代码-4" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int e_gcd(int a, int b, int* x, int* y)</span><br><span class="line">&#123;</span><br><span class="line">	if (b == 0)</span><br><span class="line">	&#123;</span><br><span class="line">		*x = 1, *y = 0;</span><br><span class="line">		return a;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		int r = e_gcd(b, a % b, x, y);</span><br><span class="line">		/* r = GCD(a, b) = GCD(b, a%b) */</span><br><span class="line">		int t = *x;</span><br><span class="line">		*x = *y;</span><br><span class="line">		*y = t - a / b * *y;</span><br><span class="line">		return r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int f=0;</span><br><span class="line">	int i,j;</span><br><span class="line">	int* x= &amp;i;</span><br><span class="line">	int* y= &amp;j;</span><br><span class="line">	f = e_gcd(5, 3, x, y);</span><br><span class="line">	printf(&quot;%d  %d&quot;,*y,*x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-6-中国剩余定理"><a href="#4-6-中国剩余定理" class="headerlink" title="4.6 中国剩余定理"></a>4.6 中国剩余定理</h2><h2 id="4-7-高斯消元"><a href="#4-7-高斯消元" class="headerlink" title="4.7 高斯消元"></a>4.7 高斯消元</h2><h4 id="1-知识讲解-10"><a href="#1-知识讲解-10" class="headerlink" title="1. 知识讲解"></a>1. 知识讲解</h4><p>高斯消元法是求解线性方阵组的一种算法，它也可用来求矩阵的秩，以及求可逆方阵的逆矩阵。它通过逐步消除未知数来将原始线性系统转化为另一个更简单的等价的系统。它的实质是通过初等行变化，将线性方程组的增广矩阵转化为行阶梯矩阵.</p>
<p>例如，已知线性方程组</p>
<script type="math/tex; mode=display">
\begin{cases}
3x_1+2x_2+x_n=6\\
2x_1+2x_2+2x_n=4\\
4x_1-2x_2-2x_n=2\\
\end{cases}</script><p>记为矩阵形式,</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
x&y&z&val\\
3&2&1&6\\
2&2&2&2\\
4&-2&-2&2\\
\end{bmatrix}</script><p>消去x，y</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
x&y&z&val\\
1&2\over3&1\over3&2\\
0&2\over3&4\over3&0\\
0&0&18\over3&-6\\
\end{bmatrix}</script><p>回带得解</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1\\2\\-1
\end{bmatrix}</script><p>无解：当消元完毕后，发现有一行系数都为 $0$，但是常数项不为 $0$，此时无解</p>
<p>例如：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
x&y&z&val\\
1&2\over3&1\over3&2\\
0&1&2&0\\
0&0&0&-6\\
\end{bmatrix}</script><p>多解：当消元完毕后，发现有多行系数、常数项均为 $0$，此时多解，有几行为全为 $0$，就有几个自由元，即变量的值可以任取，有无数种情况可以满足给出的方程组</p>
<p>例如：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
x&y&z&val\\
1&2\over3&1\over3&2\\
0&0&0&0\\
0&0&0&0\\
\end{bmatrix}</script><p>，此时自由元个数为 $2$</p>
<h4 id="2-模板讲解-11"><a href="#2-模板讲解-11" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a[N][N]是增广矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c, r;</span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &lt; n; i ++ )   <span class="comment">// 找到绝对值最大的行</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; <span class="built_in">fabs</span>(a[t][c]))</span><br><span class="line">                t = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[t][c]) &lt; eps) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = c; i &lt;= n; i ++ ) <span class="built_in">swap</span>(a[t][i], a[r][i]);      <span class="comment">// 将绝对值最大的行换到最顶端</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];      <span class="comment">// 将当前行的首位变成1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r + <span class="number">1</span>; i &lt; n; i ++ )       <span class="comment">// 用当前行将下面所有的列消成0</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; eps)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= c; j -- )</span><br><span class="line">                    a[i][j] -= a[r][j] * a[i][c];</span><br><span class="line"></span><br><span class="line">        r ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][n]) &gt; eps)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 无解</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 有无穷多组解</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++ )</span><br><span class="line">            a[i][n] -= a[i][j] * a[j][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 有唯一解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例4-7：高斯消元解线性方程组"><a href="#例4-7：高斯消元解线性方程组" class="headerlink" title="例4.7：高斯消元解线性方程组"></a>例4.7：高斯消元解线性方程组</h4><p>输入一个包含 $n$个方程 $n$ 个未知数的线性方程组。</p>
<p>方程组中的系数为实数。</p>
<p>求解这个方程组。</p>
<p>下图为一个包含 $m$ 个方程 $n$ 个未知数的线性方程组示例：</p>
<script type="math/tex; mode=display">
\begin{cases}
a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_n=b_1,\\[2ex]
a_{21}x_1 + a_{22}x_2 + \cdots +a_{2n}x_n=b2,\\[2ex]
\cdots\\
a_{m1}x_1+a_{m2}x_2+\cdots+a_{mn}x_n = b_m,

\end{cases}</script><h5 id="输入格式-12"><a href="#输入格式-12" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $n$。</p>
<p>接下来 $n$ 行，每行包含 $n+1$ 个实数，表示一个方程的 $n$ 个系数以及等号右侧的常数。</p>
<h5 id="输出格式-12"><a href="#输出格式-12" class="headerlink" title="输出格式"></a>输出格式</h5><p>如果给定线性方程组存在唯一解，则输出共 $n$ 行，其中第 $i$ 行输出第 $i$ 个未知数的解，结果保留两位小数。</p>
<p>如果给定线性方程组存在无数解，则输出 <em>Infinite group solutions</em>。</p>
<p>如果给定线性方程组无解，则输出 <em>No solution</em>。</p>
<h5 id="数据范围-12"><a href="#数据范围-12" class="headerlink" title="数据范围"></a>数据范围</h5><p>${1≤n≤100}$,</p>
<p>所有输入系数以及常数均保留两位小数，绝对值均不超过 ${100}$。</p>
<h5 id="输入样例：-12"><a href="#输入样例：-12" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1.00 2.00 -1.00 -6.00</span><br><span class="line">2.00 1.00 -3.00 -9.00</span><br><span class="line">-1.00 -1.00 2.00 7.00</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-12"><a href="#输出样例：-12" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.00</span><br><span class="line">-2.00</span><br><span class="line">3.00</span><br></pre></td></tr></table></figure>
<h2 id="4-8-组合计数"><a href="#4-8-组合计数" class="headerlink" title="4.8 组合计数"></a>4.8 组合计数</h2><h3 id="4-8-1-递归法求组合数"><a href="#4-8-1-递归法求组合数" class="headerlink" title="4.8.1 递归法求组合数"></a>4.8.1 递归法求组合数</h3><h4 id="1-知识讲解-11"><a href="#1-知识讲解-11" class="headerlink" title="1. 知识讲解"></a>1. 知识讲解</h4><p>如果$m$为$0$，那么一定只有一种取法，不用管$n$的个数 ，返回$1$；如果$n$小于$m$，比如从$3$个里面取$4$个，很显然是不可能的，返回$0$；如果$n$等于$m$，返回$1$；其他情况：假设有一个标记的球（实际没有），那么从$n$个球中取出$m$个球就有两种结果，带有标记的一堆，和不带有标记的一堆，假设函数$F(N,M)$，那么将是$F(N-1,M-1)+F(N-1,M)$​</p>
<h4 id="2-模板讲解-12"><a href="#2-模板讲解-12" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c[a][b] 表示从a个苹果中选b个的方案数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j ++ )</span><br><span class="line">        <span class="keyword">if</span> (!j) c[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> c[i][j] = (c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br></pre></td></tr></table></figure>
<h4 id="例4-8-1：求组合数-I"><a href="#例4-8-1：求组合数-I" class="headerlink" title="例4.8.1：求组合数 I"></a>例4.8.1：求组合数 I</h4><p>给定 $n$ 组询问，每组询问给定两个整数 $a，b$，请你输出 $C^a_b \mod (10^9+7)$ 的值。</p>
<h5 id="输入格式-13"><a href="#输入格式-13" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $n$。</p>
<p>接下来 $n$ 行，每行包含一组 $a$ 和 $b$。</p>
<h5 id="输出格式-13"><a href="#输出格式-13" class="headerlink" title="输出格式"></a>输出格式</h5><p>共 $n$ 行，每行输出一个询问的解。</p>
<h5 id="数据范围-13"><a href="#数据范围-13" class="headerlink" title="数据范围"></a>数据范围</h5><p>${1≤n≤10000}$,</p>
<p>${1≤b≤a≤2000}$</p>
<h5 id="输入样例：-13"><a href="#输入样例：-13" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">3 1</span><br><span class="line">5 3</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-13"><a href="#输出样例：-13" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">10</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h5 id="示例代码-5"><a href="#示例代码-5" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2010, mod = 1e9 + 7;</span><br><span class="line">int c[N][N];</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 0; i &lt; N; i ++)</span><br><span class="line">        for(int j = 0; j &lt;= i; j ++)</span><br><span class="line">            if(!j) c[i][j] = 1;</span><br><span class="line">            else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    while(n --)&#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">        printf(&quot;%d\n&quot;, c[a][b]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-8-2-通过预处理逆元的方式求组合数"><a href="#4-8-2-通过预处理逆元的方式求组合数" class="headerlink" title="4.8.2 通过预处理逆元的方式求组合数"></a>4.8.2 通过预处理逆元的方式求组合数</h3><h4 id="1-知识讲解-12"><a href="#1-知识讲解-12" class="headerlink" title="1. 知识讲解"></a>1. 知识讲解</h4><p>首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]<br>如果取模的数是质数，可以用费马小定理求逆元</p>
<script type="math/tex; mode=display">
C^b_a=\frac{a!}{b!*(a-b)!}\\
fact[i]=i!{\ }mod{\ }10^9+7\\
infact[i]=(i!)^{-1}{\ }mod{\ }10^9+7\\</script><p>故而</p>
<script type="math/tex; mode=display">
C_a^b=fact[a]*infact[b]*infact[a-b]</script><h4 id="2-模板讲解-13"><a href="#2-模板讲解-13" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]</span><br><span class="line">如果取模的数是质数，可以用费马小定理求逆元</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span>    <span class="comment">// 快速幂模板</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理阶乘的余数和阶乘逆元的余数</span></span><br><span class="line">fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    fact[i] = (LL)fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    infact[i] = (LL)infact[i - <span class="number">1</span>] * <span class="built_in">qmi</span>(i, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例4-8-2：求组合数-II"><a href="#例4-8-2：求组合数-II" class="headerlink" title="例4.8.2：求组合数 II"></a>例4.8.2：求组合数 II</h4><p>给定 $n$ 组询问，每组询问给定两个整数 $a，b$，请你输出 $C^a_b \mod (10^9+7)$ 的值。</p>
<h5 id="输入格式-14"><a href="#输入格式-14" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $n$。</p>
<p>接下来 $n$ 行，每行包含一组 $a$ 和 $b$。</p>
<h5 id="输出格式-14"><a href="#输出格式-14" class="headerlink" title="输出格式"></a>输出格式</h5><p>共 $n$ 行，每行输出一个询问的解。</p>
<h5 id="数据范围-14"><a href="#数据范围-14" class="headerlink" title="数据范围"></a>数据范围</h5><p>${1≤n≤10000}$,</p>
<p>${1≤b≤a≤10^5}$</p>
<h5 id="输入样例：-14"><a href="#输入样例：-14" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">3 1</span><br><span class="line">5 3</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-14"><a href="#输出样例：-14" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">10</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h5 id="示例代码-6"><a href="#示例代码-6" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int N = 100010, mod = 1e9 + 7;</span><br><span class="line">int fact[N], infact[N];</span><br><span class="line"></span><br><span class="line">int qmi(int a, int k, int p)</span><br><span class="line">&#123;</span><br><span class="line">    int res = 1;</span><br><span class="line">    while(k)&#123;</span><br><span class="line">        if(k &amp; 1) res = (ll)res * a % p;</span><br><span class="line">        a = (ll) a * a % p;</span><br><span class="line">        k &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    fact[0] = infact[0] = 1;</span><br><span class="line">    for(int i = 1; i &lt; N; i ++)&#123;</span><br><span class="line">        //表示i的阶乘</span><br><span class="line">        fact[i] = (ll)fact[i - 1] * i % mod;</span><br><span class="line">        //表示i的阶乘的逆元</span><br><span class="line">        infact[i] = (ll)infact[i - 1] * qmi(i, mod - 2, mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    while(n --)&#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">        printf(&quot;%d\n&quot;, (ll)fact[a] * infact[b] % mod * infact[a - b] % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-8-3-Lucas定理"><a href="#4-8-3-Lucas定理" class="headerlink" title="4.8.3 Lucas定理"></a>4.8.3 Lucas定理</h3><h4 id="1-知识讲解-13"><a href="#1-知识讲解-13" class="headerlink" title="1. 知识讲解"></a>1. 知识讲解</h4><p>概述：</p>
<p>Lucas（卢斯卡）定理是用来求C(n,m) mod p的值。其中：n和m是非负整数，p是素数。一般用于m，n很大而p很小，或者n，m不大但大于怕、，这样用阶乘就解决不了问题。</p>
<p>结论</p>
<script type="math/tex; mode=display">
C_n^m {\   } mod{\     } p=C_{n/p}^{m/p}×C_{n{\ }mod{\ }p}^{m{\ }mod{\ }p}{\ }mod{\  }p,p是素数</script><p>接下来，我么可以运用组合数和快速幂的知识解决</p>
<h4 id="2-模板讲解-14"><a href="#2-模板讲解-14" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">若p是质数，则对于任意整数 <span class="number">1</span> &lt;= m &lt;= n，有：</span><br><span class="line">    <span class="built_in">C</span>(n, m) = <span class="built_in">C</span>(n % p, m % p) * <span class="built_in">C</span>(n / p, m / p) (mod p)</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">qmi</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)  <span class="comment">// 快速幂模板</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span>  <span class="comment">// 通过定理求组合数C(a, b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    LL x = <span class="number">1</span>, y = <span class="number">1</span>;  <span class="comment">// x是分子，y是分母</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a, j = <span class="number">1</span>; j &lt;= b; i --, j ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        x = (LL)x * i % p;</span><br><span class="line">        y = (LL) y * j % p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x * (LL)<span class="built_in">qmi</span>(y, p - <span class="number">2</span>, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lucas</span><span class="params">(LL a, LL b, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; p &amp;&amp; b &lt; p) <span class="keyword">return</span> <span class="built_in">C</span>(a, b, p);</span><br><span class="line">    <span class="keyword">return</span> (LL)<span class="built_in">C</span>(a % p, b % p, p) * <span class="built_in">lucas</span>(a / p, b / p, p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例4-8-3：求组合数-III"><a href="#例4-8-3：求组合数-III" class="headerlink" title="例4.8.3：求组合数 III"></a>例4.8.3：求组合数 III</h4><p>给定 $n$ 组询问，每组询问给定三个整数 $a,b,p$，其中 $p$ 是质数，请你输出 $C^b_a \mod (10^9+7)$ 的值。</p>
<h5 id="输入格式-15"><a href="#输入格式-15" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $n$。</p>
<p>接下来 $n$ 行，每行包含一组 $a,b,p$。</p>
<h5 id="输出格式-15"><a href="#输出格式-15" class="headerlink" title="输出格式"></a>输出格式</h5><p>共 $n$ 行，每行输出一个询问的解。</p>
<h5 id="数据范围-15"><a href="#数据范围-15" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n≤20$,</p>
<p>$1≤b≤a≤10^{18}$,</p>
<p>$1≤p≤10^5$,</p>
<h5 id="输入样例：-15"><a href="#输入样例：-15" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">5 3 7</span><br><span class="line">3 1 5</span><br><span class="line">6 4 13</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-15"><a href="#输出样例：-15" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h5 id="示例代码-7"><a href="#示例代码-7" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int N = 100010, mod = 1e9 + 7;</span><br><span class="line">int p;</span><br><span class="line"></span><br><span class="line">int qmi(int a, int k)</span><br><span class="line">&#123;</span><br><span class="line">    int res = 1;</span><br><span class="line">    while(k)&#123;</span><br><span class="line">        if(k &amp; 1) res = (ll)res * a % p;</span><br><span class="line">        a = (ll)a * a % p;</span><br><span class="line">        k &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int C(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    int res = 1;</span><br><span class="line">    for(int i = 1, j = a; i &lt;= b; i ++, j --)&#123;</span><br><span class="line">        res = (ll)res * j % p;</span><br><span class="line">        //除i等于乘以i的逆元，费马定理i模p的逆元就是i ^(p-2)</span><br><span class="line">        res = (ll)res * qmi(i, p - 2) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int lucas(ll a, ll b)</span><br><span class="line">&#123;</span><br><span class="line">    if(a &lt; p &amp;&amp; b &lt; p) return C(a, b);</span><br><span class="line">    return (ll)C(a % p, b % p) * lucas(a / p, b / p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n; cin &gt;&gt; n;</span><br><span class="line">    while(n --)&#123;</span><br><span class="line">        ll a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">        cout &lt;&lt; lucas(a, b) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-8-4-分解质因数法求组合数"><a href="#4-8-4-分解质因数法求组合数" class="headerlink" title="4.8.4 分解质因数法求组合数"></a>4.8.4 分解质因数法求组合数</h3><h4 id="1-原理讲解-1"><a href="#1-原理讲解-1" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><p>当我们需要求出组合数而非其余数时，分解质因数的方式比较好用：</p>
<ol>
<li>筛法求出范围内的所有质数</li>
<li>通过 $C(a, b) = a! / b! / (a - b)!$ 这个公式求出每个质因子的次数。 $n!$ 中$p$的次数是 $n / p + n / p^2 + n / p^3 + …$</li>
<li>用高精度乘法将所有质因子相乘</li>
</ol>
<h4 id="2-模板讲解-15"><a href="#2-模板讲解-15" class="headerlink" title="2. 模板讲解"></a>2. 模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：</span><br><span class="line">    <span class="number">1.</span> 筛法求出范围内的所有质数</span><br><span class="line">    <span class="number">2.</span> 通过 <span class="built_in">C</span>(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^<span class="number">2</span> + n / p^<span class="number">3</span> + ...</span><br><span class="line">    <span class="number">3.</span> 用高精度乘法将所有质因子相乘</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> primes[N], cnt;     <span class="comment">// 存储所有质数</span></span><br><span class="line"><span class="keyword">int</span> sum[N];     <span class="comment">// 存储每个质数的次数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];     <span class="comment">// 存储每个数是否已被筛掉</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span>      <span class="comment">// 线性筛法求素数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> p)</span>       <span class="comment">// 求n！中的次数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        res += n / p;</span><br><span class="line">        n /= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> b)</span>       <span class="comment">// 高精度乘低精度模板</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += a[i] * b;</span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t)</span><br><span class="line">    &#123;</span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">get_primes</span>(a);  <span class="comment">// 预处理范围内的所有质数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ )     <span class="comment">// 求每个质因数的次数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> p = primes[i];</span><br><span class="line">    sum[i] = <span class="built_in">get</span>(a, p) - <span class="built_in">get</span>(b, p) - <span class="built_in">get</span>(a - b, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ )     <span class="comment">// 用高精度乘法将所有质因子相乘</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sum[i]; j ++ )</span><br><span class="line">        res = <span class="built_in">mul</span>(res, primes[i]);</span><br></pre></td></tr></table></figure>
<h4 id="例4-8-4：求组合数-IV"><a href="#例4-8-4：求组合数-IV" class="headerlink" title="例4.8.4：求组合数 IV"></a>例4.8.4：求组合数 IV</h4><p>输入 $a,b$，求 $C^b_a$ 的值。</p>
<p>注意结果可能很大，需要使用高精度计算。</p>
<h5 id="输入格式-16"><a href="#输入格式-16" class="headerlink" title="输入格式"></a>输入格式</h5><p>共一行，包含两个整数 $a$ 和 $b$。</p>
<h5 id="输出格式-16"><a href="#输出格式-16" class="headerlink" title="输出格式"></a>输出格式</h5><p>共一行，输出 $C^b_a$ 的值。</p>
<h5 id="数据范围-16"><a href="#数据范围-16" class="headerlink" title="数据范围"></a>数据范围</h5><p>${1≤b≤a≤5000}$</p>
<h5 id="输入样例：-16"><a href="#输入样例：-16" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-16"><a href="#输出样例：-16" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<h5 id="示例代码-8"><a href="#示例代码-8" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 5500 ;</span><br><span class="line">int prime[N] , sum[N] , tot;</span><br><span class="line">bool st[N];</span><br><span class="line">void get_prime(int n)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 2;i &lt;= n;i ++)</span><br><span class="line">     &#123;</span><br><span class="line">         if(!st[i]) prime[tot ++] = i ;</span><br><span class="line">         for(int j = 0; j &lt; tot &amp;&amp; i * prime[j] &lt;= n ;j ++)</span><br><span class="line">          &#123;</span><br><span class="line">              st[i * prime[j]] = true ;</span><br><span class="line">              if(i % prime[j] == 0) break ;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int get(int a , int p)</span><br><span class="line">&#123;</span><br><span class="line">    int sum = 0 ;</span><br><span class="line">    while(a)</span><br><span class="line">    &#123;</span><br><span class="line">         sum += a / p ;</span><br><span class="line">         a /= p ;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum ;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt; muti(vector&lt;int&gt; a , int b)</span><br><span class="line">&#123;</span><br><span class="line">    int t = 0 ;</span><br><span class="line">    vector&lt;int&gt; res ;</span><br><span class="line">    for(int i = 0;i &lt; a.size() ;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        t += a[i] * b ;</span><br><span class="line">        res.push_back(t % 10) ;</span><br><span class="line">        t /= 10 ;</span><br><span class="line">    &#125;</span><br><span class="line">    while(t)</span><br><span class="line">    &#123;</span><br><span class="line">        res.push_back(t % 10) ;</span><br><span class="line">        t /= 10 ;</span><br><span class="line">    &#125;</span><br><span class="line">    return res ;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    int a , b ;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt;  b ;</span><br><span class="line">    get_prime(a);</span><br><span class="line">    for(int i = 0; i &lt; tot ;i ++)</span><br><span class="line">     &#123;</span><br><span class="line">         int p = prime[i] ;</span><br><span class="line">         sum[i] = get(a,p) - get(b,p) - get(a-b , p);</span><br><span class="line">     &#125;</span><br><span class="line">     vector&lt;int&gt; res; </span><br><span class="line">     res.push_back(1);</span><br><span class="line">     for(int i = 0;i &lt; tot ; i ++)</span><br><span class="line">      for(int j = 0; j &lt; sum[i] ;j ++)</span><br><span class="line">       res = muti(res, prime[i]);</span><br><span class="line">     for(int i = res.size() - 1;i &gt;= 0;i --)</span><br><span class="line">      cout &lt;&lt; res[i]  ;</span><br><span class="line">     cout &lt;&lt; endl ;</span><br><span class="line">    return 0;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-8-5-卡特兰数"><a href="#4-8-5-卡特兰数" class="headerlink" title="4.8.5 卡特兰数"></a>4.8.5 卡特兰数</h3><p>给定$n$​个${0}$​和$n$​个${1}$​，它们按照某种顺序排成长度为${2n}$​的序列，满足任意前缀中$0$的个数都不少于$1$的个数的序列的数量为： $Cat(n) = C(2n, n) / (n + 1)$​</p>
<h4 id="例4-8-5：满足条件的01序列"><a href="#例4-8-5：满足条件的01序列" class="headerlink" title="例4.8.5：满足条件的01序列"></a>例4.8.5：满足条件的01序列</h4><p>给定 $n$ 个 ${0}$ 和 $n$ 个 ${1}$，它们将按照某种顺序排成长度为 ${2n}$ 的序列，求它们能排列成的所有序列中，能够满足任意前缀序列中 $0$ 的个数都不少于 1  的个数的序列有多少个。</p>
<p>输出的答案对 ${10^9+7}$ 取模。</p>
<h5 id="输入格式-17"><a href="#输入格式-17" class="headerlink" title="输入格式"></a>输入格式</h5><p>共一行，包含整数 $n$。</p>
<h5 id="输出格式-17"><a href="#输出格式-17" class="headerlink" title="输出格式"></a>输出格式</h5><p>共一行，包含一个整数，表示答案。</p>
<h5 id="数据范围-17"><a href="#数据范围-17" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n≤10^5$</p>
<h5 id="输入样例：-17"><a href="#输入样例：-17" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-17"><a href="#输出样例：-17" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<h5 id="示例代码-9"><a href="#示例代码-9" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">typedef long long LL;</span><br><span class="line"> </span><br><span class="line">const int mod = 1e9 + 7;</span><br><span class="line"> </span><br><span class="line">int qmi(int a, int k, int p)</span><br><span class="line">&#123;</span><br><span class="line">	int res = 1;</span><br><span class="line">	while(k)</span><br><span class="line">	&#123;</span><br><span class="line">		if(k &amp; 1) res = (LL)res * a % p;</span><br><span class="line">		a = (LL)a * a % p; </span><br><span class="line">		k &gt;&gt;= 1;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n; </span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	int a = 2 * n, b = n;</span><br><span class="line">	</span><br><span class="line">	int res = 1;</span><br><span class="line">	for(int i = a; i &gt;= a - b + 1; i --) res = (LL)res * i % mod;</span><br><span class="line">	for(int i = 1; i &lt;= b; i ++) res = (LL)res * qmi(i, mod - 2, mod) % mod;</span><br><span class="line">	res = (LL)res * qmi(n + 1, mod - 2, mod) % mod;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; res;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-9-容斥原理"><a href="#4-9-容斥原理" class="headerlink" title="4.9 容斥原理"></a>4.9 容斥原理</h2><h3 id="4-9-1原理讲解"><a href="#4-9-1原理讲解" class="headerlink" title="4.9.1原理讲解"></a>4.9.1原理讲解</h3><p>要计算几个集合并集的大小，我们要先将所有单个集合的大小计算出来，然后减去所有两个集合相交的部分，再加回所有三个集合相交的部分，再减去所有四个集合相交的部分，依此类推，一直计算到所有集合相交的部分。<br>写成公式就是</p>
<script type="math/tex; mode=display">
\Bigg\lvert\bigcup\limits_{i=1}^n A_i\Bigg\rvert=\sum\limits_{i=1}^n\Bigg\lvert A_i\Bigg\rvert -\sum\limits_{1\leq i\leq j\leq n}^n\Bigg\lvert A_i\bigcap A_j\Bigg\rvert+...+(-1)^{n-1}\Bigg\lvert A_1\bigcap...\bigcap A_n\Bigg\rvert</script><p>具体到问题上，我们既可以枚举分类，也可以DFS搜索归类，从而解决问题。</p>
<h3 id="例4-9-1：求能同时被几个数整除的数的个数"><a href="#例4-9-1：求能同时被几个数整除的数的个数" class="headerlink" title="例4.9.1：求能同时被几个数整除的数的个数"></a>例4.9.1：求能同时被几个数整除的数的个数</h3><p>求$1$到$n$​范围内能被$5，6，8$整除的数的个数。</p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>共一行，包括整数$n$</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>共一行，包括个数$k$</p>
<h4 id="数据范围-18"><a href="#数据范围-18" class="headerlink" title="数据范围"></a>数据范围</h4><p>${1\leq n\leq 10^7}$</p>
<h5 id="输入样例：-18"><a href="#输入样例：-18" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-18"><a href="#输出样例：-18" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">400</span><br></pre></td></tr></table></figure>
<h5 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">    #include&lt;cstdio&gt;  </span><br><span class="line">    #include&lt;cstring&gt;  </span><br><span class="line">    #include&lt;algorithm&gt;  </span><br><span class="line">    using namespace std;  </span><br><span class="line">    int main()  </span><br><span class="line">    &#123;  </span><br><span class="line">        int i,j,k,n,b,a;  </span><br><span class="line">        while(cin&gt;&gt;n)  </span><br><span class="line">        &#123;  </span><br><span class="line">            b = n/30+n/24+n/40;  </span><br><span class="line">        a = n/120;  </span><br><span class="line">        k = n/5+n/6+n/8;  </span><br><span class="line">        cout&lt;&lt;k-b+a&lt;&lt;endl;  </span><br><span class="line">        &#125;  </span><br><span class="line">      </span><br><span class="line">        return 0;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-10简单博弈论"><a href="#4-10简单博弈论" class="headerlink" title="4.10简单博弈论"></a>4.10简单博弈论</h2><h3 id="4-10-1-NIM游戏"><a href="#4-10-1-NIM游戏" class="headerlink" title="4.10.1 NIM游戏"></a>4.10.1 NIM游戏</h3><p>给定$N$堆物品，第$i$堆物品有$A_i$个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。</p>
<p>我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。</p>
<p>所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。</p>
<p>NIM博弈不存在平局，只有先手必胜和先手必败两种情况。</p>
<p>定理： NIM博弈先手必胜，当且仅当 <em>A1 ^ A2 ^ … ^ An != 0</em></p>
<h3 id="例4-10-1：经典NIM游戏"><a href="#例4-10-1：经典NIM游戏" class="headerlink" title="例4.10.1：经典NIM游戏"></a>例4.10.1：经典NIM游戏</h3><p>给定 $ n$ 堆石子，两位玩家轮流操作，每次操作可以从任意一堆石子中拿走任意数量的石子（可以拿完，但不能不拿），最后无法进行操作的人视为失败。<br>问如果两人都采用最优策略，先手是否必胜。</p>
<h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h4><p>第一行包含整数  $n$。<br>第二行包含  $n$ 个数字，其中第  $i$ 个数字表示第  $i$ 堆石子的数量。</p>
<h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><p>若先手必胜，输出$Yes$​</p>
<p>反之输出$No$​</p>
<h4 id="数据范围-19"><a href="#数据范围-19" class="headerlink" title="数据范围"></a>数据范围</h4><p>${1\leq n\leq 10^5}$</p>
<p>${1\leq {\rm 每堆石子数}\leq 10^9}$​​</p>
<h5 id="输入样例：-19"><a href="#输入样例：-19" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-19"><a href="#输出样例：-19" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure>
<h5 id="示例代码：-1"><a href="#示例代码：-1" class="headerlink" title="示例代码："></a>示例代码：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n, res = 0;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	while (n--)</span><br><span class="line">	&#123;</span><br><span class="line">		int x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		res ^= x;</span><br><span class="line">	&#125;</span><br><span class="line">	if (res) puts(&quot;Yes&quot;);</span><br><span class="line">	else puts(&quot;No&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-10-2-公平组合游戏ICG"><a href="#4-10-2-公平组合游戏ICG" class="headerlink" title="4.10.2 公平组合游戏ICG"></a>4.10.2 公平组合游戏ICG</h3><p>若一个游戏满足：</p>
<ol>
<li>由两名玩家交替行动；</li>
<li>在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；</li>
<li>不能行动的玩家判负；</li>
</ol>
<p>则称该游戏为一个公平组合游戏。</p>
<p>NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件$2$和条件$3$。</p>
<h3 id="4-10-2-有向图游戏"><a href="#4-10-2-有向图游戏" class="headerlink" title="4.10.2 有向图游戏"></a>4.10.2 有向图游戏</h3><p>给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。</p>
<p>任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。</p>
<h3 id="4-10-3-Mex运算"><a href="#4-10-3-Mex运算" class="headerlink" title="4.10.3 Mex运算"></a>4.10.3 Mex运算</h3><p>设$S$​表示一个非负整数集合。定义 <em>mex(S)</em>为求出不属于集合S的最小非负整数的运算，即：</p>
<p><em>mex(S) = min{x}</em>, $x$​属于自然数，且$x$​不属于$S$​</p>
<h3 id="4-10-4-SG函数"><a href="#4-10-4-SG函数" class="headerlink" title="4.10.4 SG函数"></a>4.10.4 SG函数</h3><p>在有向图游戏中，对于每个节点$x$，设从$x$出发共有$k$条有向边，分别到达节点$y_1, y_2, …, y_k$，定义 <em>SG(x)</em>为x的后继节点$y_1, y_2, …, y_k$ 的SG函数值构成的集合再执行 <em>mex(S)</em>运算的结果，即：<em>SG(x) = mex({SG(y1), SG(y2), …, SG(yk)})</em></p>
<p>特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即 <em>SG(G) = SG(s)</em></p>
<h3 id="4-10-5-有向图游戏的和"><a href="#4-10-5-有向图游戏的和" class="headerlink" title="4.10.5 有向图游戏的和"></a>4.10.5 有向图游戏的和</h3><p>设$G_1, G_2, …, G_m$ 是$m$个有向图游戏。定义有向图游戏$G$，它的行动规则是任选某个有向图游戏$G_i$，并在$G_i$上行动一步。$G$被称为有向图游戏$G_1, G_2, …, G_m$的和。</p>
<p>有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即：<em>SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)</em></p>
<p>定理：</p>
<p>有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。</p>
<p>有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。</p>
<h3 id="例4-10-1：经典NIM游戏-1"><a href="#例4-10-1：经典NIM游戏-1" class="headerlink" title="例4.10.1：经典NIM游戏"></a>例4.10.1：经典NIM游戏</h3><p>给定 $ n$ 堆石子，两位玩家轮流操作，每次操作可以从任意一堆石子中拿走任意数量的石子（可以拿完，但不能不拿），最后无法进行操作的人视为失败。<br>问如果两人都采用最优策略，先手是否必胜。</p>
<h4 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h4><p>第一行包含整数  $n$​。</p>
<p>第二行包含  $n$​ 个数字，其中第  $i$​ 个数字表示第  $i$​ 堆石子的数量。</p>
<h4 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h4><p>若先手必胜，输出$Yes$​</p>
<p>反之输出$No$​</p>
<h4 id="数据范围-20"><a href="#数据范围-20" class="headerlink" title="数据范围"></a>数据范围</h4><p>${1\leq n\leq 10^5}$​</p>
<p>${1\leq {\rm每堆石子数}\leq 10^9}$​</p>
<h5 id="输入样例：-20"><a href="#输入样例：-20" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-20"><a href="#输出样例：-20" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure>
<h5 id="示例代码：-2"><a href="#示例代码：-2" class="headerlink" title="示例代码："></a>示例代码：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n, res = 0;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	while (n--)</span><br><span class="line">	&#123;</span><br><span class="line">		int x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		res ^= x;</span><br><span class="line">	&#125;</span><br><span class="line">	if (res) puts(&quot;Yes&quot;);</span><br><span class="line">	else puts(&quot;No&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例4-10-5：集合-Nim游戏"><a href="#例4-10-5：集合-Nim游戏" class="headerlink" title="例4.10.5：集合-Nim游戏"></a>例4.10.5：集合-Nim游戏</h4><p>给定 $n$ 堆石子以及一个由 $k$ 个不同正整数构成的数字集合 $S$。</p>
<p>现在有两位玩家轮流操作，每次操作可以从任意一堆石子中拿取石子，每次拿取的石子数量必须包含于集合 $S$，最后无法进行操作的人视为失败。</p>
<p>问如果两人都采用最优策略，先手是否必胜。</p>
<h5 id="输入格式-18"><a href="#输入格式-18" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $k$，表示数字集合 $S$ 中数字的个数。</p>
<p>第二行包含 $k$ 个整数，其中第 $i$ 个整数表示数字集合 $S$ 中的第 $i$ 个数 $s_i$。</p>
<p>第三行包含整数 $n$。</p>
<p>第四行包含 $n$ 个整数，其中第 $i$ 个整数表示第 $i$ 堆石子的数量 $h_i$。</p>
<h5 id="输出格式-18"><a href="#输出格式-18" class="headerlink" title="输出格式"></a>输出格式</h5><p>如果先手方必胜，则输出 <em>Yes</em>。</p>
<p>否则，输出 <em>No</em>。</p>
<h5 id="数据范围-21"><a href="#数据范围-21" class="headerlink" title="数据范围"></a>数据范围</h5><p>${1≤n,k≤100}$​</p>
<p>${1≤s_i,h_i≤10000}$​</p>
<h5 id="输入样例：-21"><a href="#输入样例：-21" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2 5</span><br><span class="line">3</span><br><span class="line">2 4 7</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-21"><a href="#输出样例：-21" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure>
<h5 id="示例代码：-3"><a href="#示例代码：-3" class="headerlink" title="示例代码："></a>示例代码：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;unordered_set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=110,M=10010;</span><br><span class="line">int s[N],f[M],k,n;</span><br><span class="line">int sg(int t)</span><br><span class="line">&#123;</span><br><span class="line">    if(f[t]!=-1)return f[t];</span><br><span class="line">    unordered_set&lt;int&gt; map;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int num=s[i];</span><br><span class="line">        if(t&gt;=num)map.insert(sg(t-num));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int i=0;;i++)if(!map.count(i))return f[t]=i;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++)cin&gt;&gt;s[i];</span><br><span class="line">    memset(f,-1,sizeof(f));</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    int ans=0;</span><br><span class="line">    while(k--)</span><br><span class="line">    &#123;</span><br><span class="line">        int t;</span><br><span class="line">        cin&gt;&gt;t;</span><br><span class="line">        ans^=sg(t);</span><br><span class="line">    &#125;</span><br><span class="line">    ans?cout&lt;&lt;&quot;Yes&quot;:cout&lt;&lt;&quot;No&quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>npuCS 第三讲 搜索与图论</title>
    <url>/2022/01/08/basicACML3/</url>
    <content><![CDATA[<h1 id="第三讲-搜索与图论"><a href="#第三讲-搜索与图论" class="headerlink" title="第三讲 搜索与图论"></a>第三讲 搜索与图论</h1><h2 id="3-1-DFS与BFS"><a href="#3-1-DFS与BFS" class="headerlink" title="3.1 DFS与BFS"></a>3.1 DFS与BFS</h2><h3 id="3-1-1-DFS"><a href="#3-1-1-DFS" class="headerlink" title="3.1.1 DFS"></a>3.1.1 DFS</h3><h4 id="1-什么是DFS"><a href="#1-什么是DFS" class="headerlink" title="1.什么是DFS"></a>1.什么是DFS</h4><p> <strong>深度优先搜索算法</strong>（Depth First Search，简称DFS）：一种用于遍历或搜索树或图的算法。 沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过或者在搜寻时结点不满足条件，搜索将回溯到发现节点v的那条边的起始节点。整个进程反复进行直到所有节点都被访问为止。</p>
<p>简单的说就是可着一条路，使劲找，如果不符合条件就回到上一步，如果符合条件就继续找，直到找到全部的解为止。</p>
<p>当问题是让你找到<strong>*全部方案*</strong>时，选用<strong>*DFS*</strong></p>
<h4 id="2-模板讲解"><a href="#2-模板讲解" class="headerlink" title="2.模板讲解"></a>2.模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(参数)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(满足条件)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        判断边界，若达到边界</span><br><span class="line">        &#123;</span><br><span class="line">            相应操作</span><br><span class="line">        &#125;</span><br><span class="line">        若未达到边界，尝试每一种可能</span><br><span class="line">        &#123;</span><br><span class="line">               满足check条件</span><br><span class="line">               标记</span><br><span class="line">               继续下一步<span class="built_in">dfs</span>(step+<span class="number">1</span>)</span><br><span class="line">               恢复初始状态（回溯的时候要用到）</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-例题和代码"><a href="#3-例题和代码" class="headerlink" title="3.例题和代码"></a>3.例题和代码</h4><h5 id="第一题-题目描述"><a href="#第一题-题目描述" class="headerlink" title="第一题    题目描述"></a>第一题    题目描述</h5><h5 id="排列数字"><a href="#排列数字" class="headerlink" title="排列数字"></a>排列数字</h5><p>给定一个整数$n$，将数字 $1∼n$ 排成一排，将会有很多种排列方法。</p>
<p>现在，请你按照字典序将所有的排列方法输出。</p>
<h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><p>共一行，包含一个整数 $n$</p>
<h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>按字典序输出所有排列方案，每个方案占一行。</p>
<h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1 ≤ n ≤ 7$</p>
<h5 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h5 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 3 2</span><br><span class="line">2 1 3</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure>
<h5 id="本题分析"><a href="#本题分析" class="headerlink" title="本题分析"></a>本题分析</h5><p>先画一下本题的解空间树 首先以3为例</p>
<p><img src="/2022/01/08/basicACML3/3.1.1.png" alt></p>
<p>看到本图我们就知道，为什么这个叫解空间树了，它不仅包含本题的全部的解，形状还像一颗树。</p>
<p>因为<em>n=3</em>所以我们假设有3个空位，我们每次给空位填的数字都是我们当前方案中未填过的数字（即无数字重复）</p>
<p>最开始的时候 <em>— — —</em></p>
<p>从1开始 故  <em>1 — —</em></p>
<p><em>1 — —</em>从1开始，因为1填过了 所以填2   <em>1 2 —</em></p>
<p>显然第三次只能填3 即 <em>1 2 3</em> 第一种方案完成 此时我们要回到上一步即<em>1 2 —</em>发现还是没有不同的选择</p>
<p>再返回一步即<em>1 — —</em>发现可以通过填3来形成新的方案<em>1 3 —</em>从而找到<em>1 3 2</em></p>
<p>以此类推，遍历解空间树，从而找到全部的解方案。</p>
<h5 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> st[<span class="number">10</span>];<span class="comment">//标记数组 防止出现重复数字 即112 331</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;a[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[i])</span><br><span class="line">            &#123;</span><br><span class="line">                st[i]= <span class="literal">true</span>;</span><br><span class="line">                a[t]=i;</span><br><span class="line">                <span class="built_in">dfs</span>(t+<span class="number">1</span>);</span><br><span class="line">                st[i]= <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="第二题-题目描述-n-皇后问题"><a href="#第二题-题目描述-n-皇后问题" class="headerlink" title="第二题 题目描述   n-皇后问题"></a>第二题 题目描述   n-皇后问题</h5><p>$n−$皇后问题是指将 $n$ 个皇后放在 $n×n$ 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。</p>
<p>现在给定整数 $n$，请你输出所有的满足条件的棋子摆法。</p>
<h5 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h5><p>共一行，包含整数 $n$。</p>
<h5 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h5><p>每个解决方案占 $n$ 行，每行输出一个长度为 $n$ 的字符串，用来表示完整的棋盘状态。</p>
<p>其中 <em>.</em> 表示某一个位置的方格状态为空，<em>Q</em> 表示某一个位置的方格上摆着皇后。</p>
<p>每个方案输出完成后，输出一个空行。</p>
<p><strong>注意：行末不能有多余空格。</strong></p>
<p>输出方案的顺序任意，只要不重复且没有遗漏即可。</p>
<h5 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n≤9$</p>
<h5 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h5 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.Q..</span><br><span class="line">...Q</span><br><span class="line">Q...</span><br><span class="line">..Q.</span><br><span class="line"></span><br><span class="line">..Q.</span><br><span class="line">Q...</span><br><span class="line">...Q</span><br><span class="line">.Q..</span><br></pre></td></tr></table></figure>
<p><strong>解题思路</strong></p>
<p>我们每次只考虑一行所以不会出现一行中同时有两个皇后的情况，即我们每次只考虑该行的皇后应放在哪里才能保证符合条件，我们应判断<strong>3个方向</strong><em>竖 对角线 反对角线</em>分别用col dg udg的数组来表示</p>
<p>其中数组的大小 <img src="/2022/01/08/basicACML3/3.1.2d.png" alt></p>
<p>为了方便我们都开20大小的数组；</p>
<p>下面在讲一下如何判断皇后放在该行的此处 是否符合规定 </p>
<p><em>col[i]</em>必须为0即该列上没有皇后</p>
<p>同时<em>dg[u + i] udg[n - u + i]</em>必须也为0，这表示对角线和反对角线均没有皇后</p>
<p>下面是解释 <strong>*u是x即行      i是列即y*</strong></p>
<p><img src="/2022/01/08/basicACML3/3.1.2c.png" alt></p>
<p>满足上面的3个条件后就可以在该行的此处放置皇后了</p>
<p>这时要把<em>col[i]dg[u + i] udg[n - u + i</em>均赋值成<strong>true</strong></p>
<p>然后<strong>dfs</strong>下一行</p>
<p>千万别忘了<strong>恢复现场</strong>哦</p>
<h5 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// bool数组用来判断搜索的下一个位置是否可行</span></span><br><span class="line"><span class="comment">// col列，dg对角线，udg反对角线</span></span><br><span class="line"><span class="comment">// g[N][N]用来存皇后的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">bool</span> col[N], dg[N], udg[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// u == n 表示已经搜了n行，故输出这条路径</span></span><br><span class="line">    <span class="keyword">if</span> (u == n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">puts</span>(g[i]);<span class="comment">// 等价于cout &lt;&lt; g[i] &lt;&lt; endl;</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);  <span class="comment">// 换行</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对n个位置按行搜索</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="comment">// 剪枝(对于不满足要求的点，不再继续往下搜索)  </span></span><br><span class="line">        <span class="comment">// udg[n - u + i]，+n是为了保证下标非负</span></span><br><span class="line">        <span class="keyword">if</span> (!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u + i]) &#123;</span><br><span class="line">            g[u][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            col[i] = dg[u + i] = udg[n - u + i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">            col[i] = dg[u + i] = udg[n - u + i] = <span class="literal">false</span>; <span class="comment">// 恢复现场 这步很关键</span></span><br><span class="line">            g[u][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h3 id="3-1-2-BFS"><a href="#3-1-2-BFS" class="headerlink" title="3.1.2 BFS"></a>3.1.2 BFS</h3><h4 id="1-什么是BFS"><a href="#1-什么是BFS" class="headerlink" title="1.什么是BFS"></a>1.什么是BFS</h4><p>广度优先搜索算法（Breadth-First-Search），是一种图形搜索算法。简单的说，BFS是从根节点开始，沿着树(图)的宽度遍历树(图)的节点。如果所有节点均被访问，则算法中止。BFS同样属于盲目搜索。一般用队列数据结构来辅助实现BFS算法。</p>
<p>当题目要求 求解<strong>什么什么最小</strong>时，用<strong>BFS</strong>。（<strong>DFS会超时</strong>）</p>
<p>下面我给大家画图描述一下</p>
<p><img src="/2022/01/08/basicACML3/3.1.2e.png" alt></p>
<h4 id="2-模板讲解-1"><a href="#2-模板讲解-1" class="headerlink" title="2.模板讲解"></a>2.模板讲解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> g[][];<span class="comment">//记录迷宫</span></span><br><span class="line"><span class="keyword">bool</span> st[][];<span class="comment">//标记数组防止重复判断</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="comment">//我们每一个状态用node表示</span></span><br><span class="line">    其他的我们需要的元素</span><br><span class="line">    <span class="keyword">bool</span> useful;<span class="comment">//该节点是否可用</span></span><br><span class="line">&#125;node;</span><br><span class="line"><span class="function">node <span class="title">move_</span><span class="params">(node now,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/**********/</span></span><br><span class="line">    扩展方法有很多</span><br><span class="line">    <span class="keyword">int</span> xx=now.x+dx[i];<span class="comment">//扩展的x坐标</span></span><br><span class="line">    <span class="keyword">int</span> yy=now.y+dy[i];<span class="comment">//扩展的y坐标</span></span><br><span class="line">    <span class="comment">/**********/</span></span><br><span class="line">    node next=&#123;xx,yy,<span class="number">0</span>, <span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(符合条件)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(未被扩展过)</span><br><span class="line">        &#123;</span><br><span class="line">            st[xx][yy]= <span class="literal">true</span>;<span class="comment">//标记扩展过</span></span><br><span class="line">            next.useful= <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(node start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;node&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    node now,next;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        now=q.<span class="built_in">front</span>();<span class="comment">//取队首元素</span></span><br><span class="line">        q.<span class="built_in">pop</span>();<span class="comment">//出队</span></span><br><span class="line">        <span class="keyword">if</span>()<span class="comment">//到达目标节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            输出</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(多种扩展方法)</span><br><span class="line">        &#123;</span><br><span class="line">            next=<span class="built_in">move_</span>(now,i);<span class="comment">//i 表示第几种扩展方式</span></span><br><span class="line">            <span class="keyword">if</span>(next.useful)<span class="comment">//可用</span></span><br><span class="line">            &#123;</span><br><span class="line">                相应处理</span><br><span class="line">                q.<span class="built_in">push</span>(next);<span class="comment">//入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3-例题和代码-1"><a href="#3-例题和代码-1" class="headerlink" title="3.例题和代码"></a>3.例题和代码</h4><h5 id="第一题-题目描述-1"><a href="#第一题-题目描述-1" class="headerlink" title="第一题 题目描述"></a>第一题 题目描述</h5><p><strong>走迷宫</strong></p>
<p>给定一个$n×m$ 的二维整数数组，用来表示一个迷宫，数组中只包含 $0$或 $1$，其中 $0$ 表示可以走的路，$1$表示不可通过的墙壁。</p>
<p>最初，有一个人位于左上角$(1,1)$ 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。</p>
<p>请问，该人从左上角移动至右下角$(n,m)$ 处，至少需要移动多少次。</p>
<p>数据保证 $(1,1)$处和 $(n,m)$ 处的数字为 $0$，且一定至少存在一条通路。</p>
<h5 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含两个整数 $n$ 和 $m$。</p>
<p>接下来 $n$ 行，每行包含 $m$个整数（$0$或 $1$），表示完整的二维数组迷宫。</p>
<h5 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出一个整数，表示从左上角移动至右下角的最少移动次数。</p>
<h5 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n,m≤100$</p>
<h5 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">0 1 0 0 0</span><br><span class="line">0 1 0 1 0</span><br><span class="line">0 0 0 0 0</span><br><span class="line">0 1 1 1 0</span><br><span class="line">0 0 0 1 0</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>
<h5 id="解析和代码"><a href="#解析和代码" class="headerlink" title="解析和代码"></a>解析和代码</h5><p>从起点开始，每个点均有4个方向扩展 上下左右，在扩展时一是要<strong>*保证不越界*</strong>二是要<strong>*保证扩展过的节点不重复扩展*</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> g[<span class="number">110</span>][<span class="number">110</span>];<span class="comment">//记录迷宫</span></span><br><span class="line"><span class="keyword">bool</span> st[<span class="number">110</span>][<span class="number">110</span>];<span class="comment">//标记数组防止重复判断</span></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="comment">//下上右左</span></span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="comment">//我们每一个状态用node表示</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> cnt;<span class="comment">//记录步数</span></span><br><span class="line">    <span class="keyword">bool</span> useful;<span class="comment">//该节点是否可用</span></span><br><span class="line">&#125;node;</span><br><span class="line"><span class="function">node <span class="title">move_</span><span class="params">(node now,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xx=now.x+dx[i];<span class="comment">//扩展的x坐标</span></span><br><span class="line">    <span class="keyword">int</span> yy=now.y+dy[i];<span class="comment">//扩展的y坐标</span></span><br><span class="line">    node next=&#123;xx,yy,<span class="number">0</span>, <span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(xx&gt;=<span class="number">1</span>&amp;&amp;xx&lt;=n&amp;&amp;yy&gt;=<span class="number">1</span>&amp;&amp;yy&lt;=m&amp;&amp;!g[xx][yy])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[xx][yy])</span><br><span class="line">        &#123;</span><br><span class="line">            st[xx][yy]= <span class="literal">true</span>;</span><br><span class="line">            next.useful= <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(node start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;node&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    node now,next;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        now=q.<span class="built_in">front</span>();<span class="comment">//取队首元素</span></span><br><span class="line">        q.<span class="built_in">pop</span>();<span class="comment">//出队</span></span><br><span class="line">        <span class="keyword">if</span>(now.x==n&amp;&amp;now.y==m)<span class="comment">//到达目标节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;now.cnt&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)<span class="comment">//共四种扩展方向</span></span><br><span class="line">        &#123;</span><br><span class="line">            next=<span class="built_in">move_</span>(now,i);</span><br><span class="line">            <span class="keyword">if</span>(next.useful)</span><br><span class="line">            &#123;</span><br><span class="line">                next.cnt=now.cnt+<span class="number">1</span>;<span class="comment">//步数加一</span></span><br><span class="line">                q.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;g[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node start=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="literal">true</span>&#125;;</span><br><span class="line">    st[<span class="number">1</span>][<span class="number">1</span>]= <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">bfs</span>(start);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h5><h5 id="题目描述-8数码"><a href="#题目描述-8数码" class="headerlink" title="题目描述   8数码"></a>题目描述   <strong>8数码</strong></h5><p>在一个 $3×3$ 的网格中，$1∼8$ 这$8$ 个数字和一个 <em>x</em> 恰好不重不漏地分布在这 $3×3$ 的网格中。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">x 4 6</span><br><span class="line">7 5 8</span><br></pre></td></tr></table></figure>
<p>在游戏过程中，可以把 <em>x</em> 与其上、下、左、右四个方向之一的数字交换（如果存在）。</p>
<p>我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 x</span><br></pre></td></tr></table></figure>
<p>例如，示例中图形就可以通过让 <em>x</em> 先后与右、下、右三个方向的数字交换成功得到正确排列。</p>
<p>交换过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3   1 2 3   1 2 3   1 2 3</span><br><span class="line">x 4 6   4 x 6   4 5 6   4 5 6</span><br><span class="line">7 5 8   7 5 8   7 x 8   7 8 x</span><br></pre></td></tr></table></figure>
<p>现在，给你一个初始网格，请你求出得到正确排列至少需要进行多少次交换。</p>
<h5 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h5><p>输入占一行，将 3×33×3 的初始网格描绘出来。</p>
<p>例如，如果初始网格如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 </span><br><span class="line">x 4 6 </span><br><span class="line">7 5 8 </span><br></pre></td></tr></table></figure>
<p>则输入为：<em>1 2 3 x 4 6 7 5 8</em></p>
<h5 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出占一行，包含一个整数，表示最少交换次数。</p>
<p>如果不存在解决方案，则输出 −1−1。</p>
<h5 id="输入样例：-2"><a href="#输入样例：-2" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2  3  4  1  5  x  7  6  8</span><br></pre></td></tr></table></figure>
<h5 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例"></a>输出样例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">19</span><br></pre></td></tr></table></figure>
<h5 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h5><p>本题 每种node即状态 需要6种元素来描述</p>
<ol>
<li><p>x0  记录x的横坐标</p>
</li>
<li><p>y0 记录x的纵坐标</p>
</li>
<li><p><em>a[3][3]</em>  记录8数码中数的位置（x当成0）</p>
</li>
<li><p>num  <em>a[3][3]</em> 因为8数码中数的位置不能重复，所以他们表示的9位十进制数都是独一无二的</p>
<p>eg   123</p>
<p>​       456   <em>-&gt;</em>    123456780</p>
<p>​       780</p>
</li>
<li><p>cnt 记录步数</p>
</li>
<li><p>useful 判断是否可用</p>
</li>
</ol>
<p>因为本题状态比较多，所以用st数组会爆掉 故要用 set来存储每种状态的num值如果 该num已经出现在set 中说明该状态重复 不扩展该状态</p>
<h5 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> work[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;<span class="comment">//4种移动方向</span></span><br><span class="line">set&lt;<span class="keyword">int</span>&gt;m;<span class="comment">//判断是否重复扩展</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x0;</span><br><span class="line">    <span class="keyword">int</span> y0;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">bool</span> useful;</span><br><span class="line">&#125;node;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_num</span><span class="params">(node now)</span><span class="comment">//根据a[3][3]计算num</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line">            sum=sum*<span class="number">10</span>+now.a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">move_</span><span class="params">(<span class="keyword">int</span> i,node now)</span><span class="comment">//移动函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node next=now;</span><br><span class="line">    next.useful= <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> xx=now.x0+work[i][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> yy=now.y0+work[i][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(xx&gt;=<span class="number">0</span>&amp;&amp;xx&lt;=<span class="number">2</span>&amp;&amp;yy&gt;=<span class="number">0</span>&amp;&amp;yy&lt;=<span class="number">2</span>)<span class="comment">//不能越界</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(next.a[now.x0][now.y0],next.a[xx][yy]);<span class="comment">//移动0的位置即x的位置</span></span><br><span class="line">        next.num= <span class="built_in">get_num</span>(next);<span class="comment">//更新num值</span></span><br><span class="line">        next.cnt=now.cnt+<span class="number">1</span>;<span class="comment">//步数加1</span></span><br><span class="line">        next.x0=xx;<span class="comment">//更新横坐标</span></span><br><span class="line">        next.y0=yy;<span class="comment">//更新纵坐标</span></span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">count</span>(next.num)==<span class="number">0</span>)<span class="comment">//从未扩展过</span></span><br><span class="line">        &#123;</span><br><span class="line">            m.<span class="built_in">insert</span>(next.num);<span class="comment">//进入set 以标记</span></span><br><span class="line">            next.useful= <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(node start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;node&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    node now,next;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        now=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(now.num==<span class="number">123456780</span>)<span class="comment">//找到目标节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> now.cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            next=<span class="built_in">move_</span>(i,now);</span><br><span class="line">            <span class="keyword">if</span>(next.useful)<span class="comment">//如果可用</span></span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//方法不可以</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node start;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            string s;<span class="comment">//字符串处理没什么好说的</span></span><br><span class="line">            cin&gt;&gt;s;</span><br><span class="line">            <span class="keyword">if</span>(s[<span class="number">0</span>]!=<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">int</span> t=s[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            start.a[i][j]=t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;x&#x27;</span>)<span class="comment">//记录x的位置 把x当成0看待</span></span><br><span class="line">            &#123;</span><br><span class="line">                start.x0=i;</span><br><span class="line">                start.y0=j;</span><br><span class="line">                start.a[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    start.cnt=<span class="number">0</span>;</span><br><span class="line">    start.useful= <span class="literal">true</span>;</span><br><span class="line">    start.num=<span class="built_in">get_num</span>(start);</span><br><span class="line">    m.<span class="built_in">insert</span>(start.num);</span><br><span class="line">    <span class="comment">//以上都是初始化start</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">bfs</span>(start)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2树与图的遍历：拓扑排序"><a href="#3-2树与图的遍历：拓扑排序" class="headerlink" title="3.2树与图的遍历：拓扑排序"></a>3.2树与图的遍历：拓扑排序</h2><h3 id="3-2-1树与图的储存"><a href="#3-2-1树与图的储存" class="headerlink" title="3.2.1树与图的储存"></a>3.2.1树与图的储存</h3><p>树是一种特殊的图，与图的存储方式相同。<br>对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。<br>因此我们可以只考虑有向图的存储。</p>
<p>(1) 邻接矩阵：<em>g[a][b]</em> 存储边a-&gt;b</p>
<p>(2) 邻接表：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</span></span><br><span class="line"><span class="keyword">int</span> h[N]N个点, e[N]N条边, ne[N]N条边, idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边a-&gt;b</span></span><br><span class="line"><span class="comment">//idx作为一个指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;<span class="comment">//存值 记录这个指针指向哪个点</span></span><br><span class="line">    ne[idx] = h[a];<span class="comment">//b的下一个点指向a的下一个点</span></span><br><span class="line">    h[a] = idx ++ ;<span class="comment">//a的下一个点修改成b         eg  1.a-&gt;c-&gt;d-&gt;e</span></span><br><span class="line">&#125;												 <span class="comment">/*2.  a-&gt;c-&gt;d-&gt;e</span></span><br><span class="line"><span class="comment">														  ^</span></span><br><span class="line"><span class="comment">														  |</span></span><br><span class="line"><span class="comment">														  b	</span></span><br><span class="line"><span class="comment">                                                    3.a-&gt;b-&gt;c-&gt;d-&gt;e      </span></span><br><span class="line"><span class="comment">                                                          </span></span><br><span class="line"><span class="comment">                                                          </span></span><br><span class="line"><span class="comment">                                                          */</span></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-2-2树与图的遍历"><a href="#3-2-2树与图的遍历" class="headerlink" title="3.2.2树与图的遍历"></a>3.2.2树与图的遍历</h3><p>时间复杂度 O(n+m)O(n+m), nn 表示点数，mm 表示边数</p>
<h4 id="1-深度优先遍历"><a href="#1-深度优先遍历" class="headerlink" title="(1) 深度优先遍历"></a>(1) 深度优先遍历</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// st[u] 表示点u已经被遍历过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span> 这就是初始化h全为<span class="number">-1</span>的原因; i = ne[i] 指向下一个点)</span><br><span class="line">        <span class="comment">//把i看成一个指针</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];<span class="comment">//i是指针 j代表是那个点</span></span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j);<span class="comment">//如果这个点没有被搜过就 dfs这个点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例3-2-2-1：树的重心"><a href="#例3-2-2-1：树的重心" class="headerlink" title="例3.2.2.1：树的重心"></a>例3.2.2.1：树的重心</h4><p>给定一颗树，树中包含 $n$ 个结点（编号 $1∼n$）和 $n−1$ 条无向边。</p>
<p>请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。</p>
<p>重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。</p>
<h5 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $n$，表示树的结点数。</p>
<p>接下来 $n−1$ 行，每行包含两个整数 $a$ 和 $b$，表示点 $a$ 和点 $b$ 之间存在一条边。</p>
<h5 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出一个整数 $m$，表示将重心删除后，剩余各个连通块中点数的最大值。</p>
<h5 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n≤10^5$</p>
<h5 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">1 2</span><br><span class="line">1 7</span><br><span class="line">1 4</span><br><span class="line">2 8</span><br><span class="line">2 5</span><br><span class="line">4 3</span><br><span class="line">3 9</span><br><span class="line">4 6</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h5 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h5><p><img src="/2022/01/08/basicACML3/3.2.2a.png" alt></p>
<p>因为是深搜，所以所有情况都会考虑到，所以我们只需要彻底弄懂一种操作原理即可</p>
<h5 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">2</span>*N;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx,n,ans=N;</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//返回以u为根的子树中结点的个数</span></span><br><span class="line">    st[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> s=<span class="built_in">dfs</span>(j);<span class="comment">//每个子树节点个数</span></span><br><span class="line">            res=<span class="built_in">max</span>(s,res);<span class="comment">//子树中最大节点</span></span><br><span class="line">            sum+=s;<span class="comment">//以u为根的子树们的节点个数和</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res=<span class="built_in">max</span>(res,n-sum);<span class="comment">//以u为根的最大子树和剩余节点比较</span></span><br><span class="line">    ans=<span class="built_in">min</span>(ans,res);<span class="comment">//找到最大们的最小</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);<span class="comment">//无向图 所以要添加2次</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-宽度优先遍历"><a href="#2-宽度优先遍历" class="headerlink" title="(2) 宽度优先遍历"></a>(2) 宽度优先遍历</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例3-2-2-2：图中点的层次"><a href="#例3-2-2-2：图中点的层次" class="headerlink" title="例3.2.2.2：图中点的层次"></a>例3.2.2.2：图中点的层次</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个 $n$ 个点 $m$ 条边的有向图，图中可能存在重边和自环。</p>
<p>所有边的长度都是 $1$，点的编号为 $1∼n$。</p>
<p>请你求出 $1$ 号点到 $n$ 号点的最短距离，如果从 $1$ 号点无法走到 $n$ 号点，输出 $−1$。</p>
<h5 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含两个整数 $n$ 和 $m$。</p>
<p>接下来 $m$行，每行包含两个整数 $a$ 和 $b$，表示存在一条从 $a $走到 $b$ 的长度为 $1$ 的边。</p>
<h5 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出一个整数，表示 $1$ 号点到 $n$ 号点的最短距离。</p>
<h5 id="数据范围-4"><a href="#数据范围-4" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n,m≤10^5$</p>
<h5 id="输入样例：-3"><a href="#输入样例：-3" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-3"><a href="#输出样例：-3" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h5 id="本题思路"><a href="#本题思路" class="headerlink" title="本题思路"></a>本题思路</h5><p>参考广搜 就是一层一层的更新，直到搜到n，同时别忘了cnt加一。</p>
<h5 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],ne[N],e[N],idx;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">bool</span> st[N];<span class="comment">//标记数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">&#125;node;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(node start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//下面是经典操作</span></span><br><span class="line">    node now,next;</span><br><span class="line">    queue&lt;node&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    st[start.x]= <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        now=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(now.x==n)<span class="comment">//到达n输出</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> now.cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[now.x];i!=<span class="number">-1</span>;i=ne[i])<span class="comment">//扩展所有与 now.x相连的并且从来未使用过的点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];<span class="comment">//now.x与j相连</span></span><br><span class="line">            <span class="keyword">if</span>(!st[j])</span><br><span class="line">            &#123;</span><br><span class="line">                st[j]= <span class="literal">true</span>;<span class="comment">//标记用过</span></span><br><span class="line">                next.x=j;<span class="comment">//从j开始</span></span><br><span class="line">                next.cnt=now.cnt+<span class="number">1</span>;<span class="comment">//前进一步</span></span><br><span class="line">                q.<span class="built_in">push</span>(next);<span class="comment">//入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="built_in">add</span>(x,y);<span class="comment">//有向图</span></span><br><span class="line">    &#125;</span><br><span class="line">    node start;</span><br><span class="line">    start.cnt=<span class="number">0</span>;</span><br><span class="line">    start.x=<span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">bfs</span>(start)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-2-3拓扑排序"><a href="#3-2-3拓扑排序" class="headerlink" title="3.2.3拓扑排序"></a>3.2.3拓扑排序</h3><p>时间复杂度 $O(n+m)$, $n$ 表示点数，$m$ 表示边数</p>
<h5 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;<span class="comment">//这里用了一个q数组当成队列</span></span><br><span class="line">    <span class="comment">// d[i] 存储点i的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!d[i])</span><br><span class="line">            q[ ++ tt] = i;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh ++ ];<span class="comment">//取队头元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])<span class="comment">//遍历所以的</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (-- d[j] == <span class="number">0</span>)<span class="comment">//更新入度</span></span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span></span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="模板讲解"><a href="#模板讲解" class="headerlink" title="模板讲解"></a>模板讲解</h5><p>首先如何确定一个拓扑排序(注意同一个图可能有多个拓扑排序)</p>
<p><img src="/2022/01/08/basicACML3/3.2.2b.png" alt></p>
<h5 id="例题-有向图的拓扑排序"><a href="#例题-有向图的拓扑排序" class="headerlink" title="例题 有向图的拓扑排序"></a>例题 有向图的拓扑排序</h5><p>给定一个 $n $个点 $m$ 条边的有向图，点的编号是$1$ 到 $n$，图中可能存在重边和自环。</p>
<p>请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出 $−1$。</p>
<p>若一个由图中所有点构成的序列 $A$ 满足：对于图中的每条边 $(x,y)$，$x$ 在 $A $中都出现在 $y$ 之前，则称 $A$ 是该图的一个拓扑序列。</p>
<h5 id="输入格式-6"><a href="#输入格式-6" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含两个整数$n$ 和 $m$。</p>
<p>接下来 $m $行，每行包含两个整数 $x$ 和 $y$，表示存在一条从点 $x$ 到点 $y$ 的有向边 $(x,y)$。</p>
<h5 id="输出格式-6"><a href="#输出格式-6" class="headerlink" title="输出格式"></a>输出格式</h5><p>共一行，如果存在拓扑序列，则输出任意一个合法的拓扑序列即可。</p>
<p>否则输出$−1$。</p>
<h5 id="数据范围-5"><a href="#数据范围-5" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n,m≤10^5$</p>
<h5 id="输入样例：-4"><a href="#输入样例：-4" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-4"><a href="#输出样例：-4" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br></pre></td></tr></table></figure>
<h5 id="本题解析和代码与模板类似就不过多赘述了-别忘了建立有向图时顺带着建立入度数组"><a href="#本题解析和代码与模板类似就不过多赘述了-别忘了建立有向图时顺带着建立入度数组" class="headerlink" title="本题解析和代码与模板类似就不过多赘述了(别忘了建立有向图时顺带着建立入度数组)"></a>本题解析和代码与模板类似就不过多赘述了(别忘了建立有向图时顺带着建立入度数组)</h5><h2 id="3-3最短路"><a href="#3-3最短路" class="headerlink" title="3.3最短路"></a>3.3最短路</h2><h3 id="前言-以下算法用法简述"><a href="#前言-以下算法用法简述" class="headerlink" title="前言 以下算法用法简述"></a>前言 以下算法用法简述</h3><p><img src="/2022/01/08/basicACML3/3.2.2c.png" alt></p>
<h3 id="3-3-1朴素dijkstra算法"><a href="#3-3-1朴素dijkstra算法" class="headerlink" title="3.3.1朴素dijkstra算法"></a>3.3.1朴素dijkstra算法</h3><p>时间复杂是 $O(n^2+m)$, $n$ 表示点数，$m$表示边数</p>
<h5 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> g[N][N];  <span class="comment">// 存储每条边</span></span><br><span class="line"><span class="keyword">int</span> dist[N];  <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="keyword">bool</span> st[N];   <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )<span class="comment">//你就记住 n个点除去起点 总共要处理n-1次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;     <span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] （表示没被考虑过）&amp;&amp; (t == <span class="number">-1</span>（表示是第一次比较，故直接赋值） || dist[t] &gt; dist[j]（找到一个更小的所以要更新）))</span><br><span class="line">                t = j;<span class="comment">//找到最小的距离</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用t更新其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);<span class="comment">//用找到最小的那个，去更新所有距离</span></span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;<span class="comment">//别忘了标记</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//到达不了n点</span></span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="模板解析"><a href="#模板解析" class="headerlink" title="模板解析"></a>模板解析</h5><p><img src="/2022/01/08/basicACML3/3.2.2d.png" alt></p>
<p>以上面的3号点为例  一开始只考虑点1  dist[3]=12，当将点2考虑进来后  因为 <em>dist[3]=12&gt;dist[2]+g[2][3]=10</em> ,所以要去更新dist数组 使dist[3]=10</p>
<h5 id="例题-Dijkstra求最短路-I"><a href="#例题-Dijkstra求最短路-I" class="headerlink" title="例题 Dijkstra求最短路 I"></a>例题 Dijkstra求最短路 I</h5><p>给定一个 $n$ 个点 $m$ 条边的有向图，图中可能存在重边和自环，所有边权均为正值。</p>
<p>请你求出 $1$号点到 $n$ 号点的最短距离，如果无法从 $1$ 号点走到 $n$ 号点，则输出 $−1$。</p>
<h5 id="输入格式-7"><a href="#输入格式-7" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $n$ 和 $m$。</p>
<p>接下来 $m$ 行每行包含三个整数 $x$,$y$,$z$表示存在一条从点 $x$ 到点 $y$ 的有向边，边长为 $z$。</p>
<h5 id="输出格式-7"><a href="#输出格式-7" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出一个整数，表示 $1$ 号点到 $n$ 号点的最短距离。</p>
<p>如果路径不存在，则输出 $−1$。</p>
<h5 id="数据范围-6"><a href="#数据范围-6" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n≤500$,<br>$1≤m≤10^5$,<br>图中涉及边长均不超过10000。</p>
<h5 id="输入样例：-5"><a href="#输入样例：-5" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 2</span><br><span class="line">2 3 1</span><br><span class="line">1 3 4</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-5"><a href="#输出样例：-5" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h5 id="本题解析和代码与模板类似就不过多赘述了"><a href="#本题解析和代码与模板类似就不过多赘述了" class="headerlink" title="本题解析和代码与模板类似就不过多赘述了"></a>本题解析和代码与模板类似就不过多赘述了</h5><h3 id="3-3-2堆优化的dijkstra"><a href="#3-3-2堆优化的dijkstra" class="headerlink" title="3.3.2堆优化的dijkstra"></a>3.3.2堆优化的dijkstra</h3><h5 id="为什么要用堆优化"><a href="#为什么要用堆优化" class="headerlink" title="为什么要用堆优化"></a>为什么要用堆优化</h5><p>在普通版中每次我们在寻找最小的未被使用过的<em>dist[i]</em>都是从头到尾遍历一边效率低下，本算法采用堆，来简化排序的过程，从而降低时间。</p>
<p>时间复杂度 $O(mlogn)$, $n$ 表示点数，$m$ 表示边数</p>
<h4 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">int</span> n;      <span class="comment">// 点的数量</span></span><br><span class="line"><span class="keyword">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="keyword">int</span> dist[N];        <span class="comment">// 存储所有点到1号点的距离</span></span><br><span class="line"><span class="keyword">bool</span> st[N];     <span class="comment">// 存储每个点的最短距离是否已确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<span class="comment">//小根堆</span></span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);      <span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())<span class="comment">//若堆不为空 即还有点没有考虑过</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();<span class="comment">//当前最小的 就是堆顶元素</span></span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ver = t.second;<span class="comment">//编号</span></span><br><span class="line">        <span class="keyword">int</span> distance = t.first;<span class="comment">//距离</span></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;<span class="comment">//如果这个编号用过</span></span><br><span class="line">        st[ver] = <span class="literal">true</span>;<span class="comment">//标记这个编号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])<span class="comment">//遍历这个编号所连接的全部的点，来更新dist数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];<span class="comment">//点j是ver所连接的点</span></span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + w[i])<span class="comment">//满足更新条件</span></span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);<span class="comment">//新的距离要放入堆中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例3-3-2-Dijkstra求最短路-II"><a href="#例3-3-2-Dijkstra求最短路-II" class="headerlink" title="例3.3.2 Dijkstra求最短路 II"></a>例3.3.2 Dijkstra求最短路 II</h4><p>给定一个 $n$个点 $m $条边的有向图，图中可能存在重边和自环，所有边权均为非负值。</p>
<p>请你求出 $1$ 号点到 $n$ 号点的最短距离，如果无法从 $1$ 号点走到 $n$ 号点，则输出 $−1$。</p>
<h5 id="输入格式-8"><a href="#输入格式-8" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $n$和 $m$。</p>
<p>接下来 $m$ 行每行包含三个整数$ x,y,z$，表示存在一条从点 $x$ 到点 $y$ 的有向边，边长为 $z$。</p>
<h5 id="输出格式-8"><a href="#输出格式-8" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出一个整数，表示 $1$号点到 $n$ 号点的最短距离。</p>
<p>如果路径不存在，则输出 $−1$。</p>
<h5 id="数据范围-7"><a href="#数据范围-7" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n,m≤1.5×10^5$,<br>图中涉及边长均不小于 $0$，且不超过 $10000$。</p>
<h5 id="输入样例：-6"><a href="#输入样例：-6" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 2</span><br><span class="line">2 3 1</span><br><span class="line">1 3 4</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-6"><a href="#输出样例：-6" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h5 id="本题代码"><a href="#本题代码" class="headerlink" title="本题代码"></a>本题代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">150010</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],w[N],e[N],ne[N],idx;</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span> &gt;pii;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=y;</span><br><span class="line">    ne[idx]=h[x];</span><br><span class="line">    w[idx]=c;<span class="comment">//多维护一个权值数组</span></span><br><span class="line">    h[x]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">d</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt;heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!heap.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t=heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> d=t.first;</span><br><span class="line">        <span class="keyword">int</span> num=t.second;</span><br><span class="line">        <span class="keyword">if</span>(st[num])<span class="keyword">continue</span>;</span><br><span class="line">        st[num]= <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[num];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;d+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=w[i]+d;</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j],j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,t;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;t;</span><br><span class="line">        <span class="built_in">add</span>(x,y,t);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">d</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-3-Bellman-Ford算法"><a href="#3-3-3-Bellman-Ford算法" class="headerlink" title="3.3.3 Bellman-Ford算法"></a>3.3.3 Bellman-Ford算法</h3><h4 id="什么是bellman-ford算法？"><a href="#什么是bellman-ford算法？" class="headerlink" title="什么是bellman - ford算法？"></a>什么是bellman - ford算法？</h4><p>Bellman - ford 算法是求含负权图的单源最短路径的一种算法，效率较低，代码难度较小。其原理为连续进行松弛，在每次松弛时把每条边都更新一下，若在 n-1 次松弛后还能更新，则说明图中有负环，因此无法得出结果，否则就完成。<br>(通俗的来讲就是：假设 1 号点到 n 号点是可达的，每一个点同时向指向的方向出发，更新相邻的点的最短距离，通过循环 n-1 次操作，若图中不存在负环，则 1 号点一定会到达 n 号点，若图中存在负环，则在 n-1 次松弛后一定还会更新)</p>
<p><strong>时间复杂度 $O(nm)$, $n$ 表示点数，$m $表示边数</strong></p>
<p>注意在例题中需要对下面的模板稍作修改，加上备份数组。</p>
<h4 id="关于dijkstra为什么不能用在有负权的图"><a href="#关于dijkstra为什么不能用在有负权的图" class="headerlink" title="关于dijkstra为什么不能用在有负权的图"></a>关于dijkstra为什么不能用在有负权的图</h4><p><img src="/2022/01/08/basicACML3/3.2.2e.png" alt></p>
<h4 id="模板-3"><a href="#模板-3" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;       <span class="comment">// n表示点数，m表示边数</span></span><br><span class="line"><span class="keyword">int</span> dist[N];        <span class="comment">// dist[x]存储1到x的最短路距离</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>     // 边，<span class="title">a</span>表示出点，<span class="title">b</span>表示入点，<span class="title">w</span>表示边的权重</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。（负权回路通俗点讲就是，你一直在这个回路里走并且总权重还会减小，理论上如果不限制步数，就会一直在里面一直走）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )<span class="comment">//遍历所有边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;</span><br><span class="line">            <span class="keyword">if</span> (dist[b] &gt; dist[a] + w)<span class="comment">//类比  迪杰特斯拉 </span></span><br><span class="line">                dist[b] = dist[a] + w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="例题-有边数限制的最短路"><a href="#例题-有边数限制的最短路" class="headerlink" title="例题 有边数限制的最短路"></a>例题 有边数限制的最短路</h5><p>给定一个 $n$ 个点 $m$ 条边的有向图，图中可能存在重边和自环， <strong>边权可能为负数</strong>。</p>
<p>请你求出从 $1$ 号点到 $n$ 号点的最多经过 $k$ 条边的最短距离，如果无法从 $1$ 号点走到 $n$ 号点，输出 <em>impossible</em>。</p>
<p>注意：图中可能 <strong>存在负权回路</strong> 。</p>
<h5 id="输入格式-9"><a href="#输入格式-9" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含三个整数 $n,m,k$。</p>
<p>接下来 $m$ 行，每行包含三个整数 $x,y,z$，表示存在一条从点 $x$ 到点 $y$ 的有向边，边长为 $z$。</p>
<h5 id="输出格式-9"><a href="#输出格式-9" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出一个整数，表示从 $1$ 号点到 $n$ 号点的最多经过 $k$ 条边的最短距离。</p>
<p>如果不存在满足条件的路径，则输出 <em>impossible</em>。</p>
<h5 id="数据范围-8"><a href="#数据范围-8" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n,k≤500$<br>$1≤m≤10000$,<br>任意边长的绝对值不超过 $10000$。</p>
<h5 id="输入样例：-7"><a href="#输入样例：-7" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3 1</span><br><span class="line">1 2 1</span><br><span class="line">2 3 1</span><br><span class="line">1 3 3</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-7"><a href="#输出样例：-7" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h5 id="参考代码-5"><a href="#参考代码-5" class="headerlink" title="参考代码"></a>参考代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> dist[N],backup[N];<span class="comment">//备份数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,w;</span><br><span class="line">&#125;edge[<span class="number">10010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;<span class="comment">//k次松弛</span></span><br><span class="line">        <span class="built_in">memcpy</span>(backup,dist,<span class="keyword">sizeof</span> dist);<span class="comment">//开始备份</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> a=edge[j].a,b=edge[j].b,w=edge[j].w;</span><br><span class="line">            dist[b]= <span class="built_in">min</span>(dist[b],backup[a]+w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,t;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;t;</span><br><span class="line">        edge[i].a=x;</span><br><span class="line">        edge[i].b=y;</span><br><span class="line">        edge[i].w=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t= <span class="built_in">bell</span>();</span><br><span class="line">    <span class="keyword">if</span>(t&gt;=<span class="number">0x3f3f3f3f</span>/<span class="number">2</span>)<span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);<span class="comment">//是否能到达n号点的判断中需要进行if(dist[n] &gt; INF/2)判断，而并非是if(dist[n] == INF)判断，原因是INF是一个确定的值，并非真正的无穷大，会随着其他数值而受到影响，dist[n]大于某个与INF相同数量级的数即可</span></span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="关于备份数组"><a href="#关于备份数组" class="headerlink" title="关于备份数组"></a>关于备份数组</h5><p>我们为什么要设计这样一个数组呢？答案就是防止串联，不能立刻用上更新的值因为有可能会不满足k条边的条件。</p>
<p><img src="/2022/01/08/basicACML3/3.2.2f.png" alt></p>
<h3 id="3-3-4-spfa-算法（队列优化的Bellman-Ford算法）"><a href="#3-3-4-spfa-算法（队列优化的Bellman-Ford算法）" class="headerlink" title="3.3.4 spfa 算法（队列优化的Bellman-Ford算法）"></a>3.3.4 spfa 算法（队列优化的Bellman-Ford算法）</h3><h5 id="为什么要用spfa算法"><a href="#为什么要用spfa算法" class="headerlink" title="为什么要用spfa算法"></a>为什么要用spfa算法</h5><p>Bellman_ford算法会遍历所有的边，但是有很多的边遍历了其实没有什么意义，我们只用遍历那些到源点距离变小的点所连接的边即可，只有当一个点的前驱结点更新了，该节点才会得到更新；因此考虑到这一点，我们将创建一个队列每一次加入距离被更新的结点。</p>
<h5 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h5><p> Bellman_ford算法可以存在负权回路，是因为其循环的次数是有限制的因此最终不会发生死循环；但是SPFA算法不可以，由于用了队列来存储，只要发生了更新就会不断的入队，因此假如<strong>有负权回路请你不要用SPFA否则会死循环</strong>。</p>
<p><strong>时间复杂度 平均情况下 $O(m)$，最坏情况下 $O(nm)$, $n$ 表示点数，$m$ 表示边数假如题目时间允许可以直接用SPFA算法去解Dijkstra算法的题目。</strong></p>
<h4 id="模板-4"><a href="#模板-4" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;      <span class="comment">// 总点数</span></span><br><span class="line"><span class="keyword">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="keyword">int</span> dist[N];        <span class="comment">// 存储每个点到1号点的最短距离</span></span><br><span class="line"><span class="keyword">bool</span> st[N];     <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);<span class="comment">//1号点是起点</span></span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;<span class="comment">//代表之后该节点如果发生更新可再次入队</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])<span class="comment">//遍历跟t相连的所有点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])<span class="comment">//w[i]是t到j的距离 当不再更新时代表已完成要把队列清空跳出循环（若有负回路则无限循环）</span></span><br><span class="line">            &#123;<span class="comment">//只用入队那些既没有访问过还使距离变小的点</span></span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j])     <span class="comment">// 如果队列中已存在j，则不需要将j重复插入即便发生了更新也只用更新数值即可，重复添加降低效率</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="模板解析-1"><a href="#模板解析-1" class="headerlink" title="模板解析"></a>模板解析</h5><ol>
<li><p>Bellman_ford算法里最后return-1的判断条件写的是dist[n]&gt;0x3f3f3f3f/2;而spfa算法写的是dist[n]==0x3f3f3f3f;其原因在于Bellman_ford算法会遍历所有的边，因此不管是不是和源点连通的边它都会得到更新；但是SPFA算法不一样，它相当于采用了BFS，因此<strong>遍历到的结点都是与源点连通的</strong>，因此如果你要求的n和源点不连通，它不会得到更新，还是保持的0x3f3f3f3f。</p>
</li>
<li><p>SPFA算法看上去和Dijstra算法长得有一些像但是其中的意义还是相差甚远的:</p>
<ol>
<li>Dijkstra算法中的st数组保存的是当前确定了到源点距离最小的点，且一旦确定了最小那么就<strong>不可逆</strong>了(不可标记为true后改变为false)；SPFA算法中的st数组<strong>仅仅只是表示的当前发生过更新的点，且spfa中的st数组可逆</strong>(可以在标记为true之后又标记为false)。顺带一提的是BFS中的st数组记录的是当前已经被遍历过的点。</li>
<li>Dijkstra算法里使用的是<strong>优先队列保存的是当前未确定最小距离的点</strong>，目的是快速的取出当前到源点距离最小的点；SPFA算法中使用的是队列(你也可以使用别的数据结构),目的只是<strong>记录一下当前发生过更新的点</strong>。</li>
</ol>
</li>
</ol>
<h5 id="例题-spfa求最短路"><a href="#例题-spfa求最短路" class="headerlink" title="例题   spfa求最短路"></a>例题   spfa求最短路</h5><p>给定一个 $n$ 个点 $m$ 条边的有向图，图中可能存在重边和自环， <strong>边权可能为负数</strong>。</p>
<p>请你求出 $1$ 号点到 $n$ 号点的最短距离，如果无法从 $1$ 号点走到 $n$ 号点，则输出 <em>impossible</em>。</p>
<p>数据保证不存在负权回路。</p>
<h5 id="输入格式-10"><a href="#输入格式-10" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $n$ 和 $m$。</p>
<p>接下来 $m$ 行每行包含三个整数 $x,y,z$，表示存在一条从点 $x$ 到点 $y$ 的有向边，边长为 $z$。</p>
<h5 id="输出格式-10"><a href="#输出格式-10" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出一个整数，表示 $1$ 号点到 $n$ 号点的最短距离。</p>
<p>如果路径不存在，则输出 <em>impossible</em>。</p>
<h5 id="数据范围-9"><a href="#数据范围-9" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n,m≤10^5$,<br>图中涉及边长绝对值均不超过 $10000$。</p>
<h5 id="输入样例：-8"><a href="#输入样例：-8" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 5</span><br><span class="line">2 3 -3</span><br><span class="line">1 3 4</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-8"><a href="#输出样例：-8" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h5 id="参考代码-6"><a href="#参考代码-6" class="headerlink" title="参考代码"></a>参考代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],ne[N],e[N],w[N],idx;</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=t;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>]= <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t]= <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j]= <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,t;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;t;</span><br><span class="line">        <span class="built_in">add</span>(x,y,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="built_in">spfa</span>();</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">0x3f3f3f3f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="跟模板类似没什么好说的"><a href="#跟模板类似没什么好说的" class="headerlink" title="跟模板类似没什么好说的"></a>跟模板类似没什么好说的</h5><h3 id="3-3-5-spfa判断图中是否存在负环"><a href="#3-3-5-spfa判断图中是否存在负环" class="headerlink" title="3.3.5  spfa判断图中是否存在负环"></a>3.3.5  spfa判断图中是否存在负环</h3><p>时间复杂度是 $O(nm)$, $n$ 表示点数，$m$ 表示边数</p>
<h4 id="模板-5"><a href="#模板-5" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;      <span class="comment">// 总点数</span></span><br><span class="line"><span class="keyword">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="keyword">int</span> dist[N], cnt[N];        <span class="comment">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];     <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在负环，则返回true，否则返回false。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  这里不需要初始化dist数组为 正无穷/初始化的原因是， 如果存在负环， 那么dist不管初始化为多少， 都会被更新</span></span><br><span class="line">    <span class="comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。</span></span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;<span class="comment">//因为是从t到j 所以j的步数是c的步数加1.</span></span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;       <span class="comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="模板解析-2"><a href="#模板解析-2" class="headerlink" title="模板解析"></a>模板解析</h5><p>就是多维护一个cnt数组，当你执行n次后发现最短距离还能减小，就说明一定存在负环，因为你可以一直走负环来让你的最短距离十分小（卡bug）</p>
<p>同时还有一点 为什么要在一开始的时候把所有点都放在队列中呢？</p>
<p>如下图所示</p>
<p><img src="/2022/01/08/basicACML3/3.2.2g.png" alt></p>
<h4 id="例题-spfa判断负环"><a href="#例题-spfa判断负环" class="headerlink" title="例题  spfa判断负环"></a>例题  spfa判断负环</h4><p>给定一个 $n$个点 $m$ 条边的有向图，图中可能存在重边和自环， <strong>边权可能为负数</strong>。</p>
<p>请你判断图中是否存在负权回路。</p>
<h5 id="输入格式-11"><a href="#输入格式-11" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数$n$和  $m$ 。</p>
<p>接下来  $m$ 行每行包含三个整数$x,y,z$，表示存在一条从点 $x$到点$ y$的有向边，边长为 $z$.</p>
<h5 id="输出格式-11"><a href="#输出格式-11" class="headerlink" title="输出格式"></a>输出格式</h5><p>如果图中<strong>存在</strong>负权回路，则输出 <em>Yes</em>，否则输出 <em>No</em>。</p>
<h5 id="数据范围-10"><a href="#数据范围-10" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n≤2000$<br>$1≤m≤10000$,<br>图中涉及边长绝对值均不超过 $10000$。</p>
<h5 id="输入样例：-9"><a href="#输入样例：-9" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 -1</span><br><span class="line">2 3 4</span><br><span class="line">3 1 -4</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-9"><a href="#输出样例：-9" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure>
<h5 id="参考代码-7"><a href="#参考代码-7" class="headerlink" title="参考代码"></a>参考代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],ne[N],e[N],w[N],idx;</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=t;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t]= <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;n)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j]= <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,t;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;t;</span><br><span class="line">        <span class="built_in">add</span>(x,y,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> t=<span class="built_in">spfa</span>();</span><br><span class="line">    <span class="keyword">if</span>(t)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="跟模板差不多"><a href="#跟模板差不多" class="headerlink" title="跟模板差不多"></a>跟模板差不多</h5><h3 id="3-3-6-floyd算法"><a href="#3-3-6-floyd算法" class="headerlink" title="3.3.6 floyd算法"></a>3.3.6 floyd算法</h3><p>时间复杂度是 $O(n^3)$, $n$ 表示点数</p>
<h4 id="模板-6"><a href="#模板-6" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">初始化：</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法结束后，d[a][b]表示a到b的最短距离</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模板解析-3"><a href="#模板解析-3" class="headerlink" title="模板解析"></a>模板解析</h4><p><em>f[i, j, k]</em>表示从i走到j的路径上除<em>i</em>和<em>j</em>点外只经过<em>1</em>到<em>k</em>的点的所有路径的最短距离。</p>
<p>根据动态规划思想</p>
<p>若不经过第k个点则 <em>f[i, j, k] = f[i, j, k - 1]</em></p>
<p>若经过第k个点则 <em>f[i, j, k] = f[i, k, k - 1] + f[k, j, k - 1]</em> </p>
<p>所以<em>f[i, j, k] = min(f[i, j, k - 1], f[i, k, k - 1] + f[k, j, k - 1])</em> </p>
<p>因此在计算第<em>k</em>层的<em>f[i, j]</em>的时候必须先将第<em>k - 1</em>层的所有状态计算出来，所以需要把<em>k</em>放在最外层。</p>
<p>故3维数组变2维    <em>f[i][j] = min(f[i][j],f[i][k] + f[k][j]);</em></p>
<h4 id="例题-Floyd求最短路"><a href="#例题-Floyd求最短路" class="headerlink" title="例题   Floyd求最短路"></a>例题   Floyd求最短路</h4><p>给定一个 $n$个点 $m$ 条边的有向图，图中可能存在重边和自环，边权可能为负数。</p>
<p>再给定 $k$ 个询问，每个询问包含两个整数 $x$ 和$y$，表示查询从点 $x$ 到点 $y$的最短距离，如果路径不存在，则输出 <em>impossible</em>。</p>
<p>数据保证图中不存在负权回路。</p>
<h5 id="输入格式-12"><a href="#输入格式-12" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含三个整数 $n,m,k$。</p>
<p>接下来$ m$ 行，每行包含三个整数 $x,y,z$，表示存在一条从点 $x$ 到点 $y$ 的有向边，边长为 $z$。</p>
<p>接下来 kk 行，每行包含两个整数 $x,y$，表示询问点 $x$ 到点 $y $的最短距离。</p>
<h5 id="输出格式-12"><a href="#输出格式-12" class="headerlink" title="输出格式"></a>输出格式</h5><p>共 kk 行，每行输出一个整数，表示询问的结果，若询问两点间不存在路径，则输出 <em>impossible</em>。</p>
<h5 id="数据范围-11"><a href="#数据范围-11" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n≤200$<br>$1≤k≤n^2$<br>$1≤m≤20000$,<br>图中涉及边长绝对值均不超过 $10000$。</p>
<h5 id="输入样例：-10"><a href="#输入样例：-10" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3 2</span><br><span class="line">1 2 1</span><br><span class="line">2 3 2</span><br><span class="line">1 3 1</span><br><span class="line">2 1</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-10"><a href="#输出样例：-10" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">impossible</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h5 id="参考代码-8"><a href="#参考代码-8" class="headerlink" title="参考代码"></a>参考代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">210</span>;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m,z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j)g[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> g[i][j]=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,t;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;t;</span><br><span class="line">        g[x][y]=<span class="built_in">min</span>(t,g[x][y]);<span class="comment">//可能存在重边 取最小值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">floyd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; z; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(g[x][y]&gt;<span class="number">0x3f3f3f3f</span>/<span class="number">2</span>)<span class="comment">//断从a到b是否是无穷大距离时，需要进行if(t &gt; INF/2)判断，而并非是if(t == INF)判断，原因是INF是一个确定的值，并非真正的无穷大，会随着其他数值而受到影响，t大于某个与INF相同数量级的数即可</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;<span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;g[x][y]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                g[i][j]= <span class="built_in">min</span>(g[i][j],g[i][k]+g[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-4最小生成树"><a href="#3-4最小生成树" class="headerlink" title="3.4最小生成树"></a>3.4最小生成树</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>最小生成树（minimum spanning tree）是由n个顶点，n-1条边，将一个连通图连接起来，且使权值最小的结构。</p>
<h3 id="3-4-1-朴素版prim算法"><a href="#3-4-1-朴素版prim算法" class="headerlink" title="3.4.1  朴素版prim算法"></a>3.4.1  朴素版prim算法</h3><p>这里就采用的是邻接矩阵存储的，<br>个人觉得Prim和最短路中的dijkstra很像，方法：<br>① 先建立一个只有一个结点的树，这个结点可以是原图中任 意的一个结点。</p>
<p>② 使用一条边扩展这个树，要求这条边一个顶点在树中另一 个顶点不在树中，并且这条边的权值要求最小。</p>
<p>③ 重复步骤②直到所有顶点都在树中。</p>
<p>时间复杂度是 $O(n^2+m)$, $n$ 表示点数，$m$ 表示边数</p>
<h4 id="模板-7"><a href="#模板-7" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];        <span class="comment">// 邻接矩阵，存储所有边</span></span><br><span class="line"><span class="keyword">int</span> dist[N];        <span class="comment">// 存储其他点到当前最小生成树的距离</span></span><br><span class="line"><span class="keyword">bool</span> st[N];     <span class="comment">// 存储每个点是否已经在生成树中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))<span class="comment">//类似迪杰 找最小的方法</span></span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF;<span class="comment">//必须有2个点及以上  同时还要求dist[t] == INF 说明不是连通图</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i) res += dist[t];<span class="comment">//必须有2个点及以上总距离才有意义</span></span><br><span class="line">        st[t] = <span class="literal">true</span>;<span class="comment">//标记用过</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);<span class="comment">//用新加入的点更新dist</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="模板解析-4"><a href="#模板解析-4" class="headerlink" title="模板解析"></a>模板解析</h5><h5 id="Prim算法与Dijkstra算法的区别-dist数组含义不同"><a href="#Prim算法与Dijkstra算法的区别-dist数组含义不同" class="headerlink" title="Prim算法与Dijkstra算法的区别    dist数组含义不同"></a>Prim算法与Dijkstra算法的区别    dist数组含义不同</h5><p>Dijkstra算法是更新不在集合中的点 离起点的距离</p>
<p><em>dist[j]=min(dist[j], dist[t]+g[t][j])</em></p>
<p>Prim是更新不在集合中的点 离集合S的距离</p>
<p><em>dist[j] = min(dist[j], g[t][j])</em></p>
<p>内部过程  每次都找离集合最近点 然后加入</p>
<p><img src="/2022/01/08/basicACML3/3.2.2h.png" alt></p>
<p><img src="/2022/01/08/basicACML3/3.2.2i.png" alt></p>
<p><img src="/2022/01/08/basicACML3/3.2.2j.png" alt></p>
<h4 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h4><p><img src="/2022/01/08/basicACML3/3.2.2k.png" alt></p>
<h4 id="例题-Prim算法求最小生成树"><a href="#例题-Prim算法求最小生成树" class="headerlink" title="例题   Prim算法求最小生成树"></a>例题   Prim算法求最小生成树</h4><p>给定一个 $n$个点 $m$条边的无向图，图中可能存在重边和自环，边权可能为负数。</p>
<p>求最小生成树的树边权重之和，如果最小生成树不存在则输出 <em>impossible</em>。</p>
<p>给定一张边带权的无向图 $G=(V,E)$，其中 $V$ 表示图中点的集合，$E$ 表示图中边的集合，$n=|V|$，$m=|E|$。</p>
<p>由 $V$  中的全部  $n$个顶点和 $E$ 中  $n-1$ 条边构成的无向连通子图被称为$ G$ 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 $G$的最小生成树。</p>
<h4 id="输入格式-13"><a href="#输入格式-13" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 $n$和 $m$。</p>
<p>接下来 $m$ 行，每行包含三个整数 $u,v,w$，表示点 $u$ 和点 $v$ 之间存在一条权值为 $w$ 的边。</p>
<h4 id="输出格式-13"><a href="#输出格式-13" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 <em>impossible</em>。</p>
<h4 id="数据范围-12"><a href="#数据范围-12" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤n≤500$,<br>$1≤m≤10^5$,<br>图中涉及边的边权的绝对值均不超过 $10000$。</p>
<h4 id="输入样例：-11"><a href="#输入样例：-11" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2 1</span><br><span class="line">1 3 2</span><br><span class="line">1 4 3</span><br><span class="line">2 3 2</span><br><span class="line">3 4 4</span><br></pre></td></tr></table></figure>
<h4 id="输出样例：-11"><a href="#输出样例：-11" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>
<h5 id="参考代码-9"><a href="#参考代码-9" class="headerlink" title="参考代码"></a>参考代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> st[N];</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;=n ; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(st[j]==<span class="number">0</span>&amp;&amp;(t==<span class="number">-1</span>||dist[t]&gt;dist[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                t=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;&amp;dist[t]==<span class="number">0x3f3f3f3f</span>)<span class="keyword">return</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">if</span>(i)res+=dist[t];</span><br><span class="line">        st[t]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[j]= <span class="built_in">min</span>(dist[j],g[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,t;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;t;</span><br><span class="line">        g[x][y]=g[y][x]= <span class="built_in">min</span>(g[x][y],t);<span class="comment">//重边取最小的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="built_in">prim</span>();</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">0x3f3f3f3f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="跟模板一样"><a href="#跟模板一样" class="headerlink" title="跟模板一样"></a>跟模板一样</h5><h3 id="3-4-2-Kruskal算法"><a href="#3-4-2-Kruskal算法" class="headerlink" title="3.4.2  Kruskal算法"></a>3.4.2  Kruskal算法</h3><p>Kruskal 算法是能够在O(mlogm) 的时间内得到一个最小生成树的算 法。它主要是基于贪心的思想：</p>
<p>① 将边按照边权从小到大排序，并建立一个没有边的图T。</p>
<p>② 选出一条没有被选过的边权最小的边。</p>
<p>③ 如果这条边两个顶点在T 中所在的连通块不相同，那么将 它加入图T， 相同就跳过。（即加入这条边后出现回路，说明不能加它）</p>
<p>④ 重复②和③直到图T 连通为止。<br>其实这里只需要维护连通性，可以不需要真正建立图T，还可以用并查集 来维护。</p>
<h4 id="模板-8"><a href="#模板-8" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;       <span class="comment">// n是点数，m是边数</span></span><br><span class="line"><span class="keyword">int</span> p[N];       <span class="comment">// 并查集的父节点数组</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>     // 存储边</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Edge &amp;W)<span class="keyword">const</span><span class="comment">//重载小于运算符</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;<span class="comment">//按权重  从小到大排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>     <span class="comment">// 并查集核心操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);<span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="comment">// 初始化并查集</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)     <span class="comment">// 如果两个连通块不连通，则将这两个连通块合并</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;<span class="comment">//记录总权重</span></span><br><span class="line">            cnt ++ ;<span class="comment">//记录生成树中包含点的个数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模板解析-5"><a href="#模板解析-5" class="headerlink" title="模板解析"></a>模板解析</h4><p>先按权重给每条边排序，每次选择最小且加入不会产生回路的边</p>
<p><img src="/2022/01/08/basicACML3/1.png" alt></p>
<p><img src="/2022/01/08/basicACML3/2.png" alt></p>
<p><img src="/2022/01/08/basicACML3/3.png" alt></p>
<p><img src="/2022/01/08/basicACML3/4.png" alt></p>
<p><img src="/2022/01/08/basicACML3/5.png" alt></p>
<p><img src="/2022/01/08/basicACML3/6.png" alt></p>
<h4 id="例题-Kruskal算法求最小生成树"><a href="#例题-Kruskal算法求最小生成树" class="headerlink" title="例题   Kruskal算法求最小生成树"></a>例题   Kruskal算法求最小生成树</h4><p>给定一个 $n$ 个点 $m$ 条边的无向图，图中可能存在重边和自环，边权可能为负数。</p>
<p>求最小生成树的树边权重之和，如果最小生成树不存在则输出 <em>impossible</em>。</p>
<p>给定一张边带权的无向图 $G=(V,E)$，其中 $V$ 表示图中点的集合，$E$ 表示图中边的集合，$n=|V|，m=|E|$。</p>
<p>由 $V$ 中的全部 $n$ 个顶点和 $E$ 中$n−1 $条边构成的无向连通子图被称为 $G$ 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 $G$ 的最小生成树。</p>
<h5 id="输入格式-14"><a href="#输入格式-14" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含两个整数 $n$和 $m$。</p>
<p>接下来 $m$ 行，每行包含三个整数 $u,v,w$，表示点 $u$ 和点 $v$ 之间存在一条权值为 $w$ 的边。</p>
<h5 id="输出格式-14"><a href="#输出格式-14" class="headerlink" title="输出格式"></a>输出格式</h5><p>共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 <em>impossible</em>。</p>
<h5 id="数据范围-13"><a href="#数据范围-13" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n≤10^5$,<br>$1≤m≤2∗10^5$,<br>图中涉及边的边权的绝对值均不超过 $1000$。</p>
<h5 id="输入样例：-12"><a href="#输入样例：-12" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2 1</span><br><span class="line">1 3 2</span><br><span class="line">1 4 3</span><br><span class="line">2 3 2</span><br><span class="line">3 4 4</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-12"><a href="#输出样例：-12" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>
<h5 id="参考代码-10"><a href="#参考代码-10" class="headerlink" title="参考代码"></a>参考代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>,M=<span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(struct edge x)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;x.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x)p[x]= <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruka</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(e,e+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)p[i]=i;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=e[i].a,b=e[i].b,w=e[i].w;</span><br><span class="line">        <span class="keyword">int</span> x= <span class="built_in">find</span>(a),y=<span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(x!=y)</span><br><span class="line">        &#123;</span><br><span class="line">            p[x]=y;</span><br><span class="line">            res+=w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt&lt;n<span class="number">-1</span>)<span class="keyword">return</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,t;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;t;</span><br><span class="line">        e[i].a=x;</span><br><span class="line">        e[i].b=y;</span><br><span class="line">        e[i].w=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="built_in">kruka</span>();</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">0x3f3f3f3f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="跟模板相同"><a href="#跟模板相同" class="headerlink" title="跟模板相同"></a>跟模板相同</h5><h2 id="3-5-二分图：染色法、匈牙利算法"><a href="#3-5-二分图：染色法、匈牙利算法" class="headerlink" title="3.5 二分图：染色法、匈牙利算法"></a>3.5 二分图：染色法、匈牙利算法</h2><h3 id="3-5-1-染色法判别二分图"><a href="#3-5-1-染色法判别二分图" class="headerlink" title="3.5.1  染色法判别二分图"></a>3.5.1  染色法判别二分图</h3><p>时间复杂度是 $O(n+m)$, $n$ 表示点数，$m$ 表示边数</p>
<p>将所有点分成两个集合，使得所有边只出现在集合之间，就是二分图</p>
<p>二分图当且仅当图中不含奇数环（环中边数是奇数）即一定不含有奇数环，可能包含长度为偶数的环， 不一定是连通图。</p>
<h4 id="模板-9"><a href="#模板-9" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="keyword">int</span> color[N];       <span class="comment">// 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数：u表示当前节点，c表示当前点的颜色</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])<span class="comment">//给与u相连的所有点 染色</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (color[j] == <span class="number">-1</span>)<span class="comment">//j点没有染色</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, !c)) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//必须染不同的颜色 即!c</span></span><br><span class="line">            <span class="comment">//同时若该点染色失败返回 false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//相邻两点 染色相同</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(color, <span class="number">-1</span>, <span class="keyword">sizeof</span> color);</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )<span class="comment">//有可能不是连通图，一次深搜可能搜不到</span></span><br><span class="line">        <span class="keyword">if</span> (color[i] == <span class="number">-1</span>)<span class="comment">//如果没染色</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">0</span>))<span class="comment">//如果染色失败</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模板解析-6"><a href="#模板解析-6" class="headerlink" title="模板解析"></a>模板解析</h4><p>  代码思路：<br>     染色可以使用<em>1</em>和<em>0</em>区分不同颜色，用<em>-1</em>表示未染色<br>     遍历所有点，每次将未染色的点进行dfs, 默认染成<em>1</em>或者<em>0</em><br>     由于<strong>某个点染色成功不代表整个图就是二分图,</strong></p>
<p>​     因此只有某个点染色<strong>失败才能立刻  break/return</strong><br>​     <strong>染色失败</strong>相当于存在相邻的2个点染了相同的颜色</p>
<h4 id="例题-染色法判定二分图"><a href="#例题-染色法判定二分图" class="headerlink" title="例题  染色法判定二分图"></a>例题  染色法判定二分图</h4><p>给定一个 $n$ 个点 $m$ 条边的无向图，图中可能存在重边和自环。</p>
<p>请你判断这个图是否是二分图。</p>
<h5 id="输入格式-15"><a href="#输入格式-15" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含两个整数 $n$ 和 $m$。</p>
<p>接下来 $m$ 行，每行包含两个整数 $u$ 和 $v$，表示点 $u$ 和点 $v$ 之间存在一条边。</p>
<h5 id="输出格式-15"><a href="#输出格式-15" class="headerlink" title="输出格式"></a>输出格式</h5><p>如果给定图是二分图，则输出 <em>Yes</em>，否则输出 <em>No</em>。</p>
<h5 id="数据范围-14"><a href="#数据范围-14" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n,m≤10^5$</p>
<h5 id="输入样例：-13"><a href="#输入样例：-13" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 4</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure>
<h5 id="输出样例：-13"><a href="#输出样例：-13" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure>
<h5 id="参考代码-11"><a href="#参考代码-11" class="headerlink" title="参考代码"></a>参考代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>,M=<span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> color[N];</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;q[N];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;node;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(node start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; now,next;</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line">    q[++tt]=&#123;start.x,start.c&#125;;<span class="comment">//入队</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (hh&lt;=tt)<span class="comment">//当队不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        now=q[hh];<span class="comment">//取队头</span></span><br><span class="line">        hh++;<span class="comment">//弹出</span></span><br><span class="line">        <span class="keyword">int</span> ii=now.first,colo=now.second;<span class="comment">//编号 和 颜色种类</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[ii];i!=<span class="number">-1</span>;i=ne[i])<span class="comment">//遍历所有与 ii相连的点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(color[j]==<span class="number">-1</span>)<span class="comment">//未染色</span></span><br><span class="line">            &#123;</span><br><span class="line">                next.first=j;<span class="comment">//记录j</span></span><br><span class="line">                next.second=!colo;<span class="comment">//不同颜色</span></span><br><span class="line">                color[j]=!colo;<span class="comment">//记录已经染过颜色了</span></span><br><span class="line">                q[++tt]=(next);<span class="comment">//入队</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(color[j]==colo)<span class="comment">//染色矛盾</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(color,<span class="number">-1</span>,<span class="keyword">sizeof</span> color);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//目的同dfs</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(color[i]==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            node k&#123;i,<span class="number">0</span>&#125;;<span class="comment">//上来先染个 0（啥都行无所谓）</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">bfs</span>(k))<span class="comment">//有一个不成立就不行</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> t=<span class="built_in">check_</span>();</span><br><span class="line">    <span class="keyword">if</span>(t)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h5><p>由于数据量太大，所以要用bfs</p>
<p>bfs基本思想</p>
<p><img src="/2022/01/08/basicACML3/1111.png" alt></p>
<h3 id="3-4-2-匈牙利算法"><a href="#3-4-2-匈牙利算法" class="headerlink" title="3.4.2 匈牙利算法"></a>3.4.2 匈牙利算法</h3><p>时间复杂度是 $O(nm)$, $n$ 表示点数，$m$ 表示边数.</p>
<h4 id="模板-10"><a href="#模板-10" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n1, n2;     <span class="comment">// n1表示第一个集合中的点数，n2表示第二个集合中的点数</span></span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</span></span><br><span class="line"><span class="keyword">int</span> match[N];       <span class="comment">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</span></span><br><span class="line"><span class="keyword">bool</span> st[N];     <span class="comment">// 表示第二个集合中的每个点是否已经被遍历过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(i)) res ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例题-二分图的最大匹配"><a href="#例题-二分图的最大匹配" class="headerlink" title="例题  二分图的最大匹配"></a>例题  二分图的最大匹配</h4><p>给定一个二分图，其中左半部包含n~1~ 个点（编号 1∼n~1~），右半部包含 n~2~ 个点（编号 1∼n~2~），二分图共包含$ m$ 条边。</p>
<p>数据保证任意一条边的两个端点都不可能在同一部分中。</p>
<p>请你求出二分图的最大匹配数。</p>
<blockquote>
<p>二分图的匹配：给定一个二分图 $G$，在 $G$ 的一个子图 $M$ 中，$M$ 的边集 ${E}$ 中的任意两条边都不依附于同一个顶点，则称 $M$ 是一个匹配。</p>
<p>二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。</p>
</blockquote>
<h4 id="输入格式-16"><a href="#输入格式-16" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含三个整数 n~1~、 n~2~ 和 $m$。</p>
<p>接下来 $m$ 行，每行包含两个整数 $u$ 和 $v$，表示左半部点集中的点 $u$ 和右半部点集中的点 $v$ 之间存在一条边。</p>
<h4 id="输出格式-16"><a href="#输出格式-16" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示二分图的最大匹配数。</p>
<h4 id="数据范围-15"><a href="#数据范围-15" class="headerlink" title="数据范围"></a>数据范围</h4><p><strong>1≤n~1~,n~2~≤500,</strong><br><strong>1≤u≤n~1~,</strong><br><strong>1≤v≤n~2~,</strong><br>$1≤m≤10^5$</p>
<h4 id="输入样例：-14"><a href="#输入样例：-14" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 2 4</span><br><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure>
<h4 id="输出样例：-14"><a href="#输出样例：-14" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h5 id="参考代码-12"><a href="#参考代码-12" class="headerlink" title="参考代码"></a>参考代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n1,n2,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>,M=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> match[N];  <span class="comment">//match[j]=a,表示女孩j的现有配对男友是a</span></span><br><span class="line"><span class="keyword">bool</span> st[N];<span class="comment">// st[a] = true 说明女生 a 目前被一个男生预定了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[k];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[j])<span class="comment">//女生还没有男友</span></span><br><span class="line">        &#123;</span><br><span class="line">            st[j]= <span class="literal">true</span>;<span class="comment">//那k就预定这个女孩了</span></span><br><span class="line">            <span class="keyword">if</span>(match[j]==<span class="number">0</span>|| <span class="built_in">find_</span>(match[j]))</span><br><span class="line">                <span class="comment">//如果女孩j没有男朋友，或者她原来的男朋友能够换一个喜欢的女孩。配对成功,更新match</span></span><br><span class="line">            &#123;</span><br><span class="line">                match[j]=k;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//自己中意的全部都被预定了。配对失败。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n1&gt;&gt;n2&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n1;i++)<span class="comment">// 尝试为每个男生做一轮深搜找对象（成功后总匹配数增加1）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st,<span class="literal">false</span>,<span class="keyword">sizeof</span> st);<span class="comment">//每次都覆盖即每次都考虑全体女生 即使她们有男友</span></span><br><span class="line">        <span class="comment">//因为即使有男友你可以换嘛，所以你不能不考虑 match是记录 st代表目前考虑不考虑</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find_</span>(i))res++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="代码解析-1"><a href="#代码解析-1" class="headerlink" title="代码解析"></a>代码解析</h5><p>二分图的匹配 不存在2条边共用一个点</p>
<p>男生是左边 n~1~点们  女生是右面 n~2~点们</p>
<p>类比成恋爱中的男女 并且不能脚踏多条船</p>
<p><img src="/2022/01/08/basicACML3/2212.png" alt></p>
<h1 id="谢谢大家"><a href="#谢谢大家" class="headerlink" title="谢谢大家"></a>谢谢大家</h1>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>npuCS 第五讲 动态规划</title>
    <url>/2022/01/08/basicACML5/</url>
    <content><![CDATA[<h1 id="第五讲-动态规划"><a href="#第五讲-动态规划" class="headerlink" title="第五讲 动态规划"></a>第五讲 动态规划</h1><h2 id="5-0-动态规划问题的分析方法"><a href="#5-0-动态规划问题的分析方法" class="headerlink" title="5.0 动态规划问题的分析方法"></a>5.0 动态规划问题的分析方法</h2><p>满足以下三点： </p>
<p><strong>1</strong>、具有相同子问题：首先，我们必须要保证这个问题能够分解出几个子问题，并且能够通过这些子问题来解决这个问题。 </p>
<p><strong>2</strong>、满足最优化原理（最优子结构） 一个最优决策的子决策也是最优的。 </p>
<p><strong>3</strong>、具有无后效性：这是动态规划中极为重要的一点（也是有可能被考察的一点），它要求每一个问题的决策，不能够对解决其它未来的问题产生影响，如果产生影响，就无法保证决策的最优性，这就是无后效性。往往这需要我们找到一个合适状态</p>
<h2 id="5-1-背包问题"><a href="#5-1-背包问题" class="headerlink" title="5.1 背包问题"></a>5.1 背包问题</h2><h3 id="5-1-1-01背包"><a href="#5-1-1-01背包" class="headerlink" title="5.1.1 01背包"></a>5.1.1 01背包</h3><h4 id="1-原理讲解"><a href="#1-原理讲解" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><p>01背包满足的几个条件：</p>
<ol>
<li>$N$个物品，背包容量为$V$，每一件物品体积为$v_i$，价值为$w_i$</li>
<li>每件物品<strong>只能用一次</strong></li>
</ol>
<p><img src="https://gitee.com/chzarles/images/raw/master/imgs/006eb5E0gy1g7yngle1hpj31510lu407.jpg" alt="image.png"></p>
<h4 id="2-模板-amp-例题"><a href="#2-模板-amp-例题" class="headerlink" title="2. 模板&amp;例题"></a>2. 模板&amp;例题</h4><h5 id="例-5-1-1"><a href="#例-5-1-1" class="headerlink" title="例 5.1.1"></a>例 5.1.1</h5><p><strong>题目描述</strong></p>
<p>有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。</p>
<p>第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包的容量，且总价值最大，输出最大价值。</p>
<p><strong>输入格式</strong></p>
<p>第一行两个整数，$N$，$V$，用空格隔开，分别表示物品数量和背包容积。接下来有 $N$ 行，每行两个整数 $v_i, w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数，表示最大价值。</p>
<p><strong>数据范围</strong></p>
<p>$0&lt;N,V\leq1000$</p>
<p>$0&lt;v_i,w_i\leq1000$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>
<p>题解：</p>
<p><strong>二维版本：</strong></p>
<p>（1）状态$f[i][j]$定义：前 $i$ 个物品，背包容量 $j$ 下的最优解（最大价值）：</p>
<p>当前的状态依赖于之前的状态，可以理解为从初始状态$f[0][0] = 0$开始决策，有 $N$ 件物品，则需要 $N$ 次决策，每一次对第 $i$ 件物品的决策，状态$f[i][j]$不断由之前的状态更新而来。</p>
<p>（2）当前背包容量不够（$j &lt; v[i]$），没得选，因此前 $i$ 个物品最优解即为前 $i−1$ 个物品最优解：</p>
<p>对应代码：$f[i][j] = f[i - 1][j]$。</p>
<p>（3）当前背包容量够，可以选，因此需要决策选与不选第 $i$ 个物品：</p>
<p>选：$f[i][j] = f[i - 1][j - v[i]] + w[i]$​。</p>
<p>不选：$f[i][j] = f[i - 1][j]$ 。</p>
<p>我们的决策是如何取到最大价值，因此以上两种情况取 $\max()$​。</p>
<p>基于以上思路，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> v[MAXN];    <span class="comment">// 体积</span></span><br><span class="line"><span class="keyword">int</span> w[MAXN];    <span class="comment">// 价值 </span></span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN];  <span class="comment">// f[i][j], j体积下前i个物品的最大价值 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;   </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  当前背包容量装不进第i个物品，则价值等于前i-1个物品</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; v[i]) </span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="comment">// 能装，需进行决策是否选择第i个物品</span></span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        &#125;           </span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>一维版本：</strong></p>
<p>将状态$f[i][j]$优化到一维$f[j]$，实际上只需要做一个等价变形。</p>
<p>为什么可以这样变形呢？我们定义的状态$f[i][j]$可以求得任意合法的$i$与$j$最优解，但题目只需要求得最终状态$f[n][m]$，因此我们只需要一维的空间来更新状态。</p>
<p>（1）状态$f[j]$定义：$N$ 件物品，背包容量$j$下的最优解。</p>
<p>（2）注意枚举背包容量$j$必须从$m$开始。</p>
<p>（3）为什么一维情况下枚举背包容量需要逆序？在二维情况下，状态$f[i][j]$是由上一轮$i - 1$的状态得来的，$f[i][j]$与$f[i - 1][j]$是独立的。而优化到一维后，如果我们还是正序，则有$f[较小体积]$更新到$f[较大体积]$，则有可能本应该用第$i-1$轮的状态却用的是第$i$轮的状态。</p>
<p>（4）例如，一维状态第$i$轮对体积为 $3$ 的物品进行决策，则$f[7]$由$f[4]$更新而来，这里的$f[4]$正确应该是$f[i - 1][4]$，但从小到大枚举j这里的$f[4]$在第i轮计算却变成了$f[i][4]$。当逆序枚举背包容量$j$时，我们求$f[7]$同样由$f[4]$更新，但由于是逆序，这里的$f[4]$还没有在第$i$轮计算，所以此时实际计算的$f[4]$仍然是$f[i - 1][4]$。</p>
<p>（5）简单来说，一维情况正序更新状态$f[j]$需要用到前面计算的状态已经被「污染」，逆序则不会有这样的问题。</p>
<p>状态转移方程为：$f[j] = max(f[j], f[j - v[i]] + w[i])$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">状态转移方程为：f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i] 。</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; v[i]) </span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];  <span class="comment">// 优化前</span></span><br><span class="line">            f[j] = f[j];            <span class="comment">// 优化后，该行自动成立，可省略。</span></span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);  <span class="comment">// 优化前</span></span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);                   <span class="comment">// 优化后</span></span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></figure>
<p>实际上，只有当枚举的背包容量 $&gt;= v[i]$ 时才会更新状态，因此我们可以修改循环终止条件进一步优化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= v[i]; j--)  </span><br><span class="line">        f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>关于状态$f[j]$的补充说明</p>
<p>二维下的状态定义$f[i][j]$是前 $i$ 件物品，背包容量 $j$ 下的最大价值。一维下，少了前 $i$ 件物品这个维度，我们的代码中决策到第 $i$ 件物品（循环到第$i$轮），$f[j]$就是前i轮已经决策的物品且背包容量 $j$ 下的最大价值。</p>
<p>因此当执行完循环结构后，由于已经决策了所有物品，$f[j]$就是所有物品背包容量 $j$ 下的最大价值。即一维$f[j]$等价于二维$f[n][j]$。</p>
<p><strong>输入优化</strong></p>
<p>我们注意到在处理数据时，我们是一个物品一个物品，一个一个体积的枚举。</p>
<p>因此我们可以不必开两个数组记录体积和价值，而是边输入边处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> f[MAXN];  <span class="comment">// </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;   </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v, w;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w;      <span class="comment">// 边输入边处理</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= v; j--)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v] + w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>标程</strong></p>
<p>二维写法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> v[N], w[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">			<span class="keyword">if</span>(j &gt;= v[i]) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">		&#125;</span><br><span class="line"> 	cout &lt;&lt; f[n][m] &lt;&lt;endl;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>降维</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> v[N], w[N];</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= v[i]; j--)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-1-2-完全背包"><a href="#5-1-2-完全背包" class="headerlink" title="5.1.2 完全背包"></a>5.1.2 完全背包</h3><h4 id="1-原理讲解-1"><a href="#1-原理讲解-1" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><p>完全背包满足的几个条件：</p>
<ol>
<li>$N$个物品，背包容量为$V$，每一件物品体积为$v_i$，价值为$w_i$</li>
<li>每件物品<strong>可以重复挑选，使用无数次</strong></li>
</ol>
<p><img src="https://gitee.com/chzarles/images/raw/master/imgs/006eb5E0gy1g7yyd0jjcyj30wk0fpdhc.jpg" alt="image.png"></p>
<h4 id="2-模板-amp-例题-1"><a href="#2-模板-amp-例题-1" class="headerlink" title="2. 模板&amp;例题"></a>2. 模板&amp;例题</h4><h5 id="例-5-1-2"><a href="#例-5-1-2" class="headerlink" title="例 5.1.2"></a>例 5.1.2</h5><p><strong>题目描述</strong></p>
<p>有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品都有无限件可用。</p>
<p>第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包的容量，且总价值最大，输出最大价值。</p>
<p><strong>输入格式</strong></p>
<p>第一行两个整数，$N$，$V$，用空格隔开，分别表示物品数量和背包容积。接下来有 $N$ 行，每行两个整数 $v_i, w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数，表示最大价值。</p>
<p><strong>数据范围</strong></p>
<p>$0&lt;N,V\leq1000$</p>
<p>$0&lt;v_i,w_i\leq1000$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<p><strong>暴力做法$O(n^3)$</strong></p>
<p>本题数据加强后会<em>TLE</em>，主要理解思路即可。</p>
<p>状态$f[i][j]$​定义（同5.1.1「01背包问题」）：前 $i$​ 个物品，背包容量 $j$​ 下的最优解（最大价值）。<br>每一轮循环 $i$​ 都可以看作是对第 $i$​ 件物品的决策——选择多少个（范围 $0 \to ⌊\frac{j}{v}⌋$​​）第 $i$ 件物品。</p>
<p>稍微不同的是多重背包允许多次选择一个物品，所以计算状态方程时需要枚举选择第  $i$  个物品</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> v[MAXN];    <span class="comment">// 体积 </span></span><br><span class="line"><span class="keyword">int</span> w[MAXN];    <span class="comment">// 价值 </span></span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN];  <span class="comment">// f[i][j], j体积下前i个物品的最大价值 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> m;  <span class="comment">// 背包体积 </span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> amount = j / v[i];  <span class="comment">// j体积时物品最多能选的次数    </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= amount; k++) <span class="comment">// 枚举选择第i个物品的个数</span></span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - k * v[i]] + k * w[i]);   <span class="comment">// 状态转移方程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间优化$O(n^2)$</strong></p>
<p>实际上，我们在计算状态方程时不必多一个循环去单独枚举选择第 $i$ 个物品个数。</p>
<p>状态转移方程推导如下：</p>
<script type="math/tex; mode=display">
f[i][j] = \max(f[i - 1][j], f[i - 1][j - v] + w, f[i - 1][j -2v] +2w, \cdots,f[i-1][j - ⌊\frac{j}{v}⌋*v+ ⌊\frac{j}{v}⌋*w])</script><p>上述方程可以这样理解：我们计算的是前 $i$ 个物品 $j$ 体积的最优解$f[i][j]$ ，而前 $i−1$ 个物品的最优解 $f[i−1][j]$ 在上一轮循环中都已计算完毕，现在我们只需判断选择几个第 $i$ 种物品得到的价值最大。</p>
<p>我们改变一下变量，将 $j$ 变成 $j−v$，则有：</p>
<script type="math/tex; mode=display">
f[i][j-v] = \max(f[i-1][j-v],f[i-1][j-2v]+w,\cdots,f[i-1][j - ⌊\frac{j}{v}⌋*v+ ⌊\frac{j}{v}⌋*w])</script><p>由以上两个式子就可以得到状态转移方程：</p>
<script type="math/tex; mode=display">
f[i][j] = \max(f[i-1][j],f[i][j-v]+w)</script><p>我们枚举体积$j$ 是从小到大的，那么我们在计算 $f[i][j]$ 时，$f[i][较大体积]$总是由$f[i][较小体积]$​更新而来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> v[MAXN];    <span class="comment">// 体积 </span></span><br><span class="line"><span class="keyword">int</span> w[MAXN];    <span class="comment">// 价值 </span></span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN];  <span class="comment">// f[i][j], j体积下前i个物品的最大价值 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> m;  <span class="comment">// 背包体积 </span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) </span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];  <span class="comment">// 不选第i个物品</span></span><br><span class="line">            <span class="keyword">if</span>(j &gt;= v[i])           <span class="comment">// 可以选择第i个物品，状态方程见上面推导    </span></span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化到一维</strong></p>
<p>状态转移方程：$f[j] = max(f[j], f[j - v[i]] + w[i])$​</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> v[MAXN];    <span class="comment">// 体积 </span></span><br><span class="line"><span class="keyword">int</span> w[MAXN];    <span class="comment">// 价值 </span></span><br><span class="line"><span class="keyword">int</span> f[MAXN];    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> m;  <span class="comment">// 背包体积 </span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = v[i]; j &lt;= m; j++)  </span><br><span class="line">        &#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>调整输入</strong></p>
<p>我们注意到在处理数据时，我们是一个物品一个物品，一个一个单位体积进行枚举。</p>
<p>因此可以不必开两个数组记录体积和价值，而是边输入边处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> f[MAXN];    <span class="comment">// f[i][j], j体积下前i个物品的最大价值 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> m;  <span class="comment">// 背包体积 </span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v, w;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = v; j &lt;= m; j++) &#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v] + w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>标程</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> v[N], w[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k * v[i] &lt;= j; k++)</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - v[i] * k] + w[i] * k);</span><br><span class="line">                </span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>降维：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> v[N], w[N];</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = v[i]; j &lt;= m; j++)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-1-3-多重背包"><a href="#5-1-3-多重背包" class="headerlink" title="5.1.3 多重背包"></a>5.1.3 多重背包</h3><h4 id="1-原理讲解-2"><a href="#1-原理讲解-2" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><p>多重背包满足的几个条件：</p>
<ol>
<li>$N$个物品，背包容量为$V$，每一件物品体积为$v_i$，价值为$w_i$，个数$s_i$</li>
<li>每件物品<strong>可以重复挑选，使用有限次</strong></li>
</ol>
<h4 id="2-模板-amp-例题-2"><a href="#2-模板-amp-例题-2" class="headerlink" title="2. 模板&amp;例题"></a>2. 模板&amp;例题</h4><h5 id="例-5-1-3"><a href="#例-5-1-3" class="headerlink" title="例 5.1.3"></a>例 5.1.3</h5><p><strong>题目描述</strong></p>
<p>有 $N$ 件物品和一个容量是 $V$ 的背包。</p>
<p>第 $i$ 件物品最多有 $s_i$ 件，每件的体积是 $v_i$，价值是 $w_i$。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包的容量，且总价值最大，输出最大价值。</p>
<p><strong>输入格式</strong></p>
<p>第一行两个整数，$N$，$V$，用空格隔开，分别表示物品数量和背包容积。接下来有 $N$ 行，每行三个整数 $v_i, w_i, s_i$，用空格隔开，分别表示第 $i$ 件物品的体积、价值和数量。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数，表示最大价值。</p>
<p><strong>数据范围</strong></p>
<p>$0&lt;N\leq1000$</p>
<p>$0&lt;V\leq2000$</p>
<p>$0&lt;v_i,w_i,s_i\leq2000$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2 3</span><br><span class="line">2 4 1</span><br><span class="line">3 4 3</span><br><span class="line">4 5 2</span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<p>题解：</p>
<p>多重背包只是在完全背包上加了一些限制</p>
<p>每个物品的选择次数有了限制，所以只需要在循环次数的时候加个判断条件$k&lt;=s[i]$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N][N],v[N],w[N],s[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;s[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k*v[i]&lt;=j&amp;&amp;k&lt;=s[i];k++)</span><br><span class="line">                f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-k*v[i]]+k*w[i]);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;f[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>用二进制优化</strong></p>
<p>首先，我们不能用完全背包的优化思路来优化这个问题，因为每组的物品的个数都不一样，是不能像之前一样推导不优化递推关系的。</p>
<p>接下来，我介绍一个二进制优化的方法，假设有一组商品，一共有$11$个。我们知道，十进制数字 $11$ 可以这样表示：</p>
<script type="math/tex; mode=display">
11=1011(B)=0111(B)+(11−0111(B))=0111(B)+0100(B)</script><p>正常背包的思路下，我们要求出含这组商品的最优解，我们要枚举$12$次（枚举装$0，1，2….12$个）。</p>
<p>现在，如果我们把这$11$个商品分别打包成含商品个数为$1$个，$2$个，$4$个，$4$个（分别对应$0001$,$0010$,$0100$,$0100$）的四个”新的商品 “, 将问题转化为01背包问题，对于每个商品，我们都只枚举一次，那么我们只需要枚举四次 ，就可以找出这含组商品的最优解。 这样就大大减少了枚举次数。</p>
<p>这种优化对于大数尤其明显，例如有$1024$个商品，在正常情况下要枚举$1025$次 ， 二进制思想下转化成01背包只需要枚举$10$次。</p>
<p>优化合理性证明：</p>
<p>先讲结论：上面的$1$，$2$，$4$，$4$是可以通过组合来表示出$0\to11$中任何一个数的，还是拿$11$证明一下（举例一下）：</p>
<p>首先，11可以这样分成两个二进制数的组合：</p>
<script type="math/tex; mode=display">
11=1011(B)=0111(B)+(11−0111(B))=0111(B)+0100(B)</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">12010</span>, M = <span class="number">2010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> v[N], w[N]; <span class="comment">//逐一枚举最大是N*logS</span></span><br><span class="line"><span class="keyword">int</span> f[M]; <span class="comment">// 体积&lt;M</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">//分组的组别</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,s;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>; <span class="comment">// 组别里面的个数</span></span><br><span class="line">        <span class="keyword">while</span>(k&lt;=s)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++ ; <span class="comment">//组别先增加</span></span><br><span class="line">            v[cnt] = a * k ; <span class="comment">//整体体积</span></span><br><span class="line">            w[cnt] = b * k; <span class="comment">// 整体价值</span></span><br><span class="line">            s -= k; <span class="comment">// s要减小</span></span><br><span class="line">            k *= <span class="number">2</span>; <span class="comment">// 组别里的个数增加</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//剩余的一组</span></span><br><span class="line">        <span class="keyword">if</span>(s&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">            v[cnt] = a*s; </span><br><span class="line">            w[cnt] = b*s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = cnt ; <span class="comment">//枚举次数正式由个数变成组别数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//01背包一维优化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n ;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m ;j &gt;= v[i];j --)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j],f[j-v[i]] + w[i]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>标程</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">25000</span>, M = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> v[N], w[N];</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, s;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt;= s)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            v[cnt] = a * k;</span><br><span class="line">            w[cnt] = b * k;</span><br><span class="line">            s -= k;</span><br><span class="line">            k *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            v[cnt] = a * s;</span><br><span class="line">            w[cnt] = b * s;</span><br><span class="line">        &#125;</span><br><span class="line">        n = cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        	<span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= v[i]; j--)</span><br><span class="line">            	f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    	cout &lt;&lt; f[m] &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-1-4-分组背包"><a href="#5-1-4-分组背包" class="headerlink" title="5.1.4 分组背包"></a>5.1.4 分组背包</h3><h4 id="1-原理讲解-3"><a href="#1-原理讲解-3" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h4><p><img src="https://cdn.acwing.com/media/article/image/2019/08/06/1606_ecd551d6b7-%E6%8D%95%E8%8E%B7.PNG" alt="捕获.PNG"></p>
<h4 id="2-模板-amp-例题-3"><a href="#2-模板-amp-例题-3" class="headerlink" title="2. 模板&amp;例题"></a>2. 模板&amp;例题</h4><h5 id="例-5-1-4"><a href="#例-5-1-4" class="headerlink" title="例 5.1.4"></a>例 5.1.4</h5><p><strong>题目描述</strong></p>
<p>有 $N$ 组物品和一个容量是 $V$ 的背包。</p>
<p>每组物品有若干个，同一组内的物品最多只能选一个。</p>
<p>每件物品的体积是 $v_{ij}$，价值是 $w_{ij}$，其中 $i$ 是组号，$j$ 是组内编号。</p>
<p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p>
<p>输出最大价值。</p>
<p><strong>输入格式</strong></p>
<p>第一行两个整数，$N$，$V$，用空格隔开，分别表示物品组数和背包容积。</p>
<p>接下来有 $N$ 组数据：</p>
<ul>
<li>每组数据第一行有一个整数 $S_i$，表示第 $i$ 个物品组的物品数量；</li>
<li>每组数据接下来有 $S_i$ 行，每行有两个整数 $v_{ij}, w_{ij}$，用空格隔开，分别表示第 $i$ 个物品组的第 $j$ 个物品的体积和价值。</li>
</ul>
<p><strong>输出格式</strong></p>
<p>输出一个整数，表示最大价值。</p>
<p><strong>数据范围</strong></p>
<p>$0&lt;N, V\leq100$</p>
<p>$0&lt;S_i\leq100$</p>
<p>$0&lt;v_i,w_i,s_i\leq100$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 5</span><br><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">1</span><br><span class="line">3 4</span><br><span class="line">1</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>
<p>类似01背包</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="keyword">int</span> v[N][N], w[N][N], s[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        cin &gt;&gt; s[i];<span class="comment">//第i组物品的数量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s[i]; j ++)&#123;<span class="comment">//依次读入第i组第j个物品的体积和价值</span></span><br><span class="line">            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)&#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];<span class="comment">//第i组物品一个都不选</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= s[i]; k ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= v[i][k])&#123;</span><br><span class="line">                   f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - v[i][k]] + w[i][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后可以同01背包一样优化</p>
<p><strong>标程</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> v[N][N], w[N][N], s[N];</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s[i]; j++)</span><br><span class="line">        	cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; s[i]; k++)</span><br><span class="line">                <span class="keyword">if</span> (v[i][k] &lt;= j)</span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-2-线性DP"><a href="#5-2-线性DP" class="headerlink" title="5.2 线性DP"></a>5.2 线性DP</h2><h3 id="1-原理讲解-4"><a href="#1-原理讲解-4" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h3><h3 id="2-经典例题"><a href="#2-经典例题" class="headerlink" title="2. 经典例题"></a>2. 经典例题</h3><h5 id="例-5-2-1-数字三角形"><a href="#例-5-2-1-数字三角形" class="headerlink" title="例 5.2.1 数字三角形"></a>例 5.2.1 数字三角形</h5><p><strong>题目描述</strong></p>
<p>给定一个形如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        7</span><br><span class="line">      3   8</span><br><span class="line">    8   1   0</span><br><span class="line">  2   7   4   4</span><br><span class="line">4   5   2   6   5</span><br></pre></td></tr></table></figure>
<p><strong>输入格式</strong></p>
<p>第一行包含整数 $n$，表示数字三角形的层数。</p>
<p>接下来 $n$ 行，每行包含若干整数，其中第 $i$ 行表示数字三角形第 $i$ 层包含的整数。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数，表示最大的路径数字和。</p>
<p><strong>数据范围</strong></p>
<p>$1\leq n\leq500$</p>
<p>$-10000\leq 三角形中的整数 \leq 10000$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">7</span><br><span class="line">3 8</span><br><span class="line">8 1 0 </span><br><span class="line">2 7 4 4</span><br><span class="line">4 5 2 6 5</span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">30</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p><strong>自上往下</strong></p>
<p>一、状态表示：$f[i][j]$</p>
<ol>
<li>集合：所有从顶点$(1, 1)$ 到$ (i, j)$的路径之和的方案</li>
<li>属性：最大值</li>
</ol>
<p>二、状态计算：</p>
<ol>
<li>思想——-集合的划分</li>
<li>集合划分依据：根据最后一步的来向, 即来自<strong>左上和来自右上</strong>两种.</li>
</ol>
<p>$f[i][j] = max(f[i - 1][j - 1] + a[i][j], f[i - 1][j] + a[i][j]);$//依次为左上、右上</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, INF = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N][N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f, INF, <span class="keyword">sizeof</span> f);<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j ++)&#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">1</span>];<span class="comment">//三角顶点为a[1][1]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j ++)&#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j]) + a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) res = <span class="built_in">max</span>(res, f[n][j]);<span class="comment">//遍历最后一层</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>自下往上</strong></p>
<p>一、状态表示：$f[i][j]$</p>
<ol>
<li>集合：所有从最后一层到顶点$(1, 1)$的路径之和的方案</li>
<li>属性：最大值</li>
</ol>
<p>二、状态计算：</p>
<ol>
<li>思想——-集合的划分</li>
<li>集合划分依据：根据最后一步的来向, 即来自左下和来自右下两种.</li>
</ol>
<p>$f[i][j] = max(f[i + 1][j] + a[i][j], f[i + 1][j + 1] + a[i][j]);$//依次为左下、右下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="keyword">int</span> a[N][N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j ++)&#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) f[n][j] = a[n][j];<span class="comment">//最后一层</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i --)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j ++)&#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i + <span class="number">1</span>][j], f[i + <span class="number">1</span>][j + <span class="number">1</span>]) + a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>标程</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N][N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= i; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i + <span class="number">1</span>; j++)</span><br><span class="line">            f[i][j] = -INF;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j], f[i - <span class="number">1</span>][j] + a[i][j]);</span><br><span class="line">    <span class="keyword">int</span> res = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res = <span class="built_in">max</span>(res, f[n][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="例-5-2-2-最长上升子序列"><a href="#例-5-2-2-最长上升子序列" class="headerlink" title="例 5.2.2 最长上升子序列"></a>例 5.2.2 最长上升子序列</h5><p><strong>题目描述</strong></p>
<p>给定一个长度为 $N$ 的数列，求数值严格单调递增的子序列的长度最长是多少。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含整数 $N$。</p>
<p>第二行包含 $N$ 个整数，表示完整序列。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数，表示最大长度。</p>
<p><strong>数据范围</strong></p>
<p>$1\leq N\leq1000$</p>
<p>$-10^9\leq 数列中的数\leq10^9$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">3 1 2 1 8 5 6</span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>(动态规划) $O(n^2)$</p>
<p>状态表示：$f[i]$表示从第一个数字开始算，以$w[i]$结尾的最大的上升序列。(以$w[i]$结尾的所有上升序列中属性为最大值的那一个)</p>
<p>状态计算（集合划分）：$j∈(0,1,2,..,i-1)$, 在$w[i] &gt; w[j]$时，$f[i] = max(f[i], f[j] + 1)$。</p>
<p>有一个边界，若前面没有比$i$小的，$f[i]$为$1$（自己为结尾）。</p>
<p>最后在找$f[i]$的最大值。</p>
<p>时间复杂度</p>
<p>$O(n^2)$ ：状态数($n$) * 转移数($n$​)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> w[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">1</span>;    <span class="comment">// 找出所计算的f[i]之中的最大值，边算边找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;    <span class="comment">// 设f[i]默认为1，找不到前面数字小于自己的时候就为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w[i] &gt; w[j]) f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);    <span class="comment">// 前一个小于自己的数结尾的最大上升子序列加上自己，即+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        mx = <span class="built_in">max</span>(mx, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; mx &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(动态规划 + 二分) $O(nlogn)$​</p>
<p>状态表示：$f[i]$表示长度为i的最长上升子序列，末尾最小的数字。(长度为i的最长上升子序列所有结尾中，结尾最小$\min$的) 即长度为$i$的子序列末尾最小元素是什么。</p>
<p>状态计算：对于每一个$w[i]$, 如果大于$f[cnt-1]$(下标从$0$开始，$cnt$长度的最长上升子序列，末尾最小的数字)，那就$cnt+1$，使得最长上升序列长度$+1$，当前末尾最小元素为$w[i]$。 若$w[i]$小于等于$f[cnt-1]$,说明不会更新当前的长度，但之前末尾的最小元素要发生变化，找到第一个 大于或等于 (这里不能是大于) $w[i]$，更新以那时候末尾的最小元素。</p>
<p>$f[i]$一定以一个单调递增的数组，所以可以用二分法来找第一个大于或等于$w[i]$的数字。</p>
<p>时间复杂度：$O(nlogn)$ 状态数($n$) * 转移数($logn$)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n, cnt;</span><br><span class="line"><span class="keyword">int</span> w[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n; i++) cin &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    f[cnt++] = w[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (w[i] &gt; f[cnt<span class="number">-1</span>]) f[cnt++] = w[i];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = cnt - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (f[mid] &gt;= w[i]) r = mid;</span><br><span class="line">                <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            f[r] = w[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>标程</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>; <span class="comment">// 只有a[i]一个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[i])</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;$d\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>思考</strong></p>
<p>如何输出该最长上升子序列？动态规划问题输出方案的一般方法是？</p>
<h5 id="例-5-2-3-最长公共子序列"><a href="#例-5-2-3-最长公共子序列" class="headerlink" title="例 5.2.3 最长公共子序列"></a>例 5.2.3 最长公共子序列</h5><p><strong>题目描述</strong></p>
<p>给定两个长度分别为 $N$ 和 $N$ 的字符串 $A$ 和 $B$，求既是 $A$ 的子序列又是 $B$ 的子序列的字符串长度最长是多少。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含两个整数 $N$ 和 $M$。</p>
<p>第二行包含一个长度为 $N$ 的字符串，表示字符串 $A$。</p>
<p>第三行包含一个长度为 $M$ 的字符串，表示字符串 $B$。</p>
<p>字符串均由小写字母构成。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数，表示最大长度。</p>
<p><strong>数据范围</strong></p>
<p>$1\leq N,M\leq1000$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">acbd</span><br><span class="line">abedc</span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>集合表示：$f[i][j]$表示$a$的前$i$个字母，和$b$的前$j$个字母的最长公共子序列长度</p>
<p>集合划分：以$a[i]$​,$b[j]$​是否包含在子序列当中为依据，因此可以分成四类：</p>
<p>①$a[i]$不在，$b[j]$不在</p>
<p>$max=f[i−1][j−1]$</p>
<p>②$a[i]$不在，$b[j]$在</p>
<p>看似是$\max=f[i−1][j]$ , 实际上无法用$f[i−1][j]$表示，因为$f[i−1][j]$表示的是在$a$的前$i-1$个字母中出现，并且在$b$的前$j$个字母中出现,此时$b[j]$不一定出现，这与条件不完全相等，条件给定是$a[i]$一定不在子序列中，$b[j]$一定在子序列当中，但仍可以用$f[i−1][j]$来表示，原因就在于条件给定的情况被包含在$f[i−1][j]$中，即条件的情况是$f[i−1][j]$的子集，而求的是$\max$，所以对结果不影响。</p>
<p>例如：要求$a$，$b$，$c$的最大值可以这样求：$\max(\max(a,b),\max(b,c))\max(\max(a,b),\max(b,c))$虽然$b$被重复使用，但仍能求出$\max$，求$\max$只要保证不漏即可。</p>
<p>③$a[i]$在，$b[j]$不在 原理同②</p>
<p>④$a[i]$在，$b[j]$在 $\max=f[i−1][j−1]+1$;</p>
<p>实际上，在计算时，①包含在②和③的情况中，所以①不用考虑</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="keyword">char</span> a[N] , b[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    cin &gt;&gt; a + <span class="number">1</span> &gt;&gt; b + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j] , f[i][j - <span class="number">1</span>]);<span class="comment">//②和③的情况一定存在，所以可以无条件优先判断</span></span><br><span class="line">                <span class="keyword">if</span>(a[i] == b[j]) f[i][j] = <span class="built_in">max</span>(f[i][j] , f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;                                                       </span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>标程</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[j]) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n][m]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-3-区间DP"><a href="#5-3-区间DP" class="headerlink" title="5.3 区间DP"></a>5.3 区间DP</h2><h3 id="1-原理讲解-5"><a href="#1-原理讲解-5" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h3><h3 id="2-经典例题-1"><a href="#2-经典例题-1" class="headerlink" title="2. 经典例题"></a>2. 经典例题</h3><h4 id="例-5-3-1-石子合并"><a href="#例-5-3-1-石子合并" class="headerlink" title="例 5.3.1 石子合并"></a>例 5.3.1 石子合并</h4><p><strong>题目描述</strong></p>
<p>设有 $N$ 堆石子排成一排，其编号为 $1, 2, 3, \ldots, N$。</p>
<p>每堆石子有一定的质量，可以用一个整数来描述，现在要将这 $N$ 堆石子合并成为一堆。</p>
<p>每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。</p>
<p>例如有 $4$ 堆石子分别为 <em>1 3 5 2</em>， 我们可以先合并 $1、2$ 堆，代价为 $4$，得到 <em>4 5 2</em>， 又合并 $1，2$ 堆，代价为 $9$，得到 <em>9 2</em> ，再合并得到 $11$，总代价为 $4+9+11=24$；</p>
<p>如果第二步是先合并 $2，3$ 堆，则代价为 $7$，得到 <em>4 7</em>，最后一次合并代价为 $11$，总代价为 $4+7+11=22$。</p>
<p>问题是：找出一种合理的方法，使总的代价最小，输出最小代价。</p>
<p><strong>输入格式</strong></p>
<p>第一行一个数 $N$ 表示石子的堆数 $N$。</p>
<p>第二行 $N$ 个数，表示每堆石子的质量(均不超过 $1000$)。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数，表示最小代价。</p>
<p><strong>数据范围</strong></p>
<p>$1\leq N \leq 300$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 3 5 2</span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">22</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>核心：最后一次合并一定是左边连续的一部分和右边连续的一部分进行合并</p>
<p>状态表示：$f[i][j]$​ 表示将 $i$​ 到 $j$​ 合并成一堆的方案的集合，属性 $\min$</p>
<p>状态计算：<br>(1) $i&lt;j$ 时，$f[i][j]=min_{i≤k≤j−1}f[i][k]+f[k+1][j]+s[j]−s[i−1]$<br>(2) $i=j$ 时， $f[i][i]=0$ （合并一堆石子代价为 0）</p>
<p>问题答案： $f[1][n]$</p>
<p><strong>区间 DP 常用模版</strong><br>所有的区间dp问题，第一维都是枚举区间长度，一般 $len = 1$ 用来初始化，枚举从 $len = 2$ 开始，第二维枚举起点 $i$ （右端点 j 自动获得，$j = i + len - 1$​​）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dp[i][i] = 初始值</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++)           <span class="comment">//区间长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++) &#123; <span class="comment">//枚举起点</span></span><br><span class="line">        <span class="keyword">int</span> j = i + len - <span class="number">1</span>;                 <span class="comment">//区间终点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; k++) &#123;        <span class="comment">//枚举分割点，构造状态转移方程</span></span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i][k] + dp[k + <span class="number">1</span>][j] + w[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>code</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">307</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], s[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        s[i] += s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区间 DP 枚举套路：长度+左端点 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt; n; len ++) &#123; <span class="comment">// len表示i和j堆下标的差值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + len &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + len; <span class="comment">// 自动得到右端点</span></span><br><span class="line">            f[i][j] = <span class="number">1e8</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j - <span class="number">1</span>; k ++) &#123; <span class="comment">// 必须满足k + 1 &lt;= j</span></span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i][j], f[i][k] + f[k + <span class="number">1</span>][j] + s[j] - s[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[<span class="number">1</span>][n] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了按长度枚举，也可以倒着枚举，因为只要保证每种状态都被提前计算即可</p>
<p>这里有图示，介绍枚举的顺序选择</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">307</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == i) &#123;</span><br><span class="line">                f[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            f[i][j] = <span class="number">1e9</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; k++) &#123;</span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i][j], f[i][k] + f[k + <span class="number">1</span>][j] + s[j] - s[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[<span class="number">1</span>][n] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果学过后面的记忆化搜索，那也可以用下面的代码。虽然时间会比递推稍微慢一丢丢，但是呢他的思路比较好写。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">307</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], s[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记忆化搜索：dp的记忆化递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == j) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 判断边界</span></span><br><span class="line">    <span class="keyword">int</span> &amp;v = f[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v != <span class="number">-1</span>) <span class="keyword">return</span> v;</span><br><span class="line"></span><br><span class="line">    v = <span class="number">1e8</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j - <span class="number">1</span>; k ++)</span><br><span class="line">        v = <span class="built_in">min</span>(v, <span class="built_in">dp</span>(i, k) + <span class="built_in">dp</span>(k + <span class="number">1</span>, j) + s[j] - s[i - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        s[i] += s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">dp</span>(<span class="number">1</span>, n) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>标程</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> s[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) s[i] += s[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> l = i, r = i + len - <span class="number">1</span>;</span><br><span class="line">            f[l][r] = <span class="number">1e8</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt; r; k ++ )</span><br><span class="line">                f[l][r] = <span class="built_in">min</span>(f[l][r], f[l][k] + f[k + <span class="number">1</span>][r] + s[r] - s[l - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[<span class="number">1</span>][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-4-计数类DP"><a href="#5-4-计数类DP" class="headerlink" title="5.4 计数类DP"></a>5.4 计数类DP</h2><h3 id="1-原理讲解-6"><a href="#1-原理讲解-6" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h3><h3 id="2-经典例题-2"><a href="#2-经典例题-2" class="headerlink" title="2. 经典例题"></a>2. 经典例题</h3><h4 id="例-5-4-1-整数划分"><a href="#例-5-4-1-整数划分" class="headerlink" title="例 5.4.1 整数划分"></a>例 5.4.1 整数划分</h4><p><strong>题目描述</strong></p>
<p>一个正整数 $n$ 可以表示成若干个正整数之和，形如：$n=n_1+n_2+…+n_k$，其中 $n_1≥n_2≥…≥n_k,k≥1$。</p>
<p>我们将这样的一种表示称为正整数 $n$ 的一种划分。</p>
<p>现在给定一个正整数 $n$，请你求出 $n$ 共有多少种不同的划分方法。</p>
<p><strong>输入格式</strong></p>
<p>共一行，包含一个整数 $n$。</p>
<p><strong>输出格式</strong></p>
<p>共一行，包含一个整数，表示总划分数量。</p>
<p>由于答案可能很大，输出结果请对 $10^9+7$ 取模。</p>
<p><strong>数据范围</strong></p>
<p>$1\leq n \leq 1000$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>思路：把$1,2,3, … n$分别看做$n$个物体的体积，这$n$个物体均无使用次数限制，问恰好能装满总体积为$n$的背包的总方案数（完全背包问题变形）</p>
<p>初值问题：</p>
<p>求最大值时，当都不选时，价值显然是 $0$</p>
<p>而求方案数时，当都不选时，方案数是 $1$（即前 $i$ 个物品都不选的情况也是一种方案），所以需要初始化为 $1$</p>
<p>即：<em>for (int i = 0; i &lt;= n; i ++) f[i][0] = 1;</em></p>
<p>等价变形后： <em>f[0] = 1</em></p>
<p>状态计算：</p>
<p>$f[i][j]$ 表示前$i$个整数$(1,2…,i)$恰好拼成$j$的方案数</p>
<p>求方案数：把集合选$0$​个$i$，$1$个$i$，$2$个$i$，…全部加起来</p>
<p>$f[i][j] = f[i - 1][j] + f[i - 1][j - i] + f[i - 1][j - 2 * i] + …$;</p>
<p>因此 $f[i][j]=f[i−1][j]+f[i][j−i]$; (这一步类似完全背包的推导）</p>
<p>朴素做法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// f[i][j] = f[i - 1][j] + f[i][j - i]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">7</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 容量为0时，前 i 个物品全不选也是一种方案</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j ++) &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j] % mod; <span class="comment">// 特殊 f[0][0] = 1</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= i) f[i][j] = (f[i - <span class="number">1</span>][j] + f[i][j - i]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[n][n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>等价变形：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// f[i][j] = f[i - 1][j] + f[i][j - i]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">7</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 容量为0时，前 i 个物品全不选也是一种方案</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j ++) &#123;</span><br><span class="line">            f[j] = (f[j] + f[j - i]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>标程</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 完全背包解法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j ++ )</span><br><span class="line">            f[j] = (f[j] + f[j - i]) % mod;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 另一种解法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j ++ )</span><br><span class="line">            f[i][j] = (f[i - <span class="number">1</span>][j - <span class="number">1</span>] + f[i - j][j]) % mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) res = (res + f[n][i]) % mod;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-5-数位统计DP"><a href="#5-5-数位统计DP" class="headerlink" title="5.5 数位统计DP"></a>5.5 数位统计DP</h2><h3 id="1-原理讲解-7"><a href="#1-原理讲解-7" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h3><h3 id="2-经典例题-3"><a href="#2-经典例题-3" class="headerlink" title="2. 经典例题"></a>2. 经典例题</h3><h4 id="例-5-5-1-计数问题"><a href="#例-5-5-1-计数问题" class="headerlink" title="例 5.5.1 计数问题"></a>例 5.5.1 计数问题</h4><p><strong>题目描述</strong></p>
<p>给定两个整数 $a$ 和 $b$，求 $a$ 和 $b$ 之间的所有数字中 $0∼9$ 的出现次数。</p>
<p>例如，$a=1024，b=1032$，则 $a$ 和 $b$ 之间共有 $9$ 个数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1024 1025 1026 1027 1028 1029 1030 1031 1032</span><br></pre></td></tr></table></figure>
<p>其中 <em>0</em> 出现 $10$ 次，<em>1</em> 出现 $10$ 次，<em>2</em> 出现 $7$ 次，<em>3</em> 出现 $3$ 次等等…</p>
<p><strong>输入格式</strong></p>
<p>输入包含多组测试数据。</p>
<p>每组测试数据占一行，包含两个整数 $a$ 和 $b$。</p>
<p>当读入一行为 <em>0 0</em> 时，表示输入终止，且该行不作处理。</p>
<p><strong>输出格式</strong></p>
<p>每组数据输出一个结果，每个结果占一行。</p>
<p>每个结果包含十个用空格隔开的数字，第一个数字表示 <em>0</em> 出现的次数，第二个数字表示 <em>1</em> 出现的次数，以此类推。</p>
<p><strong>数据范围</strong></p>
<p>$0&lt;a,b&lt;100000000$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 10</span><br><span class="line">44 497</span><br><span class="line">346 542</span><br><span class="line">1199 1748</span><br><span class="line">1496 1403</span><br><span class="line">1004 503</span><br><span class="line">1714 190</span><br><span class="line">1317 854</span><br><span class="line">1976 494</span><br><span class="line">1001 1960</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 1 1 1 1 1 1 1 1</span><br><span class="line">85 185 185 185 190 96 96 96 95 93</span><br><span class="line">40 40 40 93 136 82 40 40 40 40</span><br><span class="line">115 666 215 215 214 205 205 154 105 106</span><br><span class="line">16 113 19 20 114 20 20 19 19 16</span><br><span class="line">107 105 100 101 101 197 200 200 200 200</span><br><span class="line">413 1133 503 503 503 502 502 417 402 412</span><br><span class="line">196 512 186 104 87 93 97 97 142 196</span><br><span class="line">398 1375 398 398 405 499 499 495 488 471</span><br><span class="line">294 1256 296 296 296 296 287 286 286 247</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>尤其强调分类讨论：</p>
<p>比如说我要找$[1,abcdefg]$中的数中$1$出现的个数，就得先求$1$在每一个位置上出现的次数。</p>
<p>比如我要找第$4$位上出现的$1$的数有几个，就是要找满足 $1 &lt;= xxx1yyy &lt;= abcdefg$</p>
<ol>
<li>$xxx∈[000,abc-1]$ , $yyy∈[000,999]$ , $ans += abc*1000$​</li>
</ol>
<p>//如果前三位没填满，则后三位就可以随便填</p>
<ol>
<li>$xxx==abc , yyy∈?$​<br>$if(d<1) yyy$不存在 , $ans +="0$" $if(d="=1)" yyy∈[000,efg]$​>1) yyy∈[000,999]$ , $ans += 1000$<br>//如果前三位填满了，后三位怎么填取决于当前这一位</1)></li>
</ol>
<p>然后每一位上都是这么讨论的，最后累加起来就是总共出现的次数</p>
<p>这样就是求出来了$[1,n]$的</p>
<p>然后如果我想求$[l,r]$的用一下前缀和就搞定了</p>
<p>但是有一些特殊情况<br>1) $x$​在第$1$位上出现的次数（不用考虑前半段）：</p>
<p>$bcdefg∈[00000,bcdefg] , ans += bcdefg+1$</p>
<p>2) x在最后一位上出现的次数（不用考虑后半段）：<br>   如果$g<x$，那么不存在这样的数，$ans +="0$" 如果$g="=x$，那么有一个这样的数，$ans">x$，$yyyyyy∈[000000,abcdef]$ , $ans += abcdef+1$<br>3) 如果我们枚举的数是0的话 ：</x$，那么不存在这样的数，$ans></p>
<p>$0$不能在第一位 </p>
<p>而且枚举到的这一位前面不能全是$0$，即$xxx∈[001,abc-1]$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e8</span>+<span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> n,a,b;</span><br><span class="line"><span class="keyword">int</span> num[N];<span class="comment">//建议不要用vector吧常数贼大</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_num</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123; <span class="comment">//算出数组num[]第r位到第l位的数是多少</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=l; i&gt;=r; i--)</span><br><span class="line">        ans = ans*<span class="number">10</span> + num[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow10</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">//求10的i次方</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i--) ans *= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//虽然a和b不会取到0，但是a-1会</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n) &#123;</span><br><span class="line">        num[++len] = n%<span class="number">10</span>;</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x!=<span class="number">0</span>) &#123; <span class="comment">//x非0 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=len; i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;len) ans += <span class="built_in">get_num</span>(len,i+<span class="number">1</span>) * <span class="built_in">pow10</span>(i<span class="number">-1</span>);</span><br><span class="line">                    <span class="comment">//第一类讨论，x在首位上时不讨论这种情况</span></span><br><span class="line">            <span class="keyword">if</span>(num[i]==x) ans += <span class="built_in">get_num</span>(i<span class="number">-1</span>,<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num[i]&gt;x) ans += <span class="built_in">pow10</span>(i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">else</span> ans += <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">//第二类讨论 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//x为0 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=len<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">            ans += (<span class="built_in">get_num</span>(len,i+<span class="number">1</span>)<span class="number">-1</span>) * <span class="built_in">pow10</span>(i<span class="number">-1</span>);</span><br><span class="line">                    <span class="comment">//x不会在首位，所以也不用担心首位特判 </span></span><br><span class="line">            <span class="keyword">if</span>(num[i]==x) ans += <span class="built_in">get_num</span>(i<span class="number">-1</span>,<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num[i]&gt;x) ans += <span class="built_in">pow10</span>(i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">else</span> ans += <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">//0对第二类讨论没有影响 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b) &amp;&amp; a!=<span class="number">0</span> &amp;&amp; b!=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b) <span class="built_in">swap</span>(a,b);<span class="comment">//输入不保证后面的比前面的大</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="built_in">work</span>(b,i) - <span class="built_in">work</span>(a<span class="number">-1</span>,i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面那个<em>work()</em>函数是为了大家好理解那么写的</p>
<p>其实可以合并一下代码更简洁</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n) &#123;</span><br><span class="line">        num[++len] = n%<span class="number">10</span>;</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=len-!x; i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;len) &#123;</span><br><span class="line">            <span class="keyword">if</span>(x) ans += <span class="built_in">get_num</span>(len,i+<span class="number">1</span>) * <span class="built_in">pow10</span>(i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">else</span>  ans += (<span class="built_in">get_num</span>(len,i+<span class="number">1</span>)<span class="number">-1</span>) * <span class="built_in">pow10</span>(i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一类讨论，x在首位上时不讨论这种情况</span></span><br><span class="line">        <span class="comment">//x不会在首位，所以也不用担心首位特判</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(num[i]==x) ans += <span class="built_in">get_num</span>(i<span class="number">-1</span>,<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num[i]&gt;x) ans += <span class="built_in">pow10</span>(i<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span> ans += <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//第二类讨论</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>标程</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">001~abc-1, 999</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">abc</span></span><br><span class="line"><span class="comment">    1. num[i] &lt; x, 0</span></span><br><span class="line"><span class="comment">    2. num[i] == x, 0~efg</span></span><br><span class="line"><span class="comment">    3. num[i] &gt; x, 0~999</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; num, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &gt;= r; i -- ) res = res * <span class="number">10</span> + num[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">power10</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (x -- ) res *= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        num.<span class="built_in">push_back</span>(n % <span class="number">10</span>);</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n = num.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span> - !x; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res += <span class="built_in">get</span>(num, n - <span class="number">1</span>, i + <span class="number">1</span>) * <span class="built_in">power10</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (!x) res -= <span class="built_in">power10</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num[i] == x) res += <span class="built_in">get</span>(num, i - <span class="number">1</span>, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num[i] &gt; x) res += <span class="built_in">power10</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; a &gt;&gt; b , a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) <span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i ++ )</span><br><span class="line">            cout &lt;&lt; <span class="built_in">count</span>(b, i) - <span class="built_in">count</span>(a - <span class="number">1</span>, i) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-6-状态压缩DP"><a href="#5-6-状态压缩DP" class="headerlink" title="5.6 状态压缩DP"></a>5.6 状态压缩DP</h2><h3 id="1-原理讲解-8"><a href="#1-原理讲解-8" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h3><h3 id="2-经典例题-4"><a href="#2-经典例题-4" class="headerlink" title="2. 经典例题"></a>2. 经典例题</h3><h4 id="例-5-6-1-蒙德里安的梦想"><a href="#例-5-6-1-蒙德里安的梦想" class="headerlink" title="例 5.6.1 蒙德里安的梦想"></a>例 5.6.1 蒙德里安的梦想</h4><p><strong>题目描述</strong></p>
<p>求把 $N×M$ 的棋盘分割成若干个 $1×2$ 的的长方形，有多少种方案。</p>
<p>例如当 $N=2，M=4$ 时，共有 $5$ 种方案。当 $N=2，M=3$ 时，共有 $3$ 种方案。</p>
<p>如下图所示：</p>
<p><img src="/2022/01/08/basicACML5/Users/dell/AppData/Roaming/Typora/typora-user-images/image-20210708214937892.png" alt="image-20210708214937892"></p>
<p><strong>输入格式</strong></p>
<p>输入包含多组测试用例。</p>
<p>每组测试用例占一行，包含两个整数 $N$ 和 $M$。</p>
<p>当输入用例 $N=0，M=0$ 时，表示输入终止，且该用例无需处理。</p>
<p><strong>输出格式</strong></p>
<p>每个测试用例输出一个结果，每个结果占一行。</p>
<p><strong>数据范围</strong></p>
<p>$1\leq N,M\leq 11$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 2</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br><span class="line">2 11</span><br><span class="line">4 11</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">144</span><br><span class="line">51205</span><br></pre></td></tr></table></figure>
<p><strong>题目分析</strong></p>
<p>摆放方块的时候，先放横着的，再放竖着的。总方案数等于只放横着的小方块的合法方案数。</p>
<p>如何判断，当前方案数是否合法？ 所有剩余位置能否填充满竖着的小方块。可以按列来看，每一列内部所有连续的空着的小方块需要是偶数个。</p>
<p>这是一道动态规划的题目，并且是一道状态压缩的dp：用一个$N$位的二进制数，每一位表示一个物品，$0/1$表示不同的状态。因此可以用$0→2^N−1$（$N$二进制对应的十进制数）$0→2^N−1$（$N$二进制对应的十进制数）中的所有数来枚举全部的状态。</p>
<p>状态表示</p>
<p>状态表示：$f[i][j]$ 表示已经将前 $i -1$ 列摆好，且从第$i−1$列，伸出到第 $i$ 列的状态是 $j$ 的所有方案。其中$j$是一个二进制数，用来表示哪一行的小方块是横着放的，其位数和棋盘的行数一致。</p>
<p>状态转移</p>
<p>既然第 $i$ 列固定了，我们需要看第$i-2$ 列是怎么转移到到第 $i-1$列的（看最后转移过来的状态）。假设此时对应的状态是$k$（第$i-2$列到第$i-1$列伸出来的二进制数，比如$00100$），$k$也是一个二进制数，$1$表示哪几行小方块是横着伸出来的，$0$表示哪几行不是横着伸出来的。</p>
<p>它对应的方案数是 $f[i−1,k]$ ，即前$i-2$列都已摆完，且从第$i-2$列伸到第$i-1$列的状态为 $k$ 的所有方案数。</p>
<p>这个$k$需要满足什么条件呢?</p>
<p>首先$k$不能和$j$在同一行（如下图）：因为从$i-1$列到第$i$列是横着摆放的$12$的方块，那么$i-2$列到$i-1$列就不能是横着摆放的，否则就是$1$ $3$的方块了！这与题意矛盾。所以 $k$和$j$不能位于同一行。</p>
<p>既然不能同一行伸出来，那么对应的代码为 $(k &amp; j ) ==0$​​ ，表示两个数相与，如果有1位相同结果就不是$0$​， $(k &amp; j ) ==0$​表示 $k$和$j$没有$1$位相同， 即没有$1$行有冲突。</p>
<p>既然从第$i-1$列到第$i$列横着摆的，和第$i-2$列到第$i-1$列横着摆的都确定了，那么第$i-1$列 空着的格子就确定了，这些空着的格子将来用作竖着放。如果 某一列有这些空着的位置，那么该列所有连续的空着的位置长度必须是偶数。</p>
<p>总共$m$列，我们假设列下标从$0$开始，即第$0$列，第$1$列……，第$m-1$列。根据状态表示$f[i] [j]$ 的定义，我们答案是什么呢？ 请读者返回定义处思考一下。答案是$f[m][0]$， 意思是前$m-1$列全部摆好,且从第$m-1$列到$m$列状态是$0$（意即从第$m-1$列到第$m$列没有伸出来的）的所有方案，即整个棋盘全部摆好的方案。</p>
<p>时间复杂度</p>
<p>dp的时间复杂度 = 状态表示 × 状态转移</p>
<p>状态表示$ f[i][j]$​ 第一维$i$​可取$11$​，第二维$j$​（二进制数）可取$2^{11}$​ ，所以状态表示 $11×2^{11}$​<br>状态转移 也是$2^{11}$​</p>
<p>所以总的时间复杂度</p>
<p>$11×2^11×2^11≈4×10^7$ 可以过</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">12</span>, M = <span class="number">1</span>&lt;&lt; N;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[N][M] ;<span class="comment">// 第一维表示列， 第二维表示所有可能的状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> st[M];  <span class="comment">//存储每种状态是否有奇数个连续的0，如果奇数个0是无效状态，如果是偶数个零置为true。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//vector&lt;int &gt; state[M];  //二维数组记录合法的状态</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">state</span>(M);  <span class="comment">//两种写法等价:二维数组</span></span><br><span class="line"><span class="keyword">int</span> m , n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m, n||m)&#123; <span class="comment">//读入n和m，并且不是两个0即合法输入就继续读入</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一部分：预处理1</span></span><br><span class="line">        <span class="comment">//对于每种状态，先预处理每列不能有奇数个连续的0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; <span class="number">1</span>&lt;&lt;n; i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> cnt =<span class="number">0</span> ;<span class="comment">//记录连续的0的个数</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> isValid = <span class="literal">true</span>; <span class="comment">// 某种状态没有奇数个连续的0则标记为true</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123; <span class="comment">//遍历这一列，从上到下</span></span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span>( i&gt;&gt;j &amp;<span class="number">1</span>)&#123;  <span class="comment">//i&gt;&gt;j位运算，表示i（i在此处是一种状态）的二进制数的第j位； &amp;1为判断该位是否为1，如果为1进入if</span></span><br><span class="line">                    <span class="keyword">if</span>(cnt &amp;<span class="number">1</span>) &#123; <span class="comment">//这一位为1，看前面连续的0的个数，如果是奇数（cnt &amp;1为真）则该状态不合法</span></span><br><span class="line">                        isValid =<span class="literal">false</span>;<span class="keyword">break</span>;</span><br><span class="line">                    &#125; </span><br><span class="line">                    cnt=<span class="number">0</span>; <span class="comment">// 既然该位是1，并且前面不是奇数个0（经过上面的if判断），计数器清零。//其实清不清零没有影响</span></span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">else</span> cnt++; <span class="comment">//否则的话该位还是0，则统计连续0的计数器++。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &amp;<span class="number">1</span>)  isValid =<span class="literal">false</span>; <span class="comment">//最下面的那一段判断一下连续的0的个数</span></span><br><span class="line"></span><br><span class="line">            st[i]  = isValid; <span class="comment">//状态i是否有奇数个连续的0的情况,输入到数组st中</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二部分：预处理2</span></span><br><span class="line">        <span class="comment">// 经过上面每种状态 连续0的判断，已经筛掉一些状态。</span></span><br><span class="line">        <span class="comment">//下面来看进一步的判断：看第i-2列伸出来的和第i-1列伸出去的是否冲突</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt; <span class="number">1</span>&lt;&lt;n;j++)&#123; <span class="comment">//对于第i列的所有状态</span></span><br><span class="line">            state[j].<span class="built_in">clear</span>(); <span class="comment">//清空上次操作遗留的状态，防止影响本次状态。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt; <span class="number">1</span>&lt;&lt;n;k++)&#123; <span class="comment">//对于第i-1列所有状态</span></span><br><span class="line">                <span class="keyword">if</span>((j&amp;k )==<span class="number">0</span> &amp;&amp; st[ j| k] ) <span class="comment">// 第i-2列伸出来的 和第i-1列伸出来的不冲突(不在同一行) </span></span><br><span class="line">                <span class="comment">//解释一下st[j | k] </span></span><br><span class="line">                <span class="comment">//已经知道st[]数组表示的是这一列没有连续奇数个0的情况，</span></span><br><span class="line">                <span class="comment">//我们要考虑的是第i-1列（第i-1列是这里的主体）中从第i-2列横插过来的，还要考虑自己这一列（i-1列）横插到第i列的</span></span><br><span class="line">                <span class="comment">//比如 第i-2列插过来的是k=10101，第i-1列插出去到第i列的是 j =01000，</span></span><br><span class="line">                <span class="comment">//那么合在第i-1列，到底有多少个1呢？自然想到的就是这两个操作共同的结果：两个状态或。 j | k = 01000 | 10101 = 11101</span></span><br><span class="line">                <span class="comment">//这个 j|k 就是当前 第i-1列的到底有几个1，即哪几行是横着放格子的</span></span><br><span class="line"></span><br><span class="line">                    state[j].<span class="built_in">push_back</span>(k);  <span class="comment">//二维数组state[j]表示第j行， </span></span><br><span class="line">                    <span class="comment">//j表示 第i列“真正”可行的状态，如果第i-1列的状态k和j不冲突则压入state数组中的第j行。</span></span><br><span class="line">                    <span class="comment">//“真正”可行是指：既没有前后两列伸进伸出的冲突；又没有连续奇数个0。</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三部分：dp开始</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);  <span class="comment">//全部初始化为0，因为是连续读入，这里是一个清空操作。类似上面的state[j].clear()</span></span><br><span class="line"></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span> ;<span class="comment">// 这里需要回忆状态表示的定义，按定义这里是：前第-1列都摆好，且从-1列到第0列伸出来的状态为0的方案数。</span></span><br><span class="line">        <span class="comment">//首先，这里没有-1列，最少也是0列。其次，没有伸出来，即没有横着摆的。即这里第0列只有竖着摆这1种状态。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;= m;i++)&#123; <span class="comment">//遍历每一列:第i列合法范围是(0~m-1列)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt; <span class="number">1</span>&lt;&lt;n; j++)&#123;  <span class="comment">//遍历当前列（第i列）所有状态j</span></span><br><span class="line">                <span class="keyword">for</span>( <span class="keyword">auto</span> k : state[j])    <span class="comment">// 遍历第i-1列的状态k，如果“真正”可行，就转移</span></span><br><span class="line">                    f[i][j] += f[i<span class="number">-1</span>][k];    <span class="comment">// 当前列的方案数就等于之前的第i-1列所有状态k的累加。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后答案是什么呢？</span></span><br><span class="line">        <span class="comment">//f[m][0]表示 前m-1列都处理完，并且第m-1列没有伸出来的所有方案数。</span></span><br><span class="line">        <span class="comment">//即整个棋盘处理完的方案数</span></span><br><span class="line"></span><br><span class="line">        cout&lt;&lt; f[m][<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>标程</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">12</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">LL f[N][M];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; state[M];</span><br><span class="line"><span class="keyword">bool</span> st[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m, n || m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">bool</span> is_valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">                <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        is_valid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cnt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> cnt ++ ;</span><br><span class="line">            <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>) is_valid = <span class="literal">false</span>;</span><br><span class="line">            st[i] = is_valid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            state[i].<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n; j ++ )</span><br><span class="line">                <span class="keyword">if</span> ((i &amp; j) == <span class="number">0</span> &amp;&amp; st[i | j])</span><br><span class="line">                    state[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n; j ++ )</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> k : state[j])</span><br><span class="line">                    f[i][j] += f[i - <span class="number">1</span>][k];</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; f[m][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例-5-6-2-最短Hamilton路径"><a href="#例-5-6-2-最短Hamilton路径" class="headerlink" title="例 5.6.2 最短Hamilton路径"></a>例 5.6.2 最短Hamilton路径</h4><p><strong>题目描述</strong></p>
<p>给定一张 $n$ 个点的带权无向图，点从 $0∼n−1$ 标号，求起点 $0$ 到终点 $n−1$ 的最短 Hamilton 路径。</p>
<p>Hamilton 路径的定义是从 $0$ 到 $n−1$ 不重不漏地经过每个点恰好一次。</p>
<p><strong>输入格式</strong></p>
<p>第一行输入整数 $n$。</p>
<p>接下来 $n$ 行每行 $n$ 个整数，其中第 $i$ 行第 $j$ 个整数表示点 $i$ 到 $j$ 的距离（记为 $a[i,j]$）。</p>
<p>对于任意的 $x,y,z$，数据保证 $a[x,x]=0，a[x,y]=a[y,x]$ 并且 $a[x,y]+a[y,z]≥a[x,z]$。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数，表示最短 Hamilton 路径的长度。</p>
<p><strong>数据范围</strong></p>
<p>$1\leq n \leq 20$</p>
<p>$0\leq a[i,j] \leq 10^7$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">0 2 4 5 1</span><br><span class="line">2 0 6 5 3</span><br><span class="line">4 6 0 8 3</span><br><span class="line">5 5 8 0 5</span><br><span class="line">1 3 3 5 0</span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">18</span><br></pre></td></tr></table></figure>
<ol>
<li>本题思路</li>
</ol>
<p>假设：一共有七个点,用$0,1,2,3,4,5,6$​来表示,那么先假设终点就是$5$,在这里我们再假设还没有走到$5$这个点,且走到的终点是$4$,那么有以下六种情况:</p>
<p>first: $0\to1\to2\to3\to4$ 距离:$21$</p>
<p>second: $0\to1\to3\to2\to4$ 距离:$23$</p>
<p>third: $0\to2\to1\to3\to4$ 距离:$17$</p>
<p>fourth: $0\to2\to3\to1\to4$ 距离:$20$</p>
<p>fifth: $0\to3\to1\to2\to4$ 距离:$15$</p>
<p>sixth: $0\to3\to2\to1\to4$ 距离:$18$</p>
<p>如果此时你是一个商人你会走怎样的路径?显而易见,会走第五种情况对吧?因为每段路程的终点都是$4$,且每种方案的可供选择的点是$0\to4$,而商人寻求的是走到$5$这个点的最短距离,而$4$到$5$的走法只有一种,所以我们选择第五种方案，可寻找到走到5这个点儿之前,且终点是4的方案的最短距离,此时$0\to5$的最短距离为($15+4$走到$5$的距离).(假设$4\to5=8$)</p>
<p>同理:假设还没有走到$5$这个点儿,且走到的终点是$3$,那么有一下六种情况:</p>
<p>first: $0\to1\to2\to4\to3$ 距离:$27$</p>
<p>second: $0\to1\to4\to2\to3$ 距离:$22$</p>
<p>third: $0\to2\to1\to4\to3$ 距离:$19$</p>
<p>fourth: $0\to2\to4\to1\to3$​ 距离:$24$</p>
<p>fifth: $0\to4\to1\to2\to3 $ 距离:$26$</p>
<p>sixth: $0\to4\to2\to1\to3$ 距离:$17$</p>
<p>此时我们可以果断的做出决定:走第六种方案!!!,而此时$0\to5$的最短距离为($17+3$走到$5$的距离)(假设$3–&gt;5=5$)</p>
<p>在以上两大类情况之后我们可以得出当走到5时:</p>
<ol>
<li>以$4$为终点的情况的最短距离是:$15+8=23$;</li>
<li>以$3$为终点的情况的最短距离是:$17+5=22$;</li>
</ol>
<p>经过深思熟虑之后,商人决定走以3为终点的最短距离,此时更新最短距离为:$22$。</p>
<p>当然以此类推还会有以$1$为终点和以$2$为终点的情况,此时我们可以进行以上操作不断更新到$5$这个点的最短距离,最终可以得到走到5这个点儿的最短距离,然后再返回最初的假设,再依次假设$1,2,3,4$是终点,最后再不断更新,最终可以得出我们想要的答案</p>
<ol>
<li>DP分析:</li>
</ol>
<p>用二进制来表示要走的所以情况的路径,这里用$i$​​来代替</p>
<p>例如走$0,1,2,4$​​这三个点,则表示为:$10111$​​;</p>
<p>走$0,2,3$​​这三个点:$1101$​​;</p>
<p>状态表示:$f[i][j]$​​;</p>
<p>集合:所有从$0$​​走到$j$​​,走过的所有点的情况是$i$​​的所有路径</p>
<p>属性:$\min$​​</p>
<p>状态计算:如$1$​​中分析一致,$0\to·····\to k\to j$​​中$k$​​​的所有情况</p>
<p>状态转移方程：</p>
<script type="math/tex; mode=display">
f[i][j]=\min(f[i][j],f[i-(1<<j)][k]+w[k][j])</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">20</span>,M=<span class="number">1</span>&lt;&lt;N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[M][N],w[N][N];<span class="comment">//w表示的是无权图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">      cin&gt;&gt;w[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(f));<span class="comment">//因为要求最小值，所以初始化为无穷大</span></span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//因为零是起点,所以f[1][0]=0;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;n;i++)<span class="comment">//i表示所有的情况</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)<span class="comment">//j表示走到哪一个点</span></span><br><span class="line">      <span class="keyword">if</span>(i&gt;&gt;j&amp;<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)<span class="comment">//k表示走到j这个点之前,以k为终点的最短距离</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;&gt;k&amp;<span class="number">1</span>)</span><br><span class="line">         f[i][j]=<span class="built_in">min</span>(f[i][j],f[i-(<span class="number">1</span>&lt;&lt;j)][k]+w[k][j]);<span class="comment">//更新最短距离</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;f[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>][n<span class="number">-1</span>]&lt;&lt;endl;<span class="comment">//表示所有点都走过了,且终点是n-1的最短距离</span></span><br><span class="line">    <span class="comment">//位运算的优先级低于&#x27;+&#x27;-&#x27;所以有必要的情况下要打括号</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>标程</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> w[N][N];</span><br><span class="line"><span class="keyword">int</span> f[M][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            cin &gt;&gt; w[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k ++ )</span><br><span class="line">                    <span class="keyword">if</span> (i &gt;&gt; k &amp; <span class="number">1</span>)</span><br><span class="line">                        f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - (<span class="number">1</span> &lt;&lt; j)][k] + w[k][j]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-7-树形DP"><a href="#5-7-树形DP" class="headerlink" title="5.7 树形DP"></a>5.7 树形DP</h2><h3 id="1-原理讲解-9"><a href="#1-原理讲解-9" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h3><h3 id="2-经典例题-5"><a href="#2-经典例题-5" class="headerlink" title="2. 经典例题"></a>2. 经典例题</h3><h4 id="例-5-7-1-没有上司的舞会"><a href="#例-5-7-1-没有上司的舞会" class="headerlink" title="例 5.7.1 没有上司的舞会"></a>例 5.7.1 没有上司的舞会</h4><p><strong>题目描述</strong></p>
<p>Ural 大学有 $N$ 名职员，编号为 $1∼N$。</p>
<p>他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。</p>
<p>每个职员有一个快乐指数，用整数 $H_i$ 给出，其中 $1≤i≤N$。</p>
<p>现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。</p>
<p>在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。</p>
<p><strong>输入格式</strong></p>
<p>第一行一个整数 $N$。</p>
<p>接下来 $N$ 行，第 $i$ 行表示 $i$ 号职员的快乐指数 $H_i$。</p>
<p>接下来 $N−1$ 行，每行输入一对整数 $L,K$，表示 $K$ 是 $L$ 的直接上司。</p>
<p><strong>输出格式</strong></p>
<p>输出最大的快乐指数。</p>
<p><strong>数据范围</strong></p>
<p>$1\leq N \leq 6000$</p>
<p>$-128 \leq H_i \leq 127$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">6 4</span><br><span class="line">7 4</span><br><span class="line">4 5</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<p>每个人只有两种状态，则设$dp[0][i]$为第$i$个人不来，他的下属所能获得的最大快乐值；$dp[1][i]$为第$i$个人来，他的下属所能获得的最大快乐值。</p>
<p>所以容易推出状态转移方程：</p>
<script type="math/tex; mode=display">
dp[0][i]=\sum_{u=sons}\max(dp[1][u],dp[0][u])</script><p>当前节点不选，那么子节点随意</p>
<script type="math/tex; mode=display">
dp[1][i]=\sum_{u=sons}dp[0][u]+happy[i]</script><p>当前节点选，子节点不能选</p>
<p>分析可得，每个人的状态要在下属的状态更新完了才能更新，所以用类似拓扑的方法，只记录每个子节点的父亲，最后从所有入度为$0$​的点开始跑就行了。在更新每个子节点时顺便让父节点加上自己的权值，最后访问父节点时权值已经更新好了，就可以省去建图的麻烦。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][<span class="number">6010</span>];<span class="comment">//dp解释见上</span></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>][<span class="number">6010</span>];<span class="comment">//f[0]为父亲，f[1]为高兴值</span></span><br><span class="line"><span class="keyword">int</span> ind[<span class="number">6010</span>];<span class="comment">//入度</span></span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">6010</span>];<span class="comment">//访问标记</span></span><br><span class="line"><span class="keyword">int</span> root;<span class="comment">//树的根</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;<span class="comment">//递归从后往前更新</span></span><br><span class="line">    <span class="keyword">if</span>(!u) <span class="keyword">return</span>;</span><br><span class="line">    vis[u]=<span class="number">1</span>;<span class="comment">//已访问</span></span><br><span class="line">    root=u;<span class="comment">//最后一个访问到的一定是根，所以一直更新根就行了</span></span><br><span class="line">    dp[<span class="number">0</span>][f[<span class="number">0</span>][u]]+=<span class="built_in">max</span>(dp[<span class="number">1</span>][u]+f[<span class="number">1</span>][u],dp[<span class="number">0</span>][u]);<span class="comment">//给父亲更新</span></span><br><span class="line">    dp[<span class="number">1</span>][f[<span class="number">0</span>][u]]+=dp[<span class="number">0</span>][u];</span><br><span class="line">    ind[f[<span class="number">0</span>][u]]--;<span class="comment">//更新完一个子节点</span></span><br><span class="line">    <span class="keyword">if</span>(!ind[f[<span class="number">0</span>][u]]) <span class="built_in">dfs</span>(f[<span class="number">0</span>][u]);<span class="comment">//在所有子节点更新后再更新（入度为0）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;f[<span class="number">1</span>][i]);</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        f[<span class="number">0</span>][a]=b;<span class="comment">//保存节点信息</span></span><br><span class="line">        ind[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]&amp;&amp;!ind[i])<span class="comment">//没有被访问过，没有入度，说明是叶子节点</span></span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">max</span>(dp[<span class="number">0</span>][root],dp[<span class="number">1</span>][root]+f[<span class="number">1</span>][root]));<span class="comment">//取根节点两种方案的最大值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>标程</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="keyword">int</span> happy[N];</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> has_fa[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[u][<span class="number">1</span>] = happy[u];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j);</span><br><span class="line"></span><br><span class="line">        f[u][<span class="number">1</span>] += f[j][<span class="number">0</span>];</span><br><span class="line">        f[u][<span class="number">0</span>] += <span class="built_in">max</span>(f[j][<span class="number">0</span>], f[j][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;happy[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(b, a);</span><br><span class="line">        has_fa[a] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (has_fa[root]) root ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">max</span>(f[root][<span class="number">0</span>], f[root][<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-8-记忆化搜索"><a href="#5-8-记忆化搜索" class="headerlink" title="5.8 记忆化搜索"></a>5.8 记忆化搜索</h2><h3 id="1-原理讲解-10"><a href="#1-原理讲解-10" class="headerlink" title="1. 原理讲解"></a>1. 原理讲解</h3><h3 id="2-经典例题-6"><a href="#2-经典例题-6" class="headerlink" title="2. 经典例题"></a>2. 经典例题</h3><h4 id="例-5-8-1-滑雪"><a href="#例-5-8-1-滑雪" class="headerlink" title="例 5.8.1 滑雪"></a>例 5.8.1 滑雪</h4><p><strong>题目描述</strong></p>
<p>给定一个 $R$ 行 $C$ 列的矩阵，表示一个矩形网格滑雪场。</p>
<p>矩阵中第 $i$ 行第 $j$ 列的点表示滑雪场的第 $i$ 行第 $j$ 列区域的高度。</p>
<p>一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。</p>
<p>当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。</p>
<p>下面给出一个矩阵作为例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 1  2  3  4 5</span><br><span class="line"></span><br><span class="line">16 17 18 19 6</span><br><span class="line"></span><br><span class="line">15 24 25 20 7</span><br><span class="line"></span><br><span class="line">14 23 22 21 8</span><br><span class="line"></span><br><span class="line">13 12 11 10 9</span><br></pre></td></tr></table></figure>
<p>在给定矩阵中，一条可行的滑行轨迹为 $24−17−2−1$。</p>
<p>在给定矩阵中，最长的滑行轨迹为 $25−24−23−…−3−2−1$，沿途共经过 $25$ 个区域。</p>
<p>现在给定你一个二维矩阵表示滑雪场各区域的高度，请你找出在该滑雪场中能够完成的最长滑雪轨迹，并输出其长度(可经过最大区域数)。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含两个整数 $R$ 和 $C$。</p>
<p>接下来 $R$ 行，每行包含 $C$ 个整数，表示完整的二维矩阵。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数，表示可完成的最长滑雪长度。</p>
<p><strong>数据范围</strong></p>
<p>$1\leq R,C \leq 300$</p>
<p>$0\leq$ 矩阵中整数$ \leq 10000$​</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">1 2 3 4 5</span><br><span class="line">16 17 18 19 6</span><br><span class="line">15 24 25 20 7</span><br><span class="line">14 23 22 21 8</span><br><span class="line">13 12 11 10 9</span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">25</span><br></pre></td></tr></table></figure>
<p><strong>标程</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;v = f[x][y];</span><br><span class="line">    <span class="keyword">if</span> (v != <span class="number">-1</span>) <span class="keyword">return</span> v;</span><br><span class="line"></span><br><span class="line">    v = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (a &gt;= <span class="number">1</span> &amp;&amp; a &lt;= n &amp;&amp; b &gt;= <span class="number">1</span> &amp;&amp; b &lt;= m &amp;&amp; g[x][y] &gt; g[a][b])</span><br><span class="line">            v = <span class="built_in">max</span>(v, <span class="built_in">dp</span>(a, b) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;g[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">dp</span>(i, j));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
</search>
