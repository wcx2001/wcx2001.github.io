<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-big-counter.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wcx2001.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":true,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true},"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文是课程cs231a的第4节笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="cs231a Course 4：立体声系统和运动结构恢复">
<meta property="og:url" content="http://wcx2001.github.io/2021/12/07/L4/index.html">
<meta property="og:site_name" content="Wei">
<meta property="og:description" content="本文是课程cs231a的第4节笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://wcx2001.github.io/2021/12/07/L4/1.PNG">
<meta property="og:image" content="http://wcx2001.github.io/2021/12/07/L4/2.PNG">
<meta property="og:image" content="http://wcx2001.github.io/2021/12/07/L4/3.PNG">
<meta property="og:image" content="http://wcx2001.github.io/2021/12/07/L4/4.PNG">
<meta property="og:image" content="http://wcx2001.github.io/2021/12/07/L4/5.PNG">
<meta property="og:image" content="http://wcx2001.github.io/2021/12/07/L4/blog/source/_posts/视觉4.assets/image-20211206004541777-16387227427507.png">
<meta property="article:published_time" content="2021-12-06T16:00:00.000Z">
<meta property="article:modified_time" content="2021-12-07T14:09:14.232Z">
<meta property="article:author" content="小学渣的春天">
<meta property="article:tag" content="计算机视觉">
<meta property="article:tag" content="cs231a">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://wcx2001.github.io/2021/12/07/L4/1.PNG">

<link rel="canonical" href="http://wcx2001.github.io/2021/12/07/L4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>cs231a Course 4：立体声系统和运动结构恢复 | Wei</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Wei" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wei</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wcx2001.github.io/2021/12/07/L4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/machao.jpg">
      <meta itemprop="name" content="小学渣的春天">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          cs231a Course 4：立体声系统和运动结构恢复
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-07 00:00:00 / 修改时间：22:09:14" itemprop="dateCreated datePublished" datetime="2021-12-07T00:00:00+08:00">2021-12-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" itemprop="url" rel="index"><span itemprop="name">计算机视觉</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description">本文是课程cs231a的第4节笔记</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Course-4：立体声系统和运动结构恢复"><a href="#Course-4：立体声系统和运动结构恢复" class="headerlink" title="Course 4：立体声系统和运动结构恢复"></a>Course 4：立体声系统和运动结构恢复</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1  介绍"></a>1  介绍</h2><p>在前面的注释中，我们讨论了如何添加一个场景的额外视点可以极大地增强我们对所述场景的知识。我们专注于外极性几何设置，以便将一个图像平面上的点与另一个图像平面上的点联系起来，而不提取任何关于三维场景的信息。在这些课堂讲稿中，我们将讨论如何从多个二维图像中恢复有关三维场景的信息。</p>
<h2 id="2-三角剖分"><a href="#2-三角剖分" class="headerlink" title="2 三角剖分"></a>2 三角剖分</h2><p>多视图几何中最基本的问题之一是三角测量问题，即给定三维点投影到两个或多个图像的三维点位置的过程。</p>
<p><img src="/2021/12/07/L4/1.PNG" alt="图1：当给定两个视图时的三角测量问题的设置。"></p>
<p>在两个视图的三角测量问题中，我们分别有两个已知相机固有参数$K$​和$K_0$​的相机。我们也知道这些相机彼此之间的相对方向和偏移量$R$、$T$。假设我们在三维中有一个点$P$，这可以分别在$p$和$p’$的两个相机的图像中找到。虽然$P$的位置目前尚不清楚，但我们可以测量$p$和$p’$在图像中的确切位置。由于$K$、$K’$、$R$、$T$是已知的，我们可以计算两个视线$l$和$l’$，它们由相机中心$O_1$、$O_2$和图像位置$p$、$p’$定义。因此，$P$可以计算为$l$和$l’$的交点。</p>
<p><img src="/2021/12/07/L4/2.PNG" alt="图2：真实场景中的三角测量问题通常涉及到最小化重投影误差。"></p>
<p>虽然这个过程看起来既简单又数学合理，但在实践中并不是很好。在现实世界中，由于观测值$p$和$p’$有噪声，相机校准参数不精确，寻找$l$和$l’$的交点可能存在问题。在大多数情况下，它根本不存在，因为这两条线可能永远不会相交。        </p>
<h2 id="2-1-一种线性三角测量方法"><a href="#2-1-一种线性三角测量方法" class="headerlink" title="2.1 一种线性三角测量方法"></a>2.1 一种线性三角测量方法</h2><p>在本节中，我们将描述一个简单的线性三角测量方法，以解决射线之间缺乏交点。我们在图像中给出了两点相互对应的$p=MP=(x,y,1)$和$p’=M’P=(x’,y’,1)$。根据交叉积的定义，$p×(MP)=0$​。我们可以显式地使用交叉积生成的等式来形成三个约束：</p>
<script type="math/tex; mode=display">
\begin{matrix}
x(M_3P)-(M_1P)=0\\
y(M_3P)-(M_3P)=0\\
x(M_2P)-y(M_1P)=0
\end{matrix}\\tag{2.1}</script><p>其中$M_i$​是矩阵$M$​的第$i$​行。对于$p’$和$M’$也可以表示类似的约束。利用这两幅图像的约束条件，我们可以建立一个$AP=0$形式的线性方程，其中</p>
<script type="math/tex; mode=display">
A=\left[\begin{matrix}xM_3-M_1\\
yM_3-M_2\\
x'M_3-M_1'\\
y'M_3'-M_2'
\end{matrix}
\right ]
\tag{2.2}</script><p>该方程可以用SVD来求解，从而得到点$p$的最佳线性估计。该方法的另一个有趣的方面是，它实际上也可以处理来自多个视图的三角化。为此，简单地将添加的行附加到新视图添加的约束。</p>
<p>然而，该方法不适合用于射影重建，因为它不是射影不变的。例如，假设我们将相机矩阵M，M’替换为受射影变换$MH^{−1}$​，$M’H^{−1}$​影响的矩阵。线性方程A的矩阵变成$AH^{−1}$​。因此，之前对$AP=0$的估计的解决方案P将对应于转换问题$(AH^{−1})(HP)=0$的解决方案HP。回想一下，SVD解决了$||P||=1$​的约束，它在射影变换H下不是不变的。因此，该方法虽然简单，但往往不是三角剖分问题的最优解。</p>
<h2 id="2-2-对三角剖分的一种非线性方法"><a href="#2-2-对三角剖分的一种非线性方法" class="headerlink" title="2.2 对三角剖分的一种非线性方法"></a>2.2 对三角剖分的一种非线性方法</h2><p>相反，现实世界场景中的三角剖分问题通常被数学上描述为解决一个最小化问题：</p>
<script type="math/tex; mode=display">
\underset{\hat P} {min}\vert\vert M\hat P - p \vert \vert + \vert \vert M' \hat P-p' \vert \vert \tag{2.3}</script><p>在上述方程中，我们通过寻找两幅图像中Pˆ的重投影误差的最佳最小二乘估计值，来寻找一个最接近P的三维$\hat P$​。图像中三维点的重投影误差是图像中该点的投影与图像平面中对应的观测点之间的距离。在图2中我们的示例中，由于M是从三维空间到图像1的投影变换，所以图像1中$\hat P$​的投影点为$M\hat P$​。图1中$\hat P$​的匹配观测值为p。因此，图像1的重投影误差为距离$||M\hat P−p||$​。在公式2.3中发现的总体重投影误差是所有图像的重投影误差之和。对于有两幅以上图像的情况，我们只需在目标函数中添加更多的距离项：</p>
<script type="math/tex; mode=display">
\underset {\hat P}{\min} \sum _i ||M \hat P_i-p_i || ^2 \tag{2.4}</script><p>在实践中，存在着各种非常复杂的优化技术，它们可以很好地近似于问题。然而，对于该类的范围，我们将只关注其中一种技术，即非线性最小二乘的高斯-牛顿算法。一般的非线性最小二乘问题是找到一个最小化的$x∈R^n$​</p>
<script type="math/tex; mode=display">
\vert\vert r(x)\vert\vert^2 = \sum_{i=1}^mr_i(x)^2 \tag{2.5}</script><p>其中$r$是任何残差函数$r$：$R^n→R^m$​，这样对于某个函数f的$r(x)=f(x)-y$，输入$x$和观察$y$。当函数$f$为线性问题时，非线性最小二乘问题简化为正则的线性最小二乘问题。然而，回想一下，一般来说，我们的相机矩阵并不是仿射的。由于对图像平面的投影通常涉及到均匀坐标的除法，因此对图像的投影通常是非线性的。</p>
<p>请注意，如果我们将$e_i$​设置为一个$2×1$向量$e_i=M\hat P_i−p_i$​，那么我们可以重新表述我们的优化问题为：</p>
<script type="math/tex; mode=display">
\underset {\hat P}{\min} \sum _i e^i(\hat P)^2 \tag{2.6}</script><p>它可以完美地表示为一个非线性最小二乘问题。</p>
<p>在这些注释中，我们将介绍如何使用流行的高斯-牛顿算法来找到这个非线性最小二乘问题的近似解。首先，让我们假设我们对三维点$\hat P$​有一个有点合理的估计，我们可以用前面的线性方法来计算它。高斯-牛顿算法的关键见解是更新我们的估计，将其修正为一个更好的估计，从而最小化重投影误差。在每一步，我们想更新一些估计$\hat Pδ_P：\hat P=\hat P+δ_P$​。</p>
<p>但是我们如何选择更新参数$δ_P$​呢？高斯-牛顿算法的关键见解是线性化在当前估计$\hat P$​附近的残差函数。在我们的问题中，这意味着一个点P的残差e可以看作是：</p>
<script type="math/tex; mode=display">
e(\hat P+\delta_p) \approx e(\hat P)+\frac{\partial e}{\partial P}\delta_p \tag{2.7}</script><p>随后，将最小化问题转化为</p>
<script type="math/tex; mode=display">
\underset{\delta _P}{min} \vert \vert \frac {\partial e}{\partial P} \delta_P- (-e(\hat P)) \vert \vert^2 \tag{2.8}</script><p>当我们这样表示残差时，我们可以看到它采用了标准线性最小二乘问题的格式。对于$N$幅图像的三角剖分问题，线性最小二乘解为</p>
<script type="math/tex; mode=display">
\delta _P = -(J^TJ)^{-1}J^Te \tag{2.9}</script><p>其中</p>
<script type="math/tex; mode=display">
e = \left[
\begin {matrix}
e_1\\ 
\vdots
\\e_N
\end{matrix}
\right]=
\left[
\begin{matrix}
p_1-M_1\hat P
\\ \vdots
\\p_n-M_n\hat P
\end{matrix}
\right]\tag{2.10}</script><script type="math/tex; mode=display">
J=\left[
\begin {matrix}
\frac {\partial e_1} {\partial \hat P_1}& \frac {\partial e_1} {\partial \hat P_2}& \frac {\partial e_1} {\partial \hat P_3}\\
\vdots &\vdots& \vdots \\
\frac {\partial e_N} {\partial \hat P_1}& \frac {\partial e_N} {\partial \hat P_2}& \frac {\partial e_N} {\partial \hat P_3}
\end{matrix}
\right] \tag{2.11}</script><p>​        回想一下，一个特定图像$e_i$的残差向量是一个2×1向量，因为在图像平面上有二维空间。因此，在最简单的三角测量的两个相机情况($N=2$)中，这导致残差向量$e$是一个$2N×1=4×1$向量，雅可比矩阵$J$是一个$2N×3=4×3$矩阵。请注意该方法如何无缝地处理多个视图，因为通过将相应的行添加到e向量和J矩阵来解释额外的图像。在计算了更新$δ_P$之后，我们可以简单地对固定数量的步骤重复这个过程，或者直到它在数值上收敛。高斯-牛顿算法的一个重要性质是，我们假设残差函数接近我们的估计是线性的，这不能保证收敛。因此，在实践中，对估计数的更新次数设置一个上限总是有用的。</p>
<h2 id="3-从运动开始的仿射结构"><a href="#3-从运动开始的仿射结构" class="headerlink" title="3 从运动开始的仿射结构"></a>3 从运动开始的仿射结构</h2><p>在前一节的结尾，我们暗示了如何超越一个场景的两个视图来获得关于3D场景的信息。我们现在将探索将两个相机的几何形状扩展到多个相机。通过结合来自多个视角的点的观察，我们将能够同时确定场景的三维结构和摄像机的参数，即所谓的<strong>运动结构</strong>。</p>
<p><img src="/2021/12/07/L4/3.PNG" alt="图3：基于运动问题的总体结构的设置。"></p>
<p>在这里，我们正式地介绍了从运动问题出发的结构。假设我们有$m$个相机与相机转换$M_i$编码相机的内在和外在参数。设$X_j$为场景中的$n$个3D点之一。每个3D点可以在多个位于$x_{ij}$位置的摄像机中可见，即使用投影变换$M_i$对摄像机$i$图像的投影。运动结构的目的是从所有观测值$x_{ij}$中恢复场景的结构（$n$三维点$X_j$）和摄像机的运动（$m$投影矩阵$M_i$​）。</p>
<h3 id="3-1由运动问题引起的仿射结构"><a href="#3-1由运动问题引起的仿射结构" class="headerlink" title="3.1由运动问题引起的仿射结构"></a>3.1由运动问题引起的仿射结构</h3><p>在解决运动问题的一般结构之前，我们将首先从一个更简单的问题开始，即假设相机是仿射或弱视角。最终，由于缺乏透视图的缩放操作，这使得数学推导更容易解决这个问题。</p>
<p>之前，我们推导了上述透视和弱透视情况的方程。请记住，在全透视模型中，相机矩阵被定义为</p>
<script type="math/tex; mode=display">
M = \left[
\begin{matrix}
A & b
\\ v & 1
\end{matrix}
\right]\tag{3.1}</script><p>其中$v$是一些非零的$1×3$向量。另一方面，对于弱透视模型，$v=0$。我们发现这个性质使$MX$的齐次坐标等于$1$：</p>
<script type="math/tex; mode=display">
x=MX=\left[
\begin{matrix}
& m_1\\
& m_2\\
0&0&0&1
\end{matrix}
\right]
\left[
\begin{matrix}
X_1\\
X_2\\
X_3\\
1
\end{matrix}
\right]=
\left[
\begin{matrix}
m_1X\\
m_2x\\
1
\end{matrix}
\right]
\tag{3.2}</script><p>因此，当我们从齐次坐标移动到欧几里得坐标时，投影变换的非线性消失了，而弱透视变换仅仅作为一个放大镜。我们可以更紧凑地将投影表示为：              </p>
<script type="math/tex; mode=display">
\left[
\begin{matrix}
m_1X\\
m_2X
\end{matrix}
\right]=
\left[
\begin{matrix}
A &b
\end{matrix}
\right]X
=
AX+    b
\tag{3.3}</script><p>并以仿射$M_{affine}=[A\ \ b]$​.的格式表示任何相机矩阵因此，我们现在使用仿射相机模型来表示三维中的$X_j$​点和每个仿射相机中相应的观察结果(例如，相机$i$​中的$x_{ij}$​)。</p>
<p>从运动问题回到结构，我们需要从$m ,n$​观测中估计m个矩阵$M_i$​和n个世界坐标向量$X_j$​，总共有$8m+3n$个未知数。每个观测结果对每个相机产生$2$个约束，所以在$8m+3n$未知数中有$2mn$方程。我们可以用这个方程来知道我们需要拥有的每张图像中相应观测数的下界。例如，如果我们有$m=2$个相机，那么我们需要在3D中至少有$n$个$=16$点。然而，一旦我们在每张图像中都标记了足够的对应点，我们如何解决这个问题呢？</p>
<h3 id="3-2托马西和卡纳德分解方法"><a href="#3-2托马西和卡纳德分解方法" class="headerlink" title="3.2托马西和卡纳德分解方法"></a>3.2托马西和卡纳德分解方法</h3><p>在这部分中，我们概述了托马西和卡纳德求解仿射结构的分解方法。该方法主要包括数据定心步骤和实际分解步骤。</p>
<p><img src="/2021/12/07/L4/4.PNG" alt="图4：当应用定心步骤时，我们对所有的图像点进行平移，使其质心（记为左下红十字）位于图像平面的原点。同样地，我们将世界坐标系置为原点位于三维点的质心处（记为右上角的红十字）。"></p>
<p>让我们从数据定中心的步骤开始。在这一步中，主要的思想是将数据集中在原点。为此，对于每个图像$i$​，我们通过减去其质心$\hat x_{ij}$​来重新定义每个图像点$x_{ij}$​的新坐标$\bar {x_{ij}}$​​：</p>
<script type="math/tex; mode=display">
\hat x_{ij}= x_{ij}-\bar x_i=x_{ij}-\frac {1}{n}\sum_{j=1}^nx_{ij}\tag{3.4}</script><p>回想一下，来自运动问题的仿射结构允许我们定义图像点$x_{ij}$​、相机矩阵变量$A_i$​和$b_i$​，以及三维点$X_j$​之间的关系为：</p>
<script type="math/tex; mode=display">
x_{ij}=A_jX_j+b_i\tag{3.5}</script><p>在这个定心步骤之后，我们可以结合公式$3.4$中的中心图像点$\hat x_{ij}$​的定义和公式$3.5$中的仿射表达式：</p>
<script type="math/tex; mode=display">
\begin{align}
\hat x_{ij}&=\hat x_{ij}-\frac{1}{n}\sum_{k=1}^nx_{ik}\\
& =
A_iX_j-\frac {1}{n}\sum_{k=1}^nA_iX_k
\\
& =A_i(X_j-\frac {1}{n}\sum_{k=1}^nX_k)
\\
& =A_i(X_j-\bar X)\\
&=A_i\hat X_j 

\end{align}\tag{3.6}</script><p>从方程3.6中可以看出，如果我们将世界参考系统的起源转换为质心$\bar X$​​，那么图像点$x_{ij}$​​的中心坐标和3D点$\hat X_{ij}$​​的中心坐标仅通过一个$2×3$矩阵$A_i$​​进行关联。最终，分解方法的定心步骤允许我们创建一个紧凑的矩阵积表示，将三维结构与多个图像中的观测点联系起来。</p>
<p>但是，请注意，在矩阵乘积$\hat x_{ij}=A_i\hat X_j$​中，我们只能访问方程左侧的值。因此，我们必须以某种方式考虑出运动矩阵$A_i$​和结构$X_j$​。利用所有摄像机的所有观测结果，我们可以建立一个测量矩阵$D$，由$m$个摄像机中的$n$个观测结果组成(记住，每个$\hat x_{ij}$​入口都是一个$2×1$向量)：</p>
<script type="math/tex; mode=display">
D=\left[
\begin{matrix}
\hat x_11 & \hat x_12 &\cdots &\hat x_1n\\
\hat x_21 & \hat x_22 &\cdots &\hat x_2n\\
\vdots&\vdots&\ddots&\vdots \\
\hat x_m1 & \hat x_m2 &\cdots & \hat x_mn\\
\end{matrix}
\right]\tag{3.7}</script><p>现在回想一下，由于我们的仿射假设，D可以表示为$2m×3$​运动矩阵$M$(包括相机矩阵$A_1，…A_m$)和$3×n$结构矩阵$S$(包括3D点$X_1，…X_n$​​)的乘积。我们将使用的一个重要事实是秩$D$为$3$，因为$D$是两个最大维数为3的矩阵的乘积。</p>
<p>为了将$D$分解为$M$和$S$，我们将使用奇异值分解，$D=UΣV^T$​。因为我们知道秩为$D=3$，所以在$Σ$中只有$3$个非零奇异值$σ_1$，$σ_2$和$σ_3$。因此，我们可以进一步简化的表达式，得到以下分解方法：</p>
<script type="math/tex; mode=display">
\begin{align}
D&=U\sum V^T\\
    &=\left[
    \begin{matrix}u_1&\cdots&u_n
    \end {matrix}\right]
    \left[
    \begin{matrix}
    \sigma_1&0&0&0&\cdots&0\\
    0&\sigma_2&0&0&\cdots&0\\
    0&0&\sigma_3&0&\cdots&0\\
    0&0&0&0&\cdots&0\\
    \ & \ & \ & \ &\ddots &\ \\
    0&0&0&0&\cdots&0\\
    \end{matrix}
    \right]
    \left[
    \begin{matrix}v_1^T\\ \vdots \\ v_n^T
    \end {matrix}\right]\\
    & =\left[
    \begin{matrix}u_1&u_2&u_3
    \end {matrix}\right]
    \left[
    \begin{matrix}\sigma_1&0&0\\
    0&\sigma_2&0\\
    0&0&\sigma_3&\\
    \end {matrix}\right]
        \left[
    \begin{matrix}v_1^T\\ v_2^T\\ v_n^T
    \end {matrix}\right]\\
    &=U_3Σ_3V_3^T 
\end{align}    \tag{3.8}</script><p>在此分解中，$Σ_3$​定义为非零奇异值形成的对角矩阵，而$U_3$和$V_3T$分别取对应的$U$列和$V^T$​行得到。不幸的是，在实践中，由于测量噪声和仿射相机近似，秩$D&gt;3$。然而，请记住，当秩$D&gt;3$时，$U_3W_3V_3^T$​仍然是弗罗比尼乌斯范数意义上的最好的秩3近似。</p>
<p>经过仔细检查，我们发现矩阵积$Σ_3V_3^T$​​形成一个$3×n$​的矩阵，大小完全相同的结构矩阵$S$​类似，同样$U_3$​是一个$2m×3$矩阵，相同大小的运动矩阵M。虽然这种关联的组件SVD分解M和S导致一个物理和几何解的仿射结构从运动问题，这个选择不是一个唯一的解决方案。例如，我们也可以将运动矩阵设置为$M=U_3Σ_3$，将结构矩阵设置为$S=V_3^T$，因为在这两种情况下，观测矩阵$D$都是相同的。那么我们要选择什么因子分解呢？托马西和卡纳德得出结论，该因素分解的稳健选择是$M=U_3\sqrt{Σ_3}$和$S=\sqrt{Σ_3}V_3^T$​​。</p>
<h3 id="3-3-重建中的模糊性"><a href="#3-3-重建中的模糊性" class="headerlink" title="3.3 重建中的模糊性"></a>3.3 重建中的模糊性</h3><p>不过，我们发现在任何分解$D=MS$的选择中有固有的歧义，因为任何任意的、可逆的$3×3$矩阵$A$都可以插入到分解中：</p>
<script type="math/tex; mode=display">
D = MAA^{−1}S = (MA)(A^{−1}S) \tag{3.9}</script><p>这意味着从运动$M$获得的相机矩阵和从结构$S$获得的三维点可以乘以$10$个公共矩阵$a$。因此，我们的解决方案尚未确定，需要额外的约束来解决这种仿射歧义。当重构具有仿射模糊性时，这意味着保持了并行性，但度量尺度是未知的。</p>
<p>重建的另一类重要的歧义是相似度歧义，当重建被修正到相似度变换（旋转、平移和缩放）时，就会发生相似度歧义。一个只有相似性歧义的重构被称为度量重构。即使相机经过本质校准，这种模糊性也存在。好消息是，对于校准的相机，相似模糊是唯一的模糊。</p>
<p>事实上没有办法从图像中恢复一个场景的绝对尺度。除非我们做出进一步的假设（例如，我们知道图中房子的高度）或包含更多的数据，否则一个物体的尺度、绝对位置和规范方向总是未知的。这是因为某些属性可以补偿其他属性。例如，为了获得相同的图像，我们可以简单地向后移动对象，并相应地缩放它。在相机校准过程中出现了一个消除相似性模糊性的例子，我们假设我们知道校准点相对于现实世界参考系统的位置。这使我们能够知道棋盘上的正方形的大小，以学习三维结构的度量尺度。</p>
<h2 id="4-从运动开始的透视结构"><a href="#4-从运动开始的透视结构" class="headerlink" title="4 从运动开始的透视结构"></a>4 从运动开始的透视结构</h2><p>在研究了运动问题的简化仿射结构后，再考虑射影相机$M_i$​的一般情况。在一般情况下使用投影摄像机，每个相机矩阵$M_i$​包含$11$个自由度，因为它是被定义为：</p>
<script type="math/tex; mode=display">
M_i=\left[
\begin{matrix}
a_11 &a_12 &a_13 b_1\\
a_21 &a_22 &a_23 b_1\\
a_31 &a_32 &a_33 1
\end{matrix}
\right]
\tag{4.1}</script><p>此外，类似于仿射情况下的解可以找到一个仿射变换，解决结构和运动可以确定一个射影变换在一般情况下：我们总是可以任意应用一个4×4射影变换H运动矩阵，只要我们也变换结构矩阵的逆变换$H^{−1}$​。在图像平面上得到的观测结果仍然相同。</p>
<p>与仿射情况类似，我们可以从运动问题建立一般结构，从$m,n$观测$x_{ij}$估计$m$运动矩阵$M_i$和$n$三维点$X_j$​。因为相机和点只能在$4×4$投影变换（$15$个参数）上恢复，我们在$2mm$方程中有$11m+3n−15$未知数。根据这些事实，我们可以确定解决未知问题所需的观点和观察结果的数量</p>
<h3 id="4-1-代数方法"><a href="#4-1-代数方法" class="headerlink" title="4.1 代数方法"></a>4.1 代数方法</h3><p><img src="/2021/12/07/L4/5.PNG" alt="图5：在代数方法中，我们考虑顺序的，相机对来确定相机矩阵$M_1$和$M_2$，直到一个透视变换。"></p>
<p>图5：在代数方法中，我们考虑顺序的，相机对来确定相机矩阵$M_1$​和$M_2$​，直到一个透视变换。然后我们发现了一个透视变换H，即$M_1H=[I \ \ \ \  0]和M_2H=[A\ \ \ \ B]$​</p>
<p>我们现在将介绍代数方法，它利用基本矩阵F的概念来解决两个相机的运动问题的结构。如图5所示，代数方法的主要思想是计算两个相机矩阵$M_1$​和$M_2$​，这只能计算到一个透视变换H。由于每个Mi只能计算一个透视变换H，我们总是可以考虑一个H，这样第一个相机投影矩阵$M_1H^{−1}$​是典型的。当然，同样的转换也必须应用于第二个相机，这导致了显示的形式：</p>
<script type="math/tex; mode=display">
M_1H^{-1}=[I \ \ \ \ \ 0]\ \ \ \ M_2H^{-1}=[A\ \ \ \ \ B]\tag{4.2}</script><p>​        为了完成这一任务，我们必须首先使用前面的课程注释中提到的八点算法来计算基本矩阵F。我们现在将使用F来估计射影相机矩阵$M_1和M_2$​。为了做这个估计，我们将P定义为图像p和p’中相应观测值的相应三维点。由于我们已经将$H^{−1}$​应用于两个相机投影矩阵，所以我们也必须将H应用于结构，给我们$\tilde P=HP$​。因此，我们可以将像素坐标$p$和$p’$与转换后的结构联系起来如下：</p>
<script type="math/tex; mode=display">
\begin{matrix}
p=M_1P=M_1H^{−1}H P=[I\ \ |\ \ 0]\tilde P\\
p'=M_2P=M_2H^{−1}HP=[A\ \ |\ \ b]\tilde P
\end{matrix}\tag{4.3}</script><p>两个图像对应的p和p’之间的一个有趣的属性通过一些创造性的替换而出现：</p>
<script type="math/tex; mode=display">
\begin{align}
p' 
&= [A|b]\tilde P\\[2ex]
&=  A[I|0]\tilde P + b \\[2ex]
&= Ap + b\\[2ex]
\end{align} \tag{4.4}</script><p>利用公式4.4，我们可以将p’和b之间的交叉积写为：</p>
<script type="math/tex; mode=display">
p' × b = (Ap + b) × b = Ap × b \tag{4.5}</script><p>根据交叉积的定义，p’×b垂直于p’。因此，我们可以写道：</p>
<script type="math/tex; mode=display">
\begin{align}
0
&= p' ^T (p' × b)\\[2ex]
&= p' ^T (Ap × b) \\[2ex]
&= p' ^T · (b × Ap) \\[2ex]
&= p' ^T [b]_×Ap
\end{align}
\tag{4.6}</script><p>看看这个约束条件，它应该会提醒你基本矩阵$p’^TFp=0$​的一般定义。如果我们设置了$F=[b]_×A$​，那么提取A和b就会简单地分解为一个分解问题。</p>
<p>让我们从确定$b$开始。同样，根据交叉积的定义，我们可以简单地把$Fb$写成</p>
<script type="math/tex; mode=display">
F b = [b]_×Ab = (b × A)b = 0 \tag{4.7}</script><p>由于F是奇异的，$b$可以用SVD,在$||b||=0$的条件下计算为$k=0$的最小二乘解。</p>
<p>一旦$b$知道，我们就可以计算$A$。如果我们设置了一个$A=−[b]_×F$，那么我们可以验证这个定义满足$F=[b]_×A$​：</p>
<script type="math/tex; mode=display">
\begin{align}
[b_×]A' =
&−[b×][b×]F\\[2ex]
&= (bb^T − |b|^2I)F \\[2ex]
&= bb^TF + |b|^2F\\[2ex]
&= 0 + 1 · F \\[2ex]
&= F
\end{align}
\tag{4.8}</script><p>​    因此，我们确定了相机矩阵$M_1H^{−1}$和$M_2H^{−1}$的两个表达式：</p>
<script type="math/tex; mode=display">
\tilde M_1 = [I\ \ \ \  0] \ \ \ \ \ \ \ \tilde M_2 = [−[e_×]F \ \ \ \ e] \tag{4.10}</script><h3 id="4-2-从本征矩阵中确定运动"><a href="#4-2-从本征矩阵中确定运动" class="headerlink" title="4.2 从本征矩阵中确定运动"></a>4.2 从本征矩阵中确定运动</h3><p>改进由代数方法得到的重建的一个有用的方法是使用校准的相机。利用基本矩阵是标准化坐标基本矩阵的一种特殊情况，可以提取出相机矩阵的更精确的初始估计。回想一下，通过使用基本矩阵E，我们假设我们已经校准了相机，从而知道内在相机矩阵$K$。我们可以直接从归一化图像坐标，也可以从它与基本矩阵$F$和内在矩阵$K$的关系来计算基本矩阵$E$：</p>
<script type="math/tex; mode=display">
E = K^TFK \tag{4.11}</script><p>因为基本矩阵假设我们有校准的相机，我们应该记住它只有$5$个自由度，因为它只有编码外部参数：相机之间的旋转$R$和平移$t$。幸运的是，这正是我们想要提取的用来创建运动矩阵的信息。首先，记住基本矩阵E可以表示为</p>
<script type="math/tex; mode=display">
E = [t]_×R \tag{4.12}</script><p>因此，也许我们可以找到一种策略来将E纳入其两个组成部分。首先，我们应该注意到交叉积矩阵$[t]_×$是偏对称的。我们定义了两个我们将在分解中使用的矩阵：</p>
<script type="math/tex; mode=display">
W=\left[
\begin{matrix}
0&-1&0\\
1&0&0\\
0&0&1
\end{matrix}
\right]
,
\ \ \ \ \ \ \
Z=\left[
\begin{matrix}
0&1&0\\
-1&0&0\\
0&0&0
\end{matrix}
\right]
\tag{4.13}</script><p>我们稍后将使用的一个重要特性是$Z=diag(1,1,0)W$到一个标志。类似地，我们也将使用$ZW=ZW^T=diag(1,1,0)$到一个符号。</p>
<p>由于特征值分解的结果，我们可以创建一个已知的一般偏对称矩阵的块分解。因此，我们可以将$[t]_×$写为</p>
<script type="math/tex; mode=display">
[t]_× = UZU^T \tag{4.14}</script><p>其中$U$是某个正交矩阵。因此，我们可以将该分解数重写为：</p>
<script type="math/tex; mode=display">
E = Udiag(1,1,0)(W U^TR)\tag{4.15}</script><p>仔细观察这个表达式，我们发现它非常类似于奇异值分解$E=UΣV^T$，其中Σ包含两个相等的奇异值。如果我们知道E，并且我们假设它采用了$E=Udiag(1,1,0)V^T$的形式，那么我们得到了E的以下分解：</p>
<script type="math/tex; mode=display">
[t]_×=UZU^T，\ \ R=UWV^T \ \ or\ \  UW^TV^T \tag{4.17}</script><p>通过检验，我们可以证明所给定的分解是有效的。我们还可以证明没有其他因素的分解。$[t]_×$的形式是由它的左零空间必须与E的零空间相同而决定的。给定一元矩阵U和V，任何旋转R都可以分解为$UXV^T$，其中X是另一个旋转矩阵。在替换这些值后，我们得到了$ZX=diag(1,1,0)$。因此，X必须等于W或$W^T$。</p>
<p>请注意，E的这种分解只保证了矩阵$UWV^T$或$UW^TV^T$是正交的。为了确保R是一个有效的旋转，我们只是要确保R的行列式是正的：</p>
<script type="math/tex; mode=display">
R=(detUW^TV^T)UWV^T\ \ \ \ or \ \ \ \ (detUW^TV^T)UW^TV^T \tag{4.17}</script><p>与类似于旋转$R$如何取两个潜在值相似，平移向量$t$也可以取几个值。从交叉积的定义中来看，我们知道</p>
<script type="math/tex; mode=display">
t × t = [t]_×t = UZU^T t = 0 \tag{4.18}</script><p>知道$U$是一元的，我们可以发现$||[t]_×||F=\sqrt{2}$。因此，我们从这个分解的$t$估计将从上面的方程和$E$是已知的，这意味着</p>
<script type="math/tex; mode=display">
t= \pm U\left[\begin{matrix}0\\0\\1\end{matrix}\right]=\pm u_3 \tag{4.13}</script><p>其中$u_3$是$U$的第三列。通过检查，我们还可以通过将$[t]_×=UZU^T$重新格式化为已知的向量$t$来验证我们得到相同的结果。</p>
<p><img src="/2021/12/07/L4/blog\source\_posts\视觉4.assets\image-20211206004541777-16387227427507.png" alt="image-20211206004541777"></p>
<p>图6：从基本矩阵中提取相对相机旋转R和平移t有四种可能的解决方案。然而，只有(a)中重建点在两个摄像机前。（图片取自哈特利和齐泽尔曼出版社的教科书第260页）</p>
<p>如图6所示，由于$R$和$t$同时存在两种选项，因此$R$和$t$都存在两种选项。直观地说，这四对对包括所有$16$种可能的对，即在特定方向旋转相机或在相反方向旋转相机，以及在特定方向或相反方向移动相机的选择。因此，在理想条件下，我们只需要三角化一个点来确定正确的一对$R$，$t$对。对于正确的一对$R$，$t$，三角化的点$\hat P$存在于两个相机的前面，这意味着它相对于两个相机参考系统都有一个正的$z$坐标。由于测量噪声，我们通常不依赖于三角点，而是三角测量许多点，并确定正确的一对$R$，$t$，作为两个相机前包含这些点的大多数。</p>
<h2 id="5-一个来自运动管道的结构示例"><a href="#5-一个来自运动管道的结构示例" class="headerlink" title="5 一个来自运动管道的结构示例"></a>5 一个来自运动管道的结构示例</h2><p>在找到相对运动矩阵$M_i$后，我们可以用它们来确定点$X_j$的世界坐标。在代数方法的情况下，这些点的估计将修正透视变换h。在从基本矩阵中提取相机矩阵时，估计可以被知道。在这两种情况下，三维点都可以通过前面描述的三角测量方法从估计的相机矩阵中计算出来。</p>
<p>对多视图案例的扩展可以通过链接成对的摄像机来完成。利用代数方法或基本矩阵，我们可以利用代数方法得到任意一对相机的相机矩阵和三维点的解，只要有足够的点对应。重建的3D点与相机对之间可用的点对应关系相关联。我们接下来将看到，这些成对的解决方案可以以一种称为捆绑调整的方法组合在一起（优化）。</p>
<h3 id="5-1-套件调整"><a href="#5-1-套件调整" class="headerlink" title="5.1 套件调整"></a>5.1 套件调整</h3><p>到目前为止，我们讨论的从运动问题解决结构的方法有很大的局限性。该分解方法假设所有的点在每幅图像中都是可见的。这是不太可能发生的，因为当我们有很多图像，或者有些图像相距遥远时，就会被遮挡，无法找到对应关系。最后，代数方法产生了成对的解，可以组合成一个摄像机链，但不能解决使用所有摄像机和三维点的相干优化重建。</p>
<p>为了解决这些限制，我们引入了<strong>束调整</strong>，这是一种从运动问题中求解结构的非线性方法。在优化中，我们的目标是尽量减少重投影误差，即一个重建点对估计摄像机的投影与其对所有摄像机和所有点的相应观测值之间的像素距离。之前，当讨论三角剖分的非线性优化方法时，我们主要关注这两个相机盒，我们自然地假设每个相机看到了两者之间的所有对应关系。然而，由于束束调整处理几个相机，它只计算每个相机可以看到的观测结果的重投影误差。最终，这个优化问题与我们在讨论三角测量的非线性方法时引入的问题非常相似。</p>
<p>求解束调整非线性优化的两种常用方法包括高斯-牛顿算法和莱文伯格-马夸特算法。您可以参考上一节关于高斯牛顿算法的细节，并参考哈特利和泽瑟曼教科书，了解更多关于莱文伯格-马夸特算法的细节。</p>
<p>综上所述，与我们所调查的其他方法相比，管束调整有一些重要的优点和局限性。它特别有用，因为它可以平滑地处理大量的视图，而且也可以处理每个图像都不能观察到特定点时的情况。然而，主要的限制是它是一个特别大的最小化问题，因为参数随着视图数量的增长。此外，由于它依赖于非线性优化技术，因此需要一个很好的初始条件。因此，束调整经常被用作来自运动实现的大多数结构的最后一步（即，在因子分解或代数方法之后），因为一种因子分解或代数方法可以为优化问题提供一个很好的初始解决方案。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>感谢打赏.</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="小学渣的春天 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="小学渣的春天 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" rel="tag"># 计算机视觉</a>
              <a href="/tags/cs231a/" rel="tag"># cs231a</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/12/06/Chapter1/" rel="prev" title="npuSE Chapter 1 绪论">
      <i class="fa fa-chevron-left"></i> npuSE Chapter 1 绪论
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/12/07/L3/" rel="next" title="cs231a Course 3：对极几何">
      cs231a Course 3：对极几何 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  <div>
    
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">------ 本文结束------</div>
    
</div>
    
 </div>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Course-4%EF%BC%9A%E7%AB%8B%E4%BD%93%E5%A3%B0%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%BF%90%E5%8A%A8%E7%BB%93%E6%9E%84%E6%81%A2%E5%A4%8D"><span class="nav-number">1.</span> <span class="nav-text">Course 4：立体声系统和运动结构恢复</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.</span> <span class="nav-text">1  介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86"><span class="nav-number">1.2.</span> <span class="nav-text">2 三角剖分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E4%B8%80%E7%A7%8D%E7%BA%BF%E6%80%A7%E4%B8%89%E8%A7%92%E6%B5%8B%E9%87%8F%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">2.1 一种线性三角测量方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E5%AF%B9%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86%E7%9A%84%E4%B8%80%E7%A7%8D%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%96%B9%E6%B3%95"><span class="nav-number">1.4.</span> <span class="nav-text">2.2 对三角剖分的一种非线性方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BB%8E%E8%BF%90%E5%8A%A8%E5%BC%80%E5%A7%8B%E7%9A%84%E4%BB%BF%E5%B0%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.</span> <span class="nav-text">3 从运动开始的仿射结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1%E7%94%B1%E8%BF%90%E5%8A%A8%E9%97%AE%E9%A2%98%E5%BC%95%E8%B5%B7%E7%9A%84%E4%BB%BF%E5%B0%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.1.</span> <span class="nav-text">3.1由运动问题引起的仿射结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2%E6%89%98%E9%A9%AC%E8%A5%BF%E5%92%8C%E5%8D%A1%E7%BA%B3%E5%BE%B7%E5%88%86%E8%A7%A3%E6%96%B9%E6%B3%95"><span class="nav-number">1.5.2.</span> <span class="nav-text">3.2托马西和卡纳德分解方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E9%87%8D%E5%BB%BA%E4%B8%AD%E7%9A%84%E6%A8%A1%E7%B3%8A%E6%80%A7"><span class="nav-number">1.5.3.</span> <span class="nav-text">3.3 重建中的模糊性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%BB%8E%E8%BF%90%E5%8A%A8%E5%BC%80%E5%A7%8B%E7%9A%84%E9%80%8F%E8%A7%86%E7%BB%93%E6%9E%84"><span class="nav-number">1.6.</span> <span class="nav-text">4 从运动开始的透视结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E4%BB%A3%E6%95%B0%E6%96%B9%E6%B3%95"><span class="nav-number">1.6.1.</span> <span class="nav-text">4.1 代数方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E4%BB%8E%E6%9C%AC%E5%BE%81%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%A1%AE%E5%AE%9A%E8%BF%90%E5%8A%A8"><span class="nav-number">1.6.2.</span> <span class="nav-text">4.2 从本征矩阵中确定运动</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E4%B8%80%E4%B8%AA%E6%9D%A5%E8%87%AA%E8%BF%90%E5%8A%A8%E7%AE%A1%E9%81%93%E7%9A%84%E7%BB%93%E6%9E%84%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.7.</span> <span class="nav-text">5 一个来自运动管道的结构示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E5%A5%97%E4%BB%B6%E8%B0%83%E6%95%B4"><span class="nav-number">1.7.1.</span> <span class="nav-text">5.1 套件调整</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="小学渣的春天"
      src="/images/machao.jpg">
  <p class="site-author-name" itemprop="name">小学渣的春天</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element"><i class="fa fa-comment"></i>
    Chat
  </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3djeDIwMDE=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wcx2001"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <a href="/1430466592@qq.com" title="E-Mail → 1430466592@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly93d3cubndwdS5lZHUuY24v" title="https:&#x2F;&#x2F;www.nwpu.edu.cn&#x2F;">西北工业大学</span>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小学渣的春天</span>
</div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js"></script>
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  




  
<script src="/js/local-search.js"></script>









<script data-pjax>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

    </div>
</body>
</html>
