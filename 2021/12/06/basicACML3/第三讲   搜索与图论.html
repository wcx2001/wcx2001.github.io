<h1 id="第三讲-搜索与图论"><a href="#第三讲-搜索与图论" class="headerlink" title="第三讲   搜索与图论"></a>第三讲   搜索与图论</h1><h2 id="3-1-DFS与BFS"><a href="#3-1-DFS与BFS" class="headerlink" title="3.1 DFS与BFS"></a>3.1 DFS与BFS</h2><h3 id="3-1-1-DFS"><a href="#3-1-1-DFS" class="headerlink" title="3.1.1 DFS"></a>3.1.1 DFS</h3><h4 id="1-什么是DFS"><a href="#1-什么是DFS" class="headerlink" title="1.什么是DFS"></a>1.什么是DFS</h4><p> <strong>深度优先搜索算法</strong>（Depth First Search，简称DFS）：一种用于遍历或搜索树或图的算法。 沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过或者在搜寻时结点不满足条件，搜索将回溯到发现节点v的那条边的起始节点。整个进程反复进行直到所有节点都被访问为止。</p>
<p>简单的说就是可着一条路，使劲找，如果不符合条件就回到上一步，如果符合条件就继续找，直到找到全部的解为止。</p>
<p>当问题是让你找到<strong>*全部方案*</strong>时，选用<strong>*DFS*</strong></p>
<h4 id="2-模板讲解"><a href="#2-模板讲解" class="headerlink" title="2.模板讲解"></a>2.模板讲解</h4><pre><code class="lang-c++">int check(参数)
{
    if(满足条件)
        return 1;
    return 0;
}
void dfs(int step)
{
        判断边界，若达到边界
        {
            相应操作
        }
        若未达到边界，尝试每一种可能
        {
               满足check条件
               标记
               继续下一步dfs(step+1)
               恢复初始状态（回溯的时候要用到）
        }
}
</code></pre>
<h4 id="3-例题和代码"><a href="#3-例题和代码" class="headerlink" title="3.例题和代码"></a>3.例题和代码</h4><h5 id="第一题-题目描述"><a href="#第一题-题目描述" class="headerlink" title="第一题    题目描述"></a>第一题    题目描述</h5><h5 id="排列数字"><a href="#排列数字" class="headerlink" title="排列数字"></a>排列数字</h5><p>给定一个整数$n$，将数字 $1∼n$ 排成一排，将会有很多种排列方法。</p>
<p>现在，请你按照字典序将所有的排列方法输出。</p>
<h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><p>共一行，包含一个整数 $n$</p>
<h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>按字典序输出所有排列方案，每个方案占一行。</p>
<h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1 ≤ n ≤ 7$</p>
<h5 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h5><pre><code>3
</code></pre><h5 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h5><pre><code>1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
</code></pre><h5 id="本题分析"><a href="#本题分析" class="headerlink" title="本题分析"></a>本题分析</h5><p>先画一下本题的解空间树 首先以3为例</p>
<p><img src="3.1.1.png" alt=""></p>
<p>看到本图我们就知道，为什么这个叫解空间树了，它不仅包含本题的全部的解，形状还像一颗树。</p>
<p>因为<em>n=3</em>所以我们假设有3个空位，我们每次给空位填的数字都是我们当前方案中未填过的数字（即无数字重复）</p>
<p>最开始的时候 <em>— — —</em></p>
<p>从1开始 故  <em>1 — —</em></p>
<p><em>1 — —</em>从1开始，因为1填过了 所以填2   <em>1 2 —</em></p>
<p>显然第三次只能填3 即 <em>1 2 3</em> 第一种方案完成 此时我们要回到上一步即<em>1 2 —</em>发现还是没有不同的选择</p>
<p>再返回一步即<em>1 — —</em>发现可以通过填3来形成新的方案<em>1 3 —</em>从而找到<em>1 3 2</em></p>
<p>以此类推，遍历解空间树，从而找到全部的解方案。</p>
<h5 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="lang-c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
int n;
int a[10];
bool st[10];//标记数组 防止出现重复数字 即112 331
void dfs(int t)
{
    if(t==n)
    {
        for(int i=0;i&lt;n;i++)
        {
            cout&lt;&lt;a[i]&lt;&lt;&#39; &#39;;
        }
        cout&lt;&lt;endl;
    } else
    {
        for(int i=1;i&lt;=n;i++)
        {
            if(!st[i])
            {
                st[i]= true;
                a[t]=i;
                dfs(t+1);
                st[i]= false;
            }
        }
    }
}
int main() {
    cin&gt;&gt;n;
    dfs(0);
    return 0;
}
</code></pre>
<h5 id="第二题-题目描述-n-皇后问题"><a href="#第二题-题目描述-n-皇后问题" class="headerlink" title="第二题 题目描述   n-皇后问题"></a>第二题 题目描述   n-皇后问题</h5><p>$n−$皇后问题是指将 $n$ 个皇后放在 $n×n$ 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。</p>
<p>现在给定整数 $n$，请你输出所有的满足条件的棋子摆法。</p>
<h5 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h5><p>共一行，包含整数 $n$。</p>
<h5 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h5><p>每个解决方案占 $n$ 行，每行输出一个长度为 $n$ 的字符串，用来表示完整的棋盘状态。</p>
<p>其中 <em>.</em> 表示某一个位置的方格状态为空，<em>Q</em> 表示某一个位置的方格上摆着皇后。</p>
<p>每个方案输出完成后，输出一个空行。</p>
<p><strong>注意：行末不能有多余空格。</strong></p>
<p>输出方案的顺序任意，只要不重复且没有遗漏即可。</p>
<h5 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n≤9$</p>
<h5 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h5><pre><code>4
</code></pre><h5 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h5><pre><code>.Q..
...Q
Q...
..Q.

..Q.
Q...
...Q
.Q..
</code></pre><p><strong>解题思路</strong></p>
<p>我们每次只考虑一行所以不会出现一行中同时有两个皇后的情况，即我们每次只考虑该行的皇后应放在哪里才能保证符合条件，我们应判断<strong>3个方向</strong><em>竖 对角线 反对角线</em>分别用col dg udg的数组来表示</p>
<p>其中数组的大小 <img src="3.1.2d.png" alt=""></p>
<p>为了方便我们都开20大小的数组；</p>
<p>下面在讲一下如何判断皇后放在该行的此处 是否符合规定 </p>
<p><em>col[i]</em>必须为0即该列上没有皇后</p>
<p>同时<em>dg[u + i] udg[n - u + i]</em>必须也为0，这表示对角线和反对角线均没有皇后</p>
<p>下面是解释 <strong>*u是x即行      i是列即y*</strong></p>
<p><img src="3.1.2c.png" alt=""></p>
<p>满足上面的3个条件后就可以在该行的此处放置皇后了</p>
<p>这时要把<em>col[i]dg[u + i] udg[n - u + i</em>均赋值成<strong>true</strong></p>
<p>然后<strong>dfs</strong>下一行</p>
<p>千万别忘了<strong>恢复现场</strong>哦</p>
<h5 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="lang-c++">#include &lt;iostream&gt;
using namespace std;
const int N = 20; 

// bool数组用来判断搜索的下一个位置是否可行
// col列，dg对角线，udg反对角线
// g[N][N]用来存皇后的位置

int n;
char g[N][N];
bool col[N], dg[N], udg[N];

void dfs(int u) {
    // u == n 表示已经搜了n行，故输出这条路径
    if (u == n) {
        for (int i = 0; i &lt; n; i ++ ) puts(g[i]);// 等价于cout &lt;&lt; g[i] &lt;&lt; endl;
        puts(&quot;&quot;);  // 换行
        return;
    }

    //对n个位置按行搜索
    for (int i = 0; i &lt; n; i ++ )
        // 剪枝(对于不满足要求的点，不再继续往下搜索)  
        // udg[n - u + i]，+n是为了保证下标非负
        if (!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u + i]) {
            g[u][i] = &#39;Q&#39;;
            col[i] = dg[u + i] = udg[n - u + i] = true;
            dfs(u + 1);
            col[i] = dg[u + i] = udg[n - u + i] = false; // 恢复现场 这步很关键
            g[u][i] = &#39;.&#39;;

        }
}

int main() {
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i ++ )
        for (int j = 0; j &lt; n; j ++ )
            g[i][j] = &#39;.&#39;;
    dfs(0);
    return 0;
}
</code></pre>
<h3 id="3-1-2-BFS"><a href="#3-1-2-BFS" class="headerlink" title="3.1.2 BFS"></a>3.1.2 BFS</h3><h4 id="1-什么是BFS"><a href="#1-什么是BFS" class="headerlink" title="1.什么是BFS"></a>1.什么是BFS</h4><p>广度优先搜索算法（Breadth-First-Search），是一种图形搜索算法。简单的说，BFS是从根节点开始，沿着树(图)的宽度遍历树(图)的节点。如果所有节点均被访问，则算法中止。BFS同样属于盲目搜索。一般用队列数据结构来辅助实现BFS算法。</p>
<p>当题目要求 求解<strong>什么什么最小</strong>时，用<strong>BFS</strong>。（<strong>DFS会超时</strong>）</p>
<p>下面我给大家画图描述一下</p>
<p><img src="3.1.2e.png" alt=""></p>
<h4 id="2-模板讲解-1"><a href="#2-模板讲解-1" class="headerlink" title="2.模板讲解"></a>2.模板讲解</h4><pre><code class="lang-c++">int g[][];//记录迷宫
bool st[][];//标记数组防止重复判断
typedef struct node{//我们每一个状态用node表示
    其他的我们需要的元素
    bool useful;//该节点是否可用
}node;
node move_(node now,int i)
{
    /**********/
    扩展方法有很多
    int xx=now.x+dx[i];//扩展的x坐标
    int yy=now.y+dy[i];//扩展的y坐标
    /**********/
    node next={xx,yy,0, false};
    if(符合条件)
    {
        if(未被扩展过)
        {
            st[xx][yy]= true;//标记扩展过
            next.useful= true;
        }
    }
    return next;
}
void bfs(node start)
{
    queue&lt;node&gt;q;
    q.push(start);
    node now,next;
    while (!q.empty())
    {
        now=q.front();//取队首元素
        q.pop();//出队
        if()//到达目标节点
        {
            输出
        }
        for(多种扩展方法)
        {
            next=move_(now,i);//i 表示第几种扩展方式
            if(next.useful)//可用
            {
                相应处理
                q.push(next);//入队
            }
        }
    }
}
</code></pre>
<h4 id="3-例题和代码-1"><a href="#3-例题和代码-1" class="headerlink" title="3.例题和代码"></a>3.例题和代码</h4><h5 id="第一题-题目描述-1"><a href="#第一题-题目描述-1" class="headerlink" title="第一题 题目描述"></a>第一题 题目描述</h5><p><strong>走迷宫</strong></p>
<p>给定一个$n×m$ 的二维整数数组，用来表示一个迷宫，数组中只包含 $0$或 $1$，其中 $0$ 表示可以走的路，$1$表示不可通过的墙壁。</p>
<p>最初，有一个人位于左上角$(1,1)$ 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。</p>
<p>请问，该人从左上角移动至右下角$(n,m)$ 处，至少需要移动多少次。</p>
<p>数据保证 $(1,1)$处和 $(n,m)$ 处的数字为 $0$，且一定至少存在一条通路。</p>
<h5 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含两个整数 $n$ 和 $m$。</p>
<p>接下来 $n$ 行，每行包含 $m$个整数（$0$或 $1$），表示完整的二维数组迷宫。</p>
<h5 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出一个整数，表示从左上角移动至右下角的最少移动次数。</p>
<h5 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n,m≤100$</p>
<h5 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h5><pre><code>5 5
0 1 0 0 0
0 1 0 1 0
0 0 0 0 0
0 1 1 1 0
0 0 0 1 0
</code></pre><h5 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h5><pre><code>8
</code></pre><h5 id="解析和代码"><a href="#解析和代码" class="headerlink" title="解析和代码"></a>解析和代码</h5><p>从起点开始，每个点均有4个方向扩展 上下左右，在扩展时一是要<strong>*保证不越界*</strong>二是要<strong>*保证扩展过的节点不重复扩展*</strong></p>
<pre><code class="lang-c++">#include &lt;iostream&gt;
#include &lt;queue&gt;
using namespace std;
int n,m;
int g[110][110];//记录迷宫
bool st[110][110];//标记数组防止重复判断
int dx[4]={1,-1,0,0};//下上右左
int dy[4]={0,0,1,-1};
typedef struct node{//我们每一个状态用node表示
    int x;
    int y;
    int cnt;//记录步数
    bool useful;//该节点是否可用
}node;
node move_(node now,int i)
{
    int xx=now.x+dx[i];//扩展的x坐标
    int yy=now.y+dy[i];//扩展的y坐标
    node next={xx,yy,0, false};
    if(xx&gt;=1&amp;&amp;xx&lt;=n&amp;&amp;yy&gt;=1&amp;&amp;yy&lt;=m&amp;&amp;!g[xx][yy])
    {
        if(!st[xx][yy])
        {
            st[xx][yy]= true;
            next.useful= true;
        }
    }
    return next;
}
void bfs(node start)
{
    queue&lt;node&gt;q;
    q.push(start);
    node now,next;
    while (!q.empty())
    {
        now=q.front();//取队首元素
        q.pop();//出队
        if(now.x==n&amp;&amp;now.y==m)//到达目标节点
        {
            cout&lt;&lt;now.cnt&lt;&lt;endl;
        }
        for(int i=0;i&lt;4;i++)//共四种扩展方向
        {
            next=move_(now,i);
            if(next.useful)
            {
                next.cnt=now.cnt+1;//步数加一
                q.push(next);
            }
        }
    }
}
int main() {
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=m;j++)
        {
            cin&gt;&gt;g[i][j];
        }
    }
    node start={1,1,0,true};
    st[1][1]= true;
    bfs(start);
    return 0;
}
</code></pre>
<h5 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h5><h5 id="题目描述-8数码"><a href="#题目描述-8数码" class="headerlink" title="题目描述   8数码"></a>题目描述   <strong>8数码</strong></h5><p>在一个 $3×3$ 的网格中，$1∼8$ 这$8$ 个数字和一个 <em>x</em> 恰好不重不漏地分布在这 $3×3$ 的网格中。</p>
<p>例如：</p>
<pre><code>1 2 3
x 4 6
7 5 8
</code></pre><p>在游戏过程中，可以把 <em>x</em> 与其上、下、左、右四个方向之一的数字交换（如果存在）。</p>
<p>我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：</p>
<pre><code>1 2 3
4 5 6
7 8 x
</code></pre><p>例如，示例中图形就可以通过让 <em>x</em> 先后与右、下、右三个方向的数字交换成功得到正确排列。</p>
<p>交换过程如下：</p>
<pre><code>1 2 3   1 2 3   1 2 3   1 2 3
x 4 6   4 x 6   4 5 6   4 5 6
7 5 8   7 5 8   7 x 8   7 8 x
</code></pre><p>现在，给你一个初始网格，请你求出得到正确排列至少需要进行多少次交换。</p>
<h5 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h5><p>输入占一行，将 3×33×3 的初始网格描绘出来。</p>
<p>例如，如果初始网格如下所示：</p>
<pre><code>1 2 3 
x 4 6 
7 5 8
</code></pre><p>则输入为：<em>1 2 3 x 4 6 7 5 8</em></p>
<h5 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出占一行，包含一个整数，表示最少交换次数。</p>
<p>如果不存在解决方案，则输出 −1−1。</p>
<h5 id="输入样例：-2"><a href="#输入样例：-2" class="headerlink" title="输入样例："></a>输入样例：</h5><pre><code>2  3  4  1  5  x  7  6  8
</code></pre><h5 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例"></a>输出样例</h5><pre><code>19
</code></pre><h5 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h5><p>本题 每种node即状态 需要6种元素来描述</p>
<ol>
<li><p>x0  记录x的横坐标</p>
</li>
<li><p>y0 记录x的纵坐标</p>
</li>
<li><p><em>a[3][3]</em>  记录8数码中数的位置（x当成0）</p>
</li>
<li><p>num  <em>a[3][3]</em> 因为8数码中数的位置不能重复，所以他们表示的9位十进制数都是独一无二的</p>
<p>eg   123</p>
<p>​       456   <em>-&gt;</em>    123456780</p>
<p>​       780</p>
</li>
<li><p>cnt 记录步数</p>
</li>
<li><p>useful 判断是否可用</p>
</li>
</ol>
<p>因为本题状态比较多，所以用st数组会爆掉 故要用 set来存储每种状态的num值如果 该num已经出现在set 中说明该状态重复 不扩展该状态</p>
<h5 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="lang-c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
using namespace std;
int work[4][2]={{1,0},{-1,0},{0,1},{0,-1}};//4种移动方向
set&lt;int&gt;m;//判断是否重复扩展
typedef struct node{
    int x0;
    int y0;
    int a[3][3];
    int num;
    int cnt;
    bool useful;
}node;
int get_num(node now)//根据a[3][3]计算num
{
    int sum=0;
    for (int i = 0; i &lt; 3; ++i) {
        for (int j = 0; j &lt; 3; ++j) {
            sum=sum*10+now.a[i][j];
        }
    }
    return sum;
}
node move_(int i,node now)//移动函数
{
    node next=now;
    next.useful= false;
    int xx=now.x0+work[i][0];
    int yy=now.y0+work[i][1];
    if(xx&gt;=0&amp;&amp;xx&lt;=2&amp;&amp;yy&gt;=0&amp;&amp;yy&lt;=2)//不能越界
    {
        swap(next.a[now.x0][now.y0],next.a[xx][yy]);//移动0的位置即x的位置
        next.num= get_num(next);//更新num值
        next.cnt=now.cnt+1;//步数加1
        next.x0=xx;//更新横坐标
        next.y0=yy;//更新纵坐标
        if(m.count(next.num)==0)//从未扩展过
        {
            m.insert(next.num);//进入set 以标记
            next.useful= true;
        }
    }
    return next;
}
int bfs(node start)
{
    queue&lt;node&gt;q;
    q.push(start);
    node now,next;
    while (!q.empty())
    {
        now=q.front();
        q.pop();
        if(now.num==123456780)//找到目标节点
        {
            return now.cnt;
        }
        for (int i = 0; i &lt; 4; ++i) {
            next=move_(i,now);
            if(next.useful)//如果可用
            {
                q.push(next);
            }
        }
    }
    return -1;//方法不可以
}
int main() {
    node start;
    for (int i = 0; i &lt; 3; ++i) {
        for(int j=0;j&lt;3;j++)
        {
            string s;//字符串处理没什么好说的
            cin&gt;&gt;s;
            if(s[0]!=&#39;x&#39;)
            {
            int t=s[0]-&#39;0&#39;;
            start.a[i][j]=t;
            }
            if(s[0]==&#39;x&#39;)//记录x的位置 把x当成0看待
            {
                start.x0=i;
                start.y0=j;
                start.a[i][j]=0;
            }
        }
    }
    start.cnt=0;
    start.useful= true;
    start.num=get_num(start);
    m.insert(start.num);
    //以上都是初始化start
    cout&lt;&lt;bfs(start)&lt;&lt;endl;
    return 0;
}
</code></pre>
<h2 id="3-2树与图的遍历：拓扑排序"><a href="#3-2树与图的遍历：拓扑排序" class="headerlink" title="3.2树与图的遍历：拓扑排序"></a>3.2树与图的遍历：拓扑排序</h2><h3 id="3-2-1树与图的储存"><a href="#3-2-1树与图的储存" class="headerlink" title="3.2.1树与图的储存"></a>3.2.1树与图的储存</h3><p>树是一种特殊的图，与图的存储方式相同。<br>对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。<br>因此我们可以只考虑有向图的存储。</p>
<p>(1) 邻接矩阵：<em>g[a][b]</em> 存储边a-&gt;b</p>
<p>(2) 邻接表：</p>
<pre><code class="lang-c++">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点
int h[N]N个点, e[N]N条边, ne[N]N条边, idx;

// 添加一条边a-&gt;b
//idx作为一个指针
void add(int a, int b)
{
    e[idx] = b;//存值 记录这个指针指向哪个点
    ne[idx] = h[a];//b的下一个点指向a的下一个点
    h[a] = idx ++ ;//a的下一个点修改成b         eg  1.a-&gt;c-&gt;d-&gt;e
}                                                 /*2.  a-&gt;c-&gt;d-&gt;e
                                                          ^
                                                          |
                                                          b    
                                                    3.a-&gt;b-&gt;c-&gt;d-&gt;e      


                                                          */
// 初始化
idx = 0;
memset(h, -1, sizeof h);
</code></pre>
<h3 id="3-2-2树与图的遍历"><a href="#3-2-2树与图的遍历" class="headerlink" title="3.2.2树与图的遍历"></a>3.2.2树与图的遍历</h3><p>时间复杂度 O(n+m)O(n+m), nn 表示点数，mm 表示边数</p>
<h4 id="1-深度优先遍历"><a href="#1-深度优先遍历" class="headerlink" title="(1) 深度优先遍历"></a>(1) 深度优先遍历</h4><pre><code class="lang-c++">int dfs(int u)
{
    st[u] = true; // st[u] 表示点u已经被遍历过

    for (int i = h[u]; i != -1 这就是初始化h全为-1的原因; i = ne[i] 指向下一个点)
        //把i看成一个指针
    {
        int j = e[i];//i是指针 j代表是那个点
        if (!st[j]) dfs(j);//如果这个点没有被搜过就 dfs这个点
    }
}
</code></pre>
<h4 id="例3-2-2-1：树的重心"><a href="#例3-2-2-1：树的重心" class="headerlink" title="例3.2.2.1：树的重心"></a>例3.2.2.1：树的重心</h4><p>给定一颗树，树中包含 $n$ 个结点（编号 $1∼n$）和 $n−1$ 条无向边。</p>
<p>请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。</p>
<p>重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。</p>
<h5 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $n$，表示树的结点数。</p>
<p>接下来 $n−1$ 行，每行包含两个整数 $a$ 和 $b$，表示点 $a$ 和点 $b$ 之间存在一条边。</p>
<h5 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出一个整数 $m$，表示将重心删除后，剩余各个连通块中点数的最大值。</p>
<h5 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n≤10^5$</p>
<h5 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h5><pre><code>9
1 2
1 7
1 4
2 8
2 5
4 3
3 9
4 6
</code></pre><h5 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h5><pre><code>4
</code></pre><h5 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h5><p><img src="3.2.2a.png" alt=""></p>
<p>因为是深搜，所以所有情况都会考虑到，所以我们只需要彻底弄懂一种操作原理即可</p>
<h5 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="lang-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;
const int N=1e5+10;
const int M=2*N;
int h[N],e[M],ne[M],idx,n,ans=N;
bool st[N];
void add(int a,int b)
{
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx++;
}
int dfs(int u)
{//返回以u为根的子树中结点的个数
    st[u]=true;
    int res=0;
    int sum=1;
    for(int i=h[u];i!=-1;i=ne[i])
    {
        int j=e[i];
        if(!st[j])
        {
            int s=dfs(j);//每个子树节点个数
            res=max(s,res);//子树中最大节点
            sum+=s;//以u为根的子树们的节点个数和
        }
    }
    res=max(res,n-sum);//以u为根的最大子树和剩余节点比较
    ans=min(ans,res);//找到最大们的最小
    return sum;
}
int main()
{
    memset(h,-1,sizeof h);
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++)
    {
        int a,b;
        cin&gt;&gt;a&gt;&gt;b;
        add(a,b);
        add(b,a);//无向图 所以要添加2次
    }
    dfs(1);
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
</code></pre>
<h4 id="2-宽度优先遍历"><a href="#2-宽度优先遍历" class="headerlink" title="(2) 宽度优先遍历"></a>(2) 宽度优先遍历</h4><pre><code class="lang-c++">queue&lt;int&gt; q;
st[1] = true; // 表示1号点已经被遍历过
q.push(1);

while (q.size())
{
    int t = q.front();
    q.pop();

    for (int i = h[t]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true; // 表示点j已经被遍历过
            q.push(j);
        }
    }
}
</code></pre>
<h4 id="例3-2-2-2：图中点的层次"><a href="#例3-2-2-2：图中点的层次" class="headerlink" title="例3.2.2.2：图中点的层次"></a>例3.2.2.2：图中点的层次</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个 $n$ 个点 $m$ 条边的有向图，图中可能存在重边和自环。</p>
<p>所有边的长度都是 $1$，点的编号为 $1∼n$。</p>
<p>请你求出 $1$ 号点到 $n$ 号点的最短距离，如果从 $1$ 号点无法走到 $n$ 号点，输出 $−1$。</p>
<h5 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含两个整数 $n$ 和 $m$。</p>
<p>接下来 $m$行，每行包含两个整数 $a$ 和 $b$，表示存在一条从 $a $走到 $b$ 的长度为 $1$ 的边。</p>
<h5 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出一个整数，表示 $1$ 号点到 $n$ 号点的最短距离。</p>
<h5 id="数据范围-4"><a href="#数据范围-4" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n,m≤10^5$</p>
<h5 id="输入样例：-3"><a href="#输入样例：-3" class="headerlink" title="输入样例："></a>输入样例：</h5><pre><code>4 5
1 2
2 3
3 4
1 3
1 4
</code></pre><h5 id="输出样例：-3"><a href="#输出样例：-3" class="headerlink" title="输出样例："></a>输出样例：</h5><pre><code>1
</code></pre><h5 id="本题思路"><a href="#本题思路" class="headerlink" title="本题思路"></a>本题思路</h5><p>参考广搜 就是一层一层的更新，直到搜到n，同时别忘了cnt加一。</p>
<h5 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="lang-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
using namespace std;
const int N=100010;
int h[N],ne[N],e[N],idx;
int n,m;
bool st[N];//标记数组
typedef struct node{
    int x;
    int cnt;
}node;
void add(int a,int b)
{
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx++;
}
int bfs(node start)
{
    //下面是经典操作
    node now,next;
    queue&lt;node&gt;q;
    q.push(start);
    st[start.x]= true;
    while (!q.empty())
    {
        now=q.front();
        q.pop();
        if(now.x==n)//到达n输出
        {
            return now.cnt;
        }
        for(int i=h[now.x];i!=-1;i=ne[i])//扩展所有与 now.x相连的并且从来未使用过的点
        {
            int j=e[i];//now.x与j相连
            if(!st[j])
            {
                st[j]= true;//标记用过
                next.x=j;//从j开始
                next.cnt=now.cnt+1;//前进一步
                q.push(next);//入队
            }
        }
    }
    return -1;
}
int main() {
    memset(h,-1,sizeof h);
    cin&gt;&gt;n&gt;&gt;m;
    for (int i = 0; i &lt; m; ++i) {
        int x,y;
        cin&gt;&gt;x&gt;&gt;y;
        add(x,y);//有向图
    }
    node start;
    start.cnt=0;
    start.x=1;
    cout&lt;&lt;bfs(start)&lt;&lt;endl;
    return 0;
}
</code></pre>
<h3 id="3-2-3拓扑排序"><a href="#3-2-3拓扑排序" class="headerlink" title="3.2.3拓扑排序"></a>3.2.3拓扑排序</h3><p>时间复杂度 $O(n+m)$, $n$ 表示点数，$m$ 表示边数</p>
<h5 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h5><pre><code class="lang-c++">bool topsort()
{
    int hh = 0, tt = -1;//这里用了一个q数组当成队列
    // d[i] 存储点i的入度
    for (int i = 1; i &lt;= n; i ++ )
        if (!d[i])
            q[ ++ tt] = i;
    while (hh &lt;= tt)
    {
        int t = q[hh ++ ];//取队头元素

        for (int i = h[t]; i != -1; i = ne[i])//遍历所以的
        {
            int j = e[i];
            if (-- d[j] == 0)//更新入度
                q[ ++ tt] = j;
        }
    }
    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。
    return tt == n - 1;
}
</code></pre>
<h5 id="模板讲解"><a href="#模板讲解" class="headerlink" title="模板讲解"></a>模板讲解</h5><p>首先如何确定一个拓扑排序(注意同一个图可能有多个拓扑排序)</p>
<p><img src="3.2.2b.png" alt=""></p>
<h5 id="例题-有向图的拓扑排序"><a href="#例题-有向图的拓扑排序" class="headerlink" title="例题 有向图的拓扑排序"></a>例题 有向图的拓扑排序</h5><p>给定一个 $n $个点 $m$ 条边的有向图，点的编号是$1$ 到 $n$，图中可能存在重边和自环。</p>
<p>请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出 $−1$。</p>
<p>若一个由图中所有点构成的序列 $A$ 满足：对于图中的每条边 $(x,y)$，$x$ 在 $A $中都出现在 $y$ 之前，则称 $A$ 是该图的一个拓扑序列。</p>
<h5 id="输入格式-6"><a href="#输入格式-6" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含两个整数$n$ 和 $m$。</p>
<p>接下来 $m $行，每行包含两个整数 $x$ 和 $y$，表示存在一条从点 $x$ 到点 $y$ 的有向边 $(x,y)$。</p>
<h5 id="输出格式-6"><a href="#输出格式-6" class="headerlink" title="输出格式"></a>输出格式</h5><p>共一行，如果存在拓扑序列，则输出任意一个合法的拓扑序列即可。</p>
<p>否则输出$−1$。</p>
<h5 id="数据范围-5"><a href="#数据范围-5" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n,m≤10^5$</p>
<h5 id="输入样例：-4"><a href="#输入样例：-4" class="headerlink" title="输入样例："></a>输入样例：</h5><pre><code>3 3
1 2
2 3
1 3
</code></pre><h5 id="输出样例：-4"><a href="#输出样例：-4" class="headerlink" title="输出样例："></a>输出样例：</h5><pre><code>1 2 3
</code></pre><h5 id="本题解析和代码与模板类似就不过多赘述了-别忘了建立有向图时顺带着建立入度数组"><a href="#本题解析和代码与模板类似就不过多赘述了-别忘了建立有向图时顺带着建立入度数组" class="headerlink" title="本题解析和代码与模板类似就不过多赘述了(别忘了建立有向图时顺带着建立入度数组)"></a>本题解析和代码与模板类似就不过多赘述了(别忘了建立有向图时顺带着建立入度数组)</h5><h2 id="3-3最短路"><a href="#3-3最短路" class="headerlink" title="3.3最短路"></a>3.3最短路</h2><h3 id="前言-以下算法用法简述"><a href="#前言-以下算法用法简述" class="headerlink" title="前言 以下算法用法简述"></a>前言 以下算法用法简述</h3><p><img src="3.2.2c.png" alt=""></p>
<h3 id="3-3-1朴素dijkstra算法"><a href="#3-3-1朴素dijkstra算法" class="headerlink" title="3.3.1朴素dijkstra算法"></a>3.3.1朴素dijkstra算法</h3><p>时间复杂是 $O(n^2+m)$, $n$ 表示点数，$m$表示边数</p>
<h5 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h5><pre><code class="lang-c++">int g[N][N];  // 存储每条边
int dist[N];  // 存储1号点到每个点的最短距离
bool st[N];   // 存储每个点的最短路是否已经确定
// 求1号点到n号点的最短路，如果不存在则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    for (int i = 0; i &lt; n - 1; i ++ )//你就记住 n个点除去起点 总共要处理n-1次
    {
        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点
        for (int j = 1; j &lt;= n; j ++ )
            if (!st[j] （表示没被考虑过）&amp;&amp; (t == -1（表示是第一次比较，故直接赋值） || dist[t] &gt; dist[j]（找到一个更小的所以要更新）))
                t = j;//找到最小的距离

        // 用t更新其他点的距离
        for (int j = 1; j &lt;= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);//用找到最小的那个，去更新所有距离

        st[t] = true;//别忘了标记
    }

    if (dist[n] == 0x3f3f3f3f) return -1;//到达不了n点
    return dist[n];
}
</code></pre>
<h5 id="模板解析"><a href="#模板解析" class="headerlink" title="模板解析"></a>模板解析</h5><p><img src="3.2.2d.png" alt=""></p>
<p>以上面的3号点为例  一开始只考虑点1  dist[3]=12，当将点2考虑进来后  因为 <em>dist[3]=12&gt;dist[2]+g[2][3]=10</em> ,所以要去更新dist数组 使dist[3]=10</p>
<h5 id="例题-Dijkstra求最短路-I"><a href="#例题-Dijkstra求最短路-I" class="headerlink" title="例题 Dijkstra求最短路 I"></a>例题 Dijkstra求最短路 I</h5><p>给定一个 $n$ 个点 $m$ 条边的有向图，图中可能存在重边和自环，所有边权均为正值。</p>
<p>请你求出 $1$号点到 $n$ 号点的最短距离，如果无法从 $1$ 号点走到 $n$ 号点，则输出 $−1$。</p>
<h5 id="输入格式-7"><a href="#输入格式-7" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $n$ 和 $m$。</p>
<p>接下来 $m$ 行每行包含三个整数 $x$,$y$,$z$表示存在一条从点 $x$ 到点 $y$ 的有向边，边长为 $z$。</p>
<h5 id="输出格式-7"><a href="#输出格式-7" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出一个整数，表示 $1$ 号点到 $n$ 号点的最短距离。</p>
<p>如果路径不存在，则输出 $−1$。</p>
<h5 id="数据范围-6"><a href="#数据范围-6" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n≤500$,<br>$1≤m≤10^5$,<br>图中涉及边长均不超过10000。</p>
<h5 id="输入样例：-5"><a href="#输入样例：-5" class="headerlink" title="输入样例："></a>输入样例：</h5><pre><code>3 3
1 2 2
2 3 1
1 3 4
</code></pre><h5 id="输出样例：-5"><a href="#输出样例：-5" class="headerlink" title="输出样例："></a>输出样例：</h5><pre><code>3
</code></pre><h5 id="本题解析和代码与模板类似就不过多赘述了"><a href="#本题解析和代码与模板类似就不过多赘述了" class="headerlink" title="本题解析和代码与模板类似就不过多赘述了"></a>本题解析和代码与模板类似就不过多赘述了</h5><h3 id="3-3-2堆优化的dijkstra"><a href="#3-3-2堆优化的dijkstra" class="headerlink" title="3.3.2堆优化的dijkstra"></a>3.3.2堆优化的dijkstra</h3><h5 id="为什么要用堆优化"><a href="#为什么要用堆优化" class="headerlink" title="为什么要用堆优化"></a>为什么要用堆优化</h5><p>在普通版中每次我们在寻找最小的未被使用过的<em>dist[i]</em>都是从头到尾遍历一边效率低下，本算法采用堆，来简化排序的过程，从而降低时间。</p>
<p>时间复杂度 $O(mlogn)$, $n$ 表示点数，$m$ 表示边数</p>
<h4 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h4><pre><code class="lang-c++">typedef pair&lt;int, int&gt; PII;
int n;      // 点的数量
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储所有点到1号点的距离
bool st[N];     // 存储每个点的最短距离是否已确定

// 求1号点到n号点的最短距离，如果不存在，则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;//小根堆
    heap.push({0, 1});      // first存储距离，second存储节点编号

    while (heap.size())//若堆不为空 即还有点没有考虑过
    {
        auto t = heap.top();//当前最小的 就是堆顶元素
        heap.pop();

        int ver = t.second;//编号
        int distance = t.first;//距离
        if (st[ver]) continue;//如果这个编号用过
        st[ver] = true;//标记这个编号

        for (int i = h[ver]; i != -1; i = ne[i])//遍历这个编号所连接的全部的点，来更新dist数组
        {
            int j = e[i];//点j是ver所连接的点
            if (dist[j] &gt; distance + w[i])//满足更新条件
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});//新的距离要放入堆中
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
</code></pre>
<h4 id="例3-3-2-Dijkstra求最短路-II"><a href="#例3-3-2-Dijkstra求最短路-II" class="headerlink" title="例3.3.2 Dijkstra求最短路 II"></a>例3.3.2 Dijkstra求最短路 II</h4><p>给定一个 $n$个点 $m $条边的有向图，图中可能存在重边和自环，所有边权均为非负值。</p>
<p>请你求出 $1$ 号点到 $n$ 号点的最短距离，如果无法从 $1$ 号点走到 $n$ 号点，则输出 $−1$。</p>
<h5 id="输入格式-8"><a href="#输入格式-8" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $n$和 $m$。</p>
<p>接下来 $m$ 行每行包含三个整数$ x,y,z$，表示存在一条从点 $x$ 到点 $y$ 的有向边，边长为 $z$。</p>
<h5 id="输出格式-8"><a href="#输出格式-8" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出一个整数，表示 $1$号点到 $n$ 号点的最短距离。</p>
<p>如果路径不存在，则输出 $−1$。</p>
<h5 id="数据范围-7"><a href="#数据范围-7" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n,m≤1.5×10^5$,<br>图中涉及边长均不小于 $0$，且不超过 $10000$。</p>
<h5 id="输入样例：-6"><a href="#输入样例：-6" class="headerlink" title="输入样例："></a>输入样例：</h5><pre><code>3 3
1 2 2
2 3 1
1 3 4
</code></pre><h5 id="输出样例：-6"><a href="#输出样例：-6" class="headerlink" title="输出样例："></a>输出样例：</h5><pre><code>3
</code></pre><h5 id="本题代码"><a href="#本题代码" class="headerlink" title="本题代码"></a>本题代码</h5><pre><code class="lang-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
using namespace std;
const int N=150010;
int h[N],w[N],e[N],ne[N],idx;
int dist[N];
bool st[N];
int n,m;
typedef pair&lt;int,int &gt;pii;
void add(int x,int y,int c)
{
    e[idx]=y;
    ne[idx]=h[x];
    w[idx]=c;//多维护一个权值数组
    h[x]=idx++;
}
int d()
{
    memset(dist,0x3f,sizeof dist);
    dist[1]=0;
    priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt;heap;
    heap.push({0,1});
    while (!heap.empty())
    {
        auto t=heap.top();
        heap.pop();
        int d=t.first;
        int num=t.second;
        if(st[num])continue;
        st[num]= true;
        for(int i=h[num];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dist[j]&gt;d+w[i])
            {
                dist[j]=w[i]+d;
                heap.push({dist[j],j});
            }
        }
    }
    if(dist[n]==0x3f3f3f3f)return -1;
    return dist[n];
}
int main() {
    cin&gt;&gt;n&gt;&gt;m;
    memset(h,-1,sizeof h);
    for (int i = 0; i &lt; m; ++i) {
        int x,y,t;
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;t;
        add(x,y,t);
    }
    cout&lt;&lt;d()&lt;&lt;endl;
    return 0;
}
</code></pre>
<h3 id="3-3-3-Bellman-Ford算法"><a href="#3-3-3-Bellman-Ford算法" class="headerlink" title="3.3.3 Bellman-Ford算法"></a>3.3.3 Bellman-Ford算法</h3><h4 id="什么是bellman-ford算法？"><a href="#什么是bellman-ford算法？" class="headerlink" title="什么是bellman - ford算法？"></a>什么是bellman - ford算法？</h4><p>Bellman - ford 算法是求含负权图的单源最短路径的一种算法，效率较低，代码难度较小。其原理为连续进行松弛，在每次松弛时把每条边都更新一下，若在 n-1 次松弛后还能更新，则说明图中有负环，因此无法得出结果，否则就完成。<br>(通俗的来讲就是：假设 1 号点到 n 号点是可达的，每一个点同时向指向的方向出发，更新相邻的点的最短距离，通过循环 n-1 次操作，若图中不存在负环，则 1 号点一定会到达 n 号点，若图中存在负环，则在 n-1 次松弛后一定还会更新)</p>
<p><strong>时间复杂度 $O(nm)$, $n$ 表示点数，$m $表示边数</strong></p>
<p>注意在例题中需要对下面的模板稍作修改，加上备份数组。</p>
<h4 id="关于dijkstra为什么不能用在有负权的图"><a href="#关于dijkstra为什么不能用在有负权的图" class="headerlink" title="关于dijkstra为什么不能用在有负权的图"></a>关于dijkstra为什么不能用在有负权的图</h4><p><img src="3.2.2e.png" alt=""></p>
<h4 id="模板-3"><a href="#模板-3" class="headerlink" title="模板"></a>模板</h4><pre><code class="lang-c++">int n, m;       // n表示点数，m表示边数
int dist[N];        // dist[x]存储1到x的最短路距离

struct Edge     // 边，a表示出点，b表示入点，w表示边的权重
{
    int a, b, w;
}edges[M];

// 求1到n的最短路距离，如果无法从1走到n，则返回-1。
int bellman_ford()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。（负权回路通俗点讲就是，你一直在这个回路里走并且总权重还会减小，理论上如果不限制步数，就会一直在里面一直走）
    for (int i = 0; i &lt; n; i ++ )
    {
        for (int j = 0; j &lt; m; j ++ )//遍历所有边
        {
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;
            if (dist[b] &gt; dist[a] + w)//类比  迪杰特斯拉 
                dist[b] = dist[a] + w;
        }
    }

    if (dist[n] &gt; 0x3f3f3f3f / 2) return -1;
    return dist[n];
}
</code></pre>
<h5 id="例题-有边数限制的最短路"><a href="#例题-有边数限制的最短路" class="headerlink" title="例题 有边数限制的最短路"></a>例题 有边数限制的最短路</h5><p>给定一个 $n$ 个点 $m$ 条边的有向图，图中可能存在重边和自环， <strong>边权可能为负数</strong>。</p>
<p>请你求出从 $1$ 号点到 $n$ 号点的最多经过 $k$ 条边的最短距离，如果无法从 $1$ 号点走到 $n$ 号点，输出 <em>impossible</em>。</p>
<p>注意：图中可能 <strong>存在负权回路</strong> 。</p>
<h5 id="输入格式-9"><a href="#输入格式-9" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含三个整数 $n,m,k$。</p>
<p>接下来 $m$ 行，每行包含三个整数 $x,y,z$，表示存在一条从点 $x$ 到点 $y$ 的有向边，边长为 $z$。</p>
<h5 id="输出格式-9"><a href="#输出格式-9" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出一个整数，表示从 $1$ 号点到 $n$ 号点的最多经过 $k$ 条边的最短距离。</p>
<p>如果不存在满足条件的路径，则输出 <em>impossible</em>。</p>
<h5 id="数据范围-8"><a href="#数据范围-8" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n,k≤500$<br>$1≤m≤10000$,<br>任意边长的绝对值不超过 $10000$。</p>
<h5 id="输入样例：-7"><a href="#输入样例：-7" class="headerlink" title="输入样例："></a>输入样例：</h5><pre><code>3 3 1
1 2 1
2 3 1
1 3 3
</code></pre><h5 id="输出样例：-7"><a href="#输出样例：-7" class="headerlink" title="输出样例："></a>输出样例：</h5><pre><code>3
</code></pre><h5 id="参考代码-5"><a href="#参考代码-5" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="lang-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
using namespace std;
const int N=510;
int n,m,k;
int dist[N],backup[N];//备份数组
struct edge{
    int a,b,w;
}edge[10010];
int bell()
{
    memset(dist,0x3f,sizeof dist);
    dist[1]=0;
    for (int i = 0; i &lt; k; ++i) {//k次松弛
        memcpy(backup,dist,sizeof dist);//开始备份
        for (int j = 0; j &lt; m; ++j) {
            int a=edge[j].a,b=edge[j].b,w=edge[j].w;
            dist[b]= min(dist[b],backup[a]+w);
        }
    }
    return dist[n];
}
int main() {
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;
    for (int i = 0; i &lt; m; ++i) {
        int x,y,t;
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;t;
        edge[i].a=x;
        edge[i].b=y;
        edge[i].w=t;
    }
    int t= bell();
    if(t&gt;=0x3f3f3f3f/2)puts(&quot;impossible&quot;);//是否能到达n号点的判断中需要进行if(dist[n] &gt; INF/2)判断，而并非是if(dist[n] == INF)判断，原因是INF是一个确定的值，并非真正的无穷大，会随着其他数值而受到影响，dist[n]大于某个与INF相同数量级的数即可
    else cout&lt;&lt;t&lt;&lt;endl;
    return 0;
}
</code></pre>
<h5 id="关于备份数组"><a href="#关于备份数组" class="headerlink" title="关于备份数组"></a>关于备份数组</h5><p>我们为什么要设计这样一个数组呢？答案就是防止串联，不能立刻用上更新的值因为有可能会不满足k条边的条件。</p>
<p><img src="3.2.2f.png" alt=""></p>
<h3 id="3-3-4-spfa-算法（队列优化的Bellman-Ford算法）"><a href="#3-3-4-spfa-算法（队列优化的Bellman-Ford算法）" class="headerlink" title="3.3.4 spfa 算法（队列优化的Bellman-Ford算法）"></a>3.3.4 spfa 算法（队列优化的Bellman-Ford算法）</h3><h5 id="为什么要用spfa算法"><a href="#为什么要用spfa算法" class="headerlink" title="为什么要用spfa算法"></a>为什么要用spfa算法</h5><p>Bellman_ford算法会遍历所有的边，但是有很多的边遍历了其实没有什么意义，我们只用遍历那些到源点距离变小的点所连接的边即可，只有当一个点的前驱结点更新了，该节点才会得到更新；因此考虑到这一点，我们将创建一个队列每一次加入距离被更新的结点。</p>
<h5 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h5><p> Bellman_ford算法可以存在负权回路，是因为其循环的次数是有限制的因此最终不会发生死循环；但是SPFA算法不可以，由于用了队列来存储，只要发生了更新就会不断的入队，因此假如<strong>有负权回路请你不要用SPFA否则会死循环</strong>。</p>
<p><strong>时间复杂度 平均情况下 $O(m)$，最坏情况下 $O(nm)$, $n$ 表示点数，$m$ 表示边数假如题目时间允许可以直接用SPFA算法去解Dijkstra算法的题目。</strong></p>
<h4 id="模板-4"><a href="#模板-4" class="headerlink" title="模板"></a>模板</h4><pre><code class="lang-c++">int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储每个点到1号点的最短距离
bool st[N];     // 存储每个点是否在队列中

// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1
int spfa()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    queue&lt;int&gt; q;
    q.push(1);//1号点是起点
    st[1] = true;

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;//代表之后该节点如果发生更新可再次入队

        for (int i = h[t]; i != -1; i = ne[i])//遍历跟t相连的所有点
        {
            int j = e[i];
            if (dist[j] &gt; dist[t] + w[i])//w[i]是t到j的距离 当不再更新时代表已完成要把队列清空跳出循环（若有负回路则无限循环）
            {//只用入队那些既没有访问过还使距离变小的点
                dist[j] = dist[t] + w[i];
                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入即便发生了更新也只用更新数值即可，重复添加降低效率
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
</code></pre>
<h5 id="模板解析-1"><a href="#模板解析-1" class="headerlink" title="模板解析"></a>模板解析</h5><ol>
<li><p>Bellman_ford算法里最后return-1的判断条件写的是dist[n]&gt;0x3f3f3f3f/2;而spfa算法写的是dist[n]==0x3f3f3f3f;其原因在于Bellman_ford算法会遍历所有的边，因此不管是不是和源点连通的边它都会得到更新；但是SPFA算法不一样，它相当于采用了BFS，因此<strong>遍历到的结点都是与源点连通的</strong>，因此如果你要求的n和源点不连通，它不会得到更新，还是保持的0x3f3f3f3f。</p>
</li>
<li><p>SPFA算法看上去和Dijstra算法长得有一些像但是其中的意义还是相差甚远的:</p>
<ol>
<li>Dijkstra算法中的st数组保存的是当前确定了到源点距离最小的点，且一旦确定了最小那么就<strong>不可逆</strong>了(不可标记为true后改变为false)；SPFA算法中的st数组<strong>仅仅只是表示的当前发生过更新的点，且spfa中的st数组可逆</strong>(可以在标记为true之后又标记为false)。顺带一提的是BFS中的st数组记录的是当前已经被遍历过的点。</li>
<li>Dijkstra算法里使用的是<strong>优先队列保存的是当前未确定最小距离的点</strong>，目的是快速的取出当前到源点距离最小的点；SPFA算法中使用的是队列(你也可以使用别的数据结构),目的只是<strong>记录一下当前发生过更新的点</strong>。</li>
</ol>
</li>
</ol>
<h5 id="例题-spfa求最短路"><a href="#例题-spfa求最短路" class="headerlink" title="例题   spfa求最短路"></a>例题   spfa求最短路</h5><p>给定一个 $n$ 个点 $m$ 条边的有向图，图中可能存在重边和自环， <strong>边权可能为负数</strong>。</p>
<p>请你求出 $1$ 号点到 $n$ 号点的最短距离，如果无法从 $1$ 号点走到 $n$ 号点，则输出 <em>impossible</em>。</p>
<p>数据保证不存在负权回路。</p>
<h5 id="输入格式-10"><a href="#输入格式-10" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 $n$ 和 $m$。</p>
<p>接下来 $m$ 行每行包含三个整数 $x,y,z$，表示存在一条从点 $x$ 到点 $y$ 的有向边，边长为 $z$。</p>
<h5 id="输出格式-10"><a href="#输出格式-10" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出一个整数，表示 $1$ 号点到 $n$ 号点的最短距离。</p>
<p>如果路径不存在，则输出 <em>impossible</em>。</p>
<h5 id="数据范围-9"><a href="#数据范围-9" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n,m≤10^5$,<br>图中涉及边长绝对值均不超过 $10000$。</p>
<h5 id="输入样例：-8"><a href="#输入样例：-8" class="headerlink" title="输入样例："></a>输入样例：</h5><pre><code>3 3
1 2 5
2 3 -3
1 3 4
</code></pre><h5 id="输出样例：-8"><a href="#输出样例：-8" class="headerlink" title="输出样例："></a>输出样例：</h5><pre><code>2
</code></pre><h5 id="参考代码-6"><a href="#参考代码-6" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="lang-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
using namespace std;
const int N=100010;
int n,m;
int h[N],ne[N],e[N],w[N],idx;
int dist[N];
bool st[N];
void add(int a,int b,int t)
{
    e[idx]=b;
    w[idx]=t;
    ne[idx]=h[a];
    h[a]=idx++;
}
int spfa()
{
    memset(dist,0x3f,sizeof dist);
    dist[1]=0;
    queue&lt;int&gt; q;
    q.push(1);
    st[1]= true;
    while (!q.empty())
    {
        int t=q.front();
        q.pop();
        st[t]= false;
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dist[j]&gt;dist[t]+w[i])
            {
                dist[j]=dist[t]+w[i];
                if(!st[j])
                {
                    q.push(j);
                    st[j]= true;
                }
            }
        }
    }
    return dist[n];
}
int main() {
    cin&gt;&gt;n&gt;&gt;m;
    memset(h,-1,sizeof h);
    for (int i = 0; i &lt; m; ++i) {
        int x,y,t;
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;t;
        add(x,y,t);
    }
    int t=spfa();
    if(t==0x3f3f3f3f)
    {
        cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;
    } else
    {
        cout&lt;&lt;t&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<h5 id="跟模板类似没什么好说的"><a href="#跟模板类似没什么好说的" class="headerlink" title="跟模板类似没什么好说的"></a>跟模板类似没什么好说的</h5><h3 id="3-3-5-spfa判断图中是否存在负环"><a href="#3-3-5-spfa判断图中是否存在负环" class="headerlink" title="3.3.5  spfa判断图中是否存在负环"></a>3.3.5  spfa判断图中是否存在负环</h3><p>时间复杂度是 $O(nm)$, $n$ 表示点数，$m$ 表示边数</p>
<h4 id="模板-5"><a href="#模板-5" class="headerlink" title="模板"></a>模板</h4><pre><code class="lang-c++">int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N], cnt[N];        // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数
bool st[N];     // 存储每个点是否在队列中

// 如果存在负环，则返回true，否则返回false。
bool spfa()
{
    //  这里不需要初始化dist数组为 正无穷/初始化的原因是， 如果存在负环， 那么dist不管初始化为多少， 都会被更新
    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。

    queue&lt;int&gt; q;
    for (int i = 1; i &lt;= n; i ++ )
    {
        q.push(i);
        st[i] = true;
    }

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] &gt; dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;//因为是从t到j 所以j的步数是c的步数加1.
                if (cnt[j] &gt;= n) return true;       // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    return false;
}
</code></pre>
<h5 id="模板解析-2"><a href="#模板解析-2" class="headerlink" title="模板解析"></a>模板解析</h5><p>就是多维护一个cnt数组，当你执行n次后发现最短距离还能减小，就说明一定存在负环，因为你可以一直走负环来让你的最短距离十分小（卡bug）</p>
<p>同时还有一点 为什么要在一开始的时候把所有点都放在队列中呢？</p>
<p>如下图所示</p>
<p><img src="3.2.2g.png" alt=""></p>
<h4 id="例题-spfa判断负环"><a href="#例题-spfa判断负环" class="headerlink" title="例题  spfa判断负环"></a>例题  spfa判断负环</h4><p>给定一个 $n$个点 $m$ 条边的有向图，图中可能存在重边和自环， <strong>边权可能为负数</strong>。</p>
<p>请你判断图中是否存在负权回路。</p>
<h5 id="输入格式-11"><a href="#输入格式-11" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数$n$和  $m$ 。</p>
<p>接下来  $m$ 行每行包含三个整数$x,y,z$，表示存在一条从点 $x$到点$ y$的有向边，边长为 $z$.</p>
<h5 id="输出格式-11"><a href="#输出格式-11" class="headerlink" title="输出格式"></a>输出格式</h5><p>如果图中<strong>存在</strong>负权回路，则输出 <em>Yes</em>，否则输出 <em>No</em>。</p>
<h5 id="数据范围-10"><a href="#数据范围-10" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n≤2000$<br>$1≤m≤10000$,<br>图中涉及边长绝对值均不超过 $10000$。</p>
<h5 id="输入样例：-9"><a href="#输入样例：-9" class="headerlink" title="输入样例："></a>输入样例：</h5><pre><code>3 3
1 2 -1
2 3 4
3 1 -4
</code></pre><h5 id="输出样例：-9"><a href="#输出样例：-9" class="headerlink" title="输出样例："></a>输出样例：</h5><pre><code>Yes
</code></pre><h5 id="参考代码-7"><a href="#参考代码-7" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="lang-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
using namespace std;
const int N=100010;
int n,m;
int h[N],ne[N],e[N],w[N],idx;
int dist[N];
int cnt[N];
bool st[N];
void add(int a,int b,int t)
{
    e[idx]=b;
    w[idx]=t;
    ne[idx]=h[a];
    h[a]=idx++;
}
bool spfa()
{
    queue&lt;int&gt; q;
    for(int i=1;i&lt;=n;i++)
    {
        q.push(i);
        st[i]=true;
    }
    while (!q.empty())
    {
        int t=q.front();
        q.pop();
        st[t]= false;
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dist[j]&gt;dist[t]+w[i])
            {
                dist[j]=dist[t]+w[i];
                cnt[j]=cnt[t]+1;
                if(cnt[j]&gt;n)
                {
                    return true;
                }
                if(!st[j])
                {
                    q.push(j);
                    st[j]= true;
                }
            }
        }
    }
    return false;
}
int main() {
    cin&gt;&gt;n&gt;&gt;m;
    memset(h,-1,sizeof h);
    for (int i = 0; i &lt; m; ++i) {
        int x,y,t;
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;t;
        add(x,y,t);
    }
    bool t=spfa();
    if(t)
    {
        cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;
    } else
    {
        cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<h5 id="跟模板差不多"><a href="#跟模板差不多" class="headerlink" title="跟模板差不多"></a>跟模板差不多</h5><h3 id="3-3-6-floyd算法"><a href="#3-3-6-floyd算法" class="headerlink" title="3.3.6 floyd算法"></a>3.3.6 floyd算法</h3><p>时间复杂度是 $O(n^3)$, $n$ 表示点数</p>
<h4 id="模板-6"><a href="#模板-6" class="headerlink" title="模板"></a>模板</h4><pre><code class="lang-c++">初始化：
    for (int i = 1; i &lt;= n; i ++ )
        for (int j = 1; j &lt;= n; j ++ )
            if (i == j) d[i][j] = 0;
            else d[i][j] = INF;

// 算法结束后，d[a][b]表示a到b的最短距离
void floyd()
{
    for (int k = 1; k &lt;= n; k ++ )
        for (int i = 1; i &lt;= n; i ++ )
            for (int j = 1; j &lt;= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}
</code></pre>
<h4 id="模板解析-3"><a href="#模板解析-3" class="headerlink" title="模板解析"></a>模板解析</h4><p><em>f[i, j, k]</em>表示从i走到j的路径上除<em>i</em>和<em>j</em>点外只经过<em>1</em>到<em>k</em>的点的所有路径的最短距离。</p>
<p>根据动态规划思想</p>
<p>若不经过第k个点则 <em>f[i, j, k] = f[i, j, k - 1]</em></p>
<p>若经过第k个点则 <em>f[i, j, k] = f[i, k, k - 1] + f[k, j, k - 1]</em> </p>
<p>所以<em>f[i, j, k] = min(f[i, j, k - 1], f[i, k, k - 1] + f[k, j, k - 1])</em> </p>
<p>因此在计算第<em>k</em>层的<em>f[i, j]</em>的时候必须先将第<em>k - 1</em>层的所有状态计算出来，所以需要把<em>k</em>放在最外层。</p>
<p>故3维数组变2维    <em>f[i][j] = min(f[i][j],f[i][k] + f[k][j]);</em></p>
<h4 id="例题-Floyd求最短路"><a href="#例题-Floyd求最短路" class="headerlink" title="例题   Floyd求最短路"></a>例题   Floyd求最短路</h4><p>给定一个 $n$个点 $m$ 条边的有向图，图中可能存在重边和自环，边权可能为负数。</p>
<p>再给定 $k$ 个询问，每个询问包含两个整数 $x$ 和$y$，表示查询从点 $x$ 到点 $y$的最短距离，如果路径不存在，则输出 <em>impossible</em>。</p>
<p>数据保证图中不存在负权回路。</p>
<h5 id="输入格式-12"><a href="#输入格式-12" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含三个整数 $n,m,k$。</p>
<p>接下来$ m$ 行，每行包含三个整数 $x,y,z$，表示存在一条从点 $x$ 到点 $y$ 的有向边，边长为 $z$。</p>
<p>接下来 kk 行，每行包含两个整数 $x,y$，表示询问点 $x$ 到点 $y $的最短距离。</p>
<h5 id="输出格式-12"><a href="#输出格式-12" class="headerlink" title="输出格式"></a>输出格式</h5><p>共 kk 行，每行输出一个整数，表示询问的结果，若询问两点间不存在路径，则输出 <em>impossible</em>。</p>
<h5 id="数据范围-11"><a href="#数据范围-11" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n≤200$<br>$1≤k≤n^2$<br>$1≤m≤20000$,<br>图中涉及边长绝对值均不超过 $10000$。</p>
<h5 id="输入样例：-10"><a href="#输入样例：-10" class="headerlink" title="输入样例："></a>输入样例：</h5><pre><code>3 3 2
1 2 1
2 3 2
1 3 1
2 1
1 3
</code></pre><h5 id="输出样例：-10"><a href="#输出样例：-10" class="headerlink" title="输出样例："></a>输出样例：</h5><pre><code>impossible
1
</code></pre><h5 id="参考代码-8"><a href="#参考代码-8" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="lang-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
using namespace std;
const int N=210;
int g[N][N];
int n,m,z;

void floyd();

int main() {
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;z;
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=n;j++)
        {
            if(i==j)g[i][j]=0;
            else g[i][j]=0x3f3f3f3f;
        }
    }
    for (int i = 0; i &lt; m; ++i) {
        int x,y,t;
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;t;
        g[x][y]=min(t,g[x][y]);//可能存在重边 取最小值
    }
    floyd();
    for (int i = 0; i &lt; z; ++i) {
        int x,y;
        cin&gt;&gt;x&gt;&gt;y;
        if(g[x][y]&gt;0x3f3f3f3f/2)//断从a到b是否是无穷大距离时，需要进行if(t &gt; INF/2)判断，而并非是if(t == INF)判断，原因是INF是一个确定的值，并非真正的无穷大，会随着其他数值而受到影响，t大于某个与INF相同数量级的数即可
        {
            cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;
        }else 
        {
            cout&lt;&lt;g[x][y]&lt;&lt;endl;
        }
    }
    return 0;
}

void floyd() {
    for(int k=1;k&lt;=n;k++)
    {
        for(int i=1;i&lt;=n;i++)
        {
            for(int j=1;j&lt;=n;j++)
            {
                g[i][j]= min(g[i][j],g[i][k]+g[k][j]);
            }
        }
    }
}
</code></pre>
<h2 id="3-4最小生成树"><a href="#3-4最小生成树" class="headerlink" title="3.4最小生成树"></a>3.4最小生成树</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>最小生成树（minimum spanning tree）是由n个顶点，n-1条边，将一个连通图连接起来，且使权值最小的结构。</p>
<h3 id="3-4-1-朴素版prim算法"><a href="#3-4-1-朴素版prim算法" class="headerlink" title="3.4.1  朴素版prim算法"></a>3.4.1  朴素版prim算法</h3><p>这里就采用的是邻接矩阵存储的，<br>个人觉得Prim和最短路中的dijkstra很像，方法：<br>① 先建立一个只有一个结点的树，这个结点可以是原图中任 意的一个结点。</p>
<p>② 使用一条边扩展这个树，要求这条边一个顶点在树中另一 个顶点不在树中，并且这条边的权值要求最小。</p>
<p>③ 重复步骤②直到所有顶点都在树中。</p>
<p>时间复杂度是 $O(n^2+m)$, $n$ 表示点数，$m$ 表示边数</p>
<h4 id="模板-7"><a href="#模板-7" class="headerlink" title="模板"></a>模板</h4><pre><code class="lang-c++">int n;      // n表示点数
int g[N][N];        // 邻接矩阵，存储所有边
int dist[N];        // 存储其他点到当前最小生成树的距离
bool st[N];     // 存储每个点是否已经在生成树中


// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和
int prim()
{
    memset(dist, 0x3f, sizeof dist);

    int res = 0;
    for (int i = 0; i &lt; n; i ++ )
    {
        int t = -1;
        for (int j = 1; j &lt;= n; j ++ )
            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))//类似迪杰 找最小的方法
                t = j;

        if (i &amp;&amp; dist[t] == INF) return INF;//必须有2个点及以上  同时还要求dist[t] == INF 说明不是连通图

        if (i) res += dist[t];//必须有2个点及以上总距离才有意义
        st[t] = true;//标记用过

        for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]);//用新加入的点更新dist
    }

    return res;
}
</code></pre>
<h5 id="模板解析-4"><a href="#模板解析-4" class="headerlink" title="模板解析"></a>模板解析</h5><h5 id="Prim算法与Dijkstra算法的区别-dist数组含义不同"><a href="#Prim算法与Dijkstra算法的区别-dist数组含义不同" class="headerlink" title="Prim算法与Dijkstra算法的区别    dist数组含义不同"></a>Prim算法与Dijkstra算法的区别    dist数组含义不同</h5><p>Dijkstra算法是更新不在集合中的点 离起点的距离</p>
<p><em>dist[j]=min(dist[j], dist[t]+g[t][j])</em></p>
<p>Prim是更新不在集合中的点 离集合S的距离</p>
<p><em>dist[j] = min(dist[j], g[t][j])</em></p>
<p>内部过程  每次都找离集合最近点 然后加入</p>
<p><img src="3.2.2h.png" alt=""></p>
<p><img src="3.2.2i.png" alt=""></p>
<p><img src="3.2.2j.png" alt=""></p>
<h4 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h4><p><img src="3.2.2k.png" alt=""></p>
<h4 id="例题-Prim算法求最小生成树"><a href="#例题-Prim算法求最小生成树" class="headerlink" title="例题   Prim算法求最小生成树"></a>例题   Prim算法求最小生成树</h4><p>给定一个 $n$个点 $m$条边的无向图，图中可能存在重边和自环，边权可能为负数。</p>
<p>求最小生成树的树边权重之和，如果最小生成树不存在则输出 <em>impossible</em>。</p>
<p>给定一张边带权的无向图 $G=(V,E)$，其中 $V$ 表示图中点的集合，$E$ 表示图中边的集合，$n=|V|$，$m=|E|$。</p>
<p>由 $V$  中的全部  $n$个顶点和 $E$ 中  $n-1$ 条边构成的无向连通子图被称为$ G$ 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 $G$的最小生成树。</p>
<h4 id="输入格式-13"><a href="#输入格式-13" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 $n$和 $m$。</p>
<p>接下来 $m$ 行，每行包含三个整数 $u,v,w$，表示点 $u$ 和点 $v$ 之间存在一条权值为 $w$ 的边。</p>
<h4 id="输出格式-13"><a href="#输出格式-13" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 <em>impossible</em>。</p>
<h4 id="数据范围-12"><a href="#数据范围-12" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤n≤500$,<br>$1≤m≤10^5$,<br>图中涉及边的边权的绝对值均不超过 $10000$。</p>
<h4 id="输入样例：-11"><a href="#输入样例：-11" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>4 5
1 2 1
1 3 2
1 4 3
2 3 2
3 4 4
</code></pre><h4 id="输出样例：-11"><a href="#输出样例：-11" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>6
</code></pre><h5 id="参考代码-9"><a href="#参考代码-9" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="lang-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
using namespace std;
const int N=510;
int g[N][N];
int st[N];
int dist[N];
int n,m;
int prim()
{
    int res=0;
    memset(dist,0x3f,sizeof dist);
    for (int i = 0; i &lt; n; ++i) {
        int t=-1;
        for (int j = 1; j &lt;=n ; ++j) {
            if(st[j]==0&amp;&amp;(t==-1||dist[t]&gt;dist[j]))
            {
                t=j;
            }
        }
        if(i&amp;&amp;dist[t]==0x3f3f3f3f)return 0x3f3f3f3f;
        if(i)res+=dist[t];
        st[t]=true;
        for(int j=1;j&lt;=n;j++)
        {
            dist[j]= min(dist[j],g[t][j]);
        }
    }
    return res;
}
int main() {
    cin&gt;&gt;n&gt;&gt;m;
    memset(g,0x3f,sizeof g);
    for (int i = 0; i &lt; m; ++i) {
        int x,y,t;
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;t;
        g[x][y]=g[y][x]= min(g[x][y],t);//重边取最小的
    }
    int t=prim();
    if(t==0x3f3f3f3f)
    {
        cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;
    } else
    {
        cout&lt;&lt;t&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<h5 id="跟模板一样"><a href="#跟模板一样" class="headerlink" title="跟模板一样"></a>跟模板一样</h5><h3 id="3-4-2-Kruskal算法"><a href="#3-4-2-Kruskal算法" class="headerlink" title="3.4.2  Kruskal算法"></a>3.4.2  Kruskal算法</h3><p>Kruskal 算法是能够在O(mlogm) 的时间内得到一个最小生成树的算 法。它主要是基于贪心的思想：</p>
<p>① 将边按照边权从小到大排序，并建立一个没有边的图T。</p>
<p>② 选出一条没有被选过的边权最小的边。</p>
<p>③ 如果这条边两个顶点在T 中所在的连通块不相同，那么将 它加入图T， 相同就跳过。（即加入这条边后出现回路，说明不能加它）</p>
<p>④ 重复②和③直到图T 连通为止。<br>其实这里只需要维护连通性，可以不需要真正建立图T，还可以用并查集 来维护。</p>
<h4 id="模板-8"><a href="#模板-8" class="headerlink" title="模板"></a>模板</h4><pre><code class="lang-c++">int n, m;       // n是点数，m是边数
int p[N];       // 并查集的父节点数组

struct Edge     // 存储边
{
    int a, b, w;
    bool operator&lt; (const Edge &amp;W)const//重载小于运算符
    {
        return w &lt; W.w;//按权重  从小到大排序
    }
}edges[M];

int find(int x)     // 并查集核心操作
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int kruskal()
{
    sort(edges, edges + m);//排序

    for (int i = 1; i &lt;= n; i ++ ) p[i] = i;    // 初始化并查集

    int res = 0, cnt = 0;
    for (int i = 0; i &lt; m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;

        a = find(a), b = find(b);
        if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并
        {
            p[a] = b;
            res += w;//记录总权重
            cnt ++ ;//记录生成树中包含点的个数
        }
    }

    if (cnt &lt; n - 1) return INF;
    return res;
}
</code></pre>
<h4 id="模板解析-5"><a href="#模板解析-5" class="headerlink" title="模板解析"></a>模板解析</h4><p>先按权重给每条边排序，每次选择最小且加入不会产生回路的边</p>
<p><img src="1.png" alt=""></p>
<p><img src="2.png" alt=""></p>
<p><img src="3.png" alt=""></p>
<p><img src="4.png" alt=""></p>
<p><img src="5.png" alt=""></p>
<p><img src="6.png" alt=""></p>
<h4 id="例题-Kruskal算法求最小生成树"><a href="#例题-Kruskal算法求最小生成树" class="headerlink" title="例题   Kruskal算法求最小生成树"></a>例题   Kruskal算法求最小生成树</h4><p>给定一个 $n$ 个点 $m$ 条边的无向图，图中可能存在重边和自环，边权可能为负数。</p>
<p>求最小生成树的树边权重之和，如果最小生成树不存在则输出 <em>impossible</em>。</p>
<p>给定一张边带权的无向图 $G=(V,E)$，其中 $V$ 表示图中点的集合，$E$ 表示图中边的集合，$n=|V|，m=|E|$。</p>
<p>由 $V$ 中的全部 $n$ 个顶点和 $E$ 中$n−1 $条边构成的无向连通子图被称为 $G$ 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 $G$ 的最小生成树。</p>
<h5 id="输入格式-14"><a href="#输入格式-14" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含两个整数 $n$和 $m$。</p>
<p>接下来 $m$ 行，每行包含三个整数 $u,v,w$，表示点 $u$ 和点 $v$ 之间存在一条权值为 $w$ 的边。</p>
<h5 id="输出格式-14"><a href="#输出格式-14" class="headerlink" title="输出格式"></a>输出格式</h5><p>共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 <em>impossible</em>。</p>
<h5 id="数据范围-13"><a href="#数据范围-13" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n≤10^5$,<br>$1≤m≤2∗10^5$,<br>图中涉及边的边权的绝对值均不超过 $1000$。</p>
<h5 id="输入样例：-12"><a href="#输入样例：-12" class="headerlink" title="输入样例："></a>输入样例：</h5><pre><code>4 5
1 2 1
1 3 2
1 4 3
2 3 2
3 4 4
</code></pre><h5 id="输出样例：-12"><a href="#输出样例：-12" class="headerlink" title="输出样例："></a>输出样例：</h5><pre><code>6
</code></pre><h5 id="参考代码-10"><a href="#参考代码-10" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="lang-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N=100010,M=200010;
int n,m;
int p[N];
struct edge{
    int a,b,w;
    bool operator&lt;(struct edge x)const{
        return w&lt;x.w;
    }
}e[M];
int find(int x)
{
    if(p[x]!=x)p[x]= find(p[x]);
    return p[x];
}
int kruka()
{
    sort(e,e+m);
    for(int i=1;i&lt;=n;i++)p[i]=i;
    int res=0,cnt=0;
    for(int i=0;i&lt;m;i++)
    {
        int a=e[i].a,b=e[i].b,w=e[i].w;
        int x= find(a),y=find(b);
        if(x!=y)
        {
            p[x]=y;
            res+=w;
            cnt++;
        }
    }
    if(cnt&lt;n-1)return 0x3f3f3f3f;
    return res;
}
int main() {
    cin&gt;&gt;n&gt;&gt;m;
    for (int i = 0; i &lt; m; ++i) {
        int x,y,t;
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;t;
        e[i].a=x;
        e[i].b=y;
        e[i].w=t;
    }
    int t=kruka();
    if(t==0x3f3f3f3f)
    {
        cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;
    } else
    {
        cout&lt;&lt;t&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<h5 id="跟模板相同"><a href="#跟模板相同" class="headerlink" title="跟模板相同"></a>跟模板相同</h5><h2 id="3-5-二分图：染色法、匈牙利算法"><a href="#3-5-二分图：染色法、匈牙利算法" class="headerlink" title="3.5 二分图：染色法、匈牙利算法"></a>3.5 二分图：染色法、匈牙利算法</h2><h3 id="3-5-1-染色法判别二分图"><a href="#3-5-1-染色法判别二分图" class="headerlink" title="3.5.1  染色法判别二分图"></a>3.5.1  染色法判别二分图</h3><p>时间复杂度是 $O(n+m)$, $n$ 表示点数，$m$ 表示边数</p>
<p>将所有点分成两个集合，使得所有边只出现在集合之间，就是二分图</p>
<p>二分图当且仅当图中不含奇数环（环中边数是奇数）即一定不含有奇数环，可能包含长度为偶数的环， 不一定是连通图。</p>
<h4 id="模板-9"><a href="#模板-9" class="headerlink" title="模板"></a>模板</h4><pre><code class="lang-c++">int n;      // n表示点数
int h[N], e[M], ne[M], idx;     // 邻接表存储图
int color[N];       // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色

// 参数：u表示当前节点，c表示当前点的颜色
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])//给与u相连的所有点 染色
    {
        int j = e[i];
        if (color[j] == -1)//j点没有染色
        {
            if (!dfs(j, !c)) return false;//必须染不同的颜色 即!c
            //同时若该点染色失败返回 false
        }
        else if (color[j] == c) return false;//相邻两点 染色相同
    }

    return true;
}

bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i &lt;= n; i ++ )//有可能不是连通图，一次深搜可能搜不到
        if (color[i] == -1)//如果没染色
            if (!dfs(i, 0))//如果染色失败
            {
                flag = false;
                break;
            }
    return flag;
}
</code></pre>
<h4 id="模板解析-6"><a href="#模板解析-6" class="headerlink" title="模板解析"></a>模板解析</h4><p>  代码思路：<br>     染色可以使用<em>1</em>和<em>0</em>区分不同颜色，用<em>-1</em>表示未染色<br>     遍历所有点，每次将未染色的点进行dfs, 默认染成<em>1</em>或者<em>0</em><br>     由于<strong>某个点染色成功不代表整个图就是二分图,</strong></p>
<p>​     因此只有某个点染色<strong>失败才能立刻  break/return</strong><br>​     <strong>染色失败</strong>相当于存在相邻的2个点染了相同的颜色</p>
<h4 id="例题-染色法判定二分图"><a href="#例题-染色法判定二分图" class="headerlink" title="例题  染色法判定二分图"></a>例题  染色法判定二分图</h4><p>给定一个 $n$ 个点 $m$ 条边的无向图，图中可能存在重边和自环。</p>
<p>请你判断这个图是否是二分图。</p>
<h5 id="输入格式-15"><a href="#输入格式-15" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含两个整数 $n$ 和 $m$。</p>
<p>接下来 $m$ 行，每行包含两个整数 $u$ 和 $v$，表示点 $u$ 和点 $v$ 之间存在一条边。</p>
<h5 id="输出格式-15"><a href="#输出格式-15" class="headerlink" title="输出格式"></a>输出格式</h5><p>如果给定图是二分图，则输出 <em>Yes</em>，否则输出 <em>No</em>。</p>
<h5 id="数据范围-14"><a href="#数据范围-14" class="headerlink" title="数据范围"></a>数据范围</h5><p>$1≤n,m≤10^5$</p>
<h5 id="输入样例：-13"><a href="#输入样例：-13" class="headerlink" title="输入样例："></a>输入样例：</h5><pre><code>4 4
1 3
1 4
2 3
2 4
</code></pre><h5 id="输出样例：-13"><a href="#输出样例：-13" class="headerlink" title="输出样例："></a>输出样例：</h5><pre><code>Yes
</code></pre><h5 id="参考代码-11"><a href="#参考代码-11" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="lang-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
using namespace std;
int n,m;
const int N=100010,M=200010;
int h[N],e[M],ne[M],idx;
int color[N];
pair&lt;int,int&gt;q[N];
typedef struct node{
    int x;
    int c;
}node;
void add(int a,int b)
{
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx++;
}
bool bfs(node start)
{
    pair&lt;int,int&gt; now,next;
    int hh=0,tt=-1;
    q[++tt]={start.x,start.c};//入队

    while (hh&lt;=tt)//当队不为空
    {
        now=q[hh];//取队头
        hh++;//弹出
        int ii=now.first,colo=now.second;//编号 和 颜色种类
        for(int i=h[ii];i!=-1;i=ne[i])//遍历所有与 ii相连的点
        {
            int j=e[i];
            if(color[j]==-1)//未染色
            {
                next.first=j;//记录j
                next.second=!colo;//不同颜色
                color[j]=!colo;//记录已经染过颜色了
                q[++tt]=(next);//入队
            } else if(color[j]==colo)//染色矛盾
            {
                return false;
            }
        }
    }
    return true;
}
bool check_()
{
    memset(color,-1,sizeof color);
    for(int i=1;i&lt;=n;i++)//目的同dfs
    {
        if(color[i]==-1)
        {
            node k{i,0};//上来先染个 0（啥都行无所谓）
            if(!bfs(k))//有一个不成立就不行
                return false;
        }
    }
    return true;
}
int main() {
    cin&gt;&gt;n&gt;&gt;m;
    memset(h,-1,sizeof h);
    for(int i=0;i&lt;m;i++)
    {
        int a,b;
        cin&gt;&gt;a&gt;&gt;b;
        add(a,b);
        add(b,a);
    }
    bool t=check_();
    if(t)
    {
        cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;
    }else
    {
        cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<h5 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h5><p>由于数据量太大，所以要用bfs</p>
<p>bfs基本思想</p>
<p><img src="1111.png" alt=""></p>
<h3 id="3-4-2-匈牙利算法"><a href="#3-4-2-匈牙利算法" class="headerlink" title="3.4.2 匈牙利算法"></a>3.4.2 匈牙利算法</h3><p>时间复杂度是 $O(nm)$, $n$ 表示点数，$m$ 表示边数.</p>
<h4 id="模板-10"><a href="#模板-10" class="headerlink" title="模板"></a>模板</h4><pre><code class="lang-c++">int n1, n2;     // n1表示第一个集合中的点数，n2表示第二个集合中的点数
int h[N], e[M], ne[M], idx;     // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边
int match[N];       // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个
bool st[N];     // 表示第二个集合中的每个点是否已经被遍历过

bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }

    return false;
}

// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点
int res = 0;
for (int i = 1; i &lt;= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
</code></pre>
<h4 id="例题-二分图的最大匹配"><a href="#例题-二分图的最大匹配" class="headerlink" title="例题  二分图的最大匹配"></a>例题  二分图的最大匹配</h4><p>给定一个二分图，其中左半部包含n~1~ 个点（编号 1∼n~1~），右半部包含 n~2~ 个点（编号 1∼n~2~），二分图共包含$ m$ 条边。</p>
<p>数据保证任意一条边的两个端点都不可能在同一部分中。</p>
<p>请你求出二分图的最大匹配数。</p>
<blockquote>
<p>二分图的匹配：给定一个二分图 $G$，在 $G$ 的一个子图 $M$ 中，$M$ 的边集 ${E}$ 中的任意两条边都不依附于同一个顶点，则称 $M$ 是一个匹配。</p>
<p>二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。</p>
</blockquote>
<h4 id="输入格式-16"><a href="#输入格式-16" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含三个整数 n~1~、 n~2~ 和 $m$。</p>
<p>接下来 $m$ 行，每行包含两个整数 $u$ 和 $v$，表示左半部点集中的点 $u$ 和右半部点集中的点 $v$ 之间存在一条边。</p>
<h4 id="输出格式-16"><a href="#输出格式-16" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示二分图的最大匹配数。</p>
<h4 id="数据范围-15"><a href="#数据范围-15" class="headerlink" title="数据范围"></a>数据范围</h4><p><strong>1≤n~1~,n~2~≤500,</strong><br><strong>1≤u≤n~1~,</strong><br><strong>1≤v≤n~2~,</strong><br>$1≤m≤10^5$</p>
<h4 id="输入样例：-14"><a href="#输入样例：-14" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>2 2 4
1 1
1 2
2 1
2 2
</code></pre><h4 id="输出样例：-14"><a href="#输出样例：-14" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>2
</code></pre><h5 id="参考代码-12"><a href="#参考代码-12" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code class="lang-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;
int n1,n2,m;
const int N=510,M=100010;
int h[N],e[M],ne[M],idx;
int match[N];  //match[j]=a,表示女孩j的现有配对男友是a
bool st[N];// st[a] = true 说明女生 a 目前被一个男生预定了
void add(int a,int b)
{
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx++;
}
int find_(int k)
{
    for(int i=h[k];i!=-1;i=ne[i])
    {
        int j=e[i];
        if(!st[j])//女生还没有男友
        {
            st[j]= true;//那k就预定这个女孩了
            if(match[j]==0|| find_(match[j]))
                //如果女孩j没有男朋友，或者她原来的男朋友能够换一个喜欢的女孩。配对成功,更新match
            {
                match[j]=k;
                return true;
            }
        }
    }
    return false;    //自己中意的全部都被预定了。配对失败。
}
int main() {
    cin&gt;&gt;n1&gt;&gt;n2&gt;&gt;m;
    memset(h,-1,sizeof h);
    for (int i = 0; i &lt; m; ++i) {
        int a,b;
        cin&gt;&gt;a&gt;&gt;b;
        add(a,b);

    }
    int res=0;
    for(int i=1;i&lt;=n1;i++)// 尝试为每个男生做一轮深搜找对象（成功后总匹配数增加1）
    {
        memset(st,false,sizeof st);//每次都覆盖即每次都考虑全体女生 即使她们有男友
        //因为即使有男友你可以换嘛，所以你不能不考虑 match是记录 st代表目前考虑不考虑
        if(find_(i))res++;
    }
    cout&lt;&lt;res&lt;&lt;endl;
    return 0;
}
</code></pre>
<h5 id="代码解析-1"><a href="#代码解析-1" class="headerlink" title="代码解析"></a>代码解析</h5><p>二分图的匹配 不存在2条边共用一个点</p>
<p>男生是左边 n~1~点们  女生是右面 n~2~点们</p>
<p>类比成恋爱中的男女 并且不能脚踏多条船</p>
<p><img src="2212.png" alt=""></p>
<h1 id="谢谢大家"><a href="#谢谢大家" class="headerlink" title="谢谢大家"></a>谢谢大家</h1>